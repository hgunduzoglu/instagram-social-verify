/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EthAddress } from '@aztec/foundation/eth-address';
import type { ViemSignature } from '@aztec/foundation/eth-signature';
import { RollupAbi } from '@aztec/l1-artifacts/RollupAbi';
import { type Account, type GetContractReturnType, type Hex } from 'viem';
import type { DeployL1ContractsReturnType } from '../deploy_l1_contracts.js';
import type { L1ContractAddresses } from '../l1_contract_addresses.js';
import type { L1ReaderConfig } from '../l1_reader.js';
import type { ViemClient } from '../types.js';
import { SlashingProposerContract } from './slashing_proposer.js';
export type L1RollupContractAddresses = Pick<L1ContractAddresses, 'rollupAddress' | 'inboxAddress' | 'outboxAddress' | 'feeJuicePortalAddress' | 'feeJuiceAddress' | 'stakingAssetAddress' | 'rewardDistributorAddress' | 'slashFactoryAddress'>;
export type EpochProofPublicInputArgs = {
    previousArchive: `0x${string}`;
    endArchive: `0x${string}`;
    endTimestamp: bigint;
    outHash: `0x${string}`;
    proverId: `0x${string}`;
};
export declare class RollupContract {
    readonly client: ViemClient;
    private readonly rollup;
    static get checkBlobStorageSlot(): bigint;
    static getFromL1ContractsValues(deployL1ContractsValues: DeployL1ContractsReturnType): RollupContract;
    static getFromConfig(config: L1ReaderConfig): RollupContract;
    constructor(client: ViemClient, address: Hex | EthAddress);
    get address(): `0x${string}`;
    getContract(): GetContractReturnType<typeof RollupAbi, ViemClient>;
    getSlashingProposer(): Promise<SlashingProposerContract>;
    getL1StartBlock(): Promise<bigint>;
    getL1GenesisTime(): Promise<bigint>;
    getProofSubmissionWindow(): Promise<bigint>;
    getEpochDuration(): Promise<bigint>;
    getSlotDuration(): Promise<bigint>;
    getTargetCommitteeSize(): Promise<bigint>;
    getMinimumStake(): Promise<bigint>;
    getManaTarget(): Promise<bigint>;
    getProvingCostPerMana(): Promise<bigint>;
    getProvingCostPerManaInFeeAsset(): Promise<bigint>;
    getManaLimit(): Promise<bigint>;
    getVersion(): Promise<bigint>;
    getGenesisArchiveTreeRoot(): Promise<`0x${string}`>;
    getSlasher(): Promise<`0x${string}`>;
    getSlashingProposerAddress(): Promise<EthAddress>;
    getBlockNumber(): Promise<bigint>;
    getProvenBlockNumber(): Promise<bigint>;
    getSlotNumber(): Promise<bigint>;
    getCommitteeAt(timestamp: bigint): Promise<readonly `0x${string}`[]>;
    getSampleSeedAt(timestamp: bigint): Promise<bigint>;
    getCurrentSampleSeed(): Promise<bigint>;
    getCurrentEpoch(): Promise<bigint>;
    getCurrentEpochCommittee(): Promise<readonly `0x${string}`[]>;
    getCurrentProposer(): Promise<`0x${string}`>;
    getProposerAt(timestamp: bigint): Promise<`0x${string}`>;
    getEpochCommittee(epoch: bigint): Promise<readonly `0x${string}`[]>;
    getBlock(blockNumber: bigint): Promise<{
        archive: `0x${string}`;
        slotNumber: bigint;
    }>;
    getTips(): Promise<{
        pendingBlockNumber: bigint;
        provenBlockNumber: bigint;
    }>;
    getTimestampForSlot(slot: bigint): Promise<bigint>;
    getEpochNumber(blockNumber?: bigint): Promise<bigint>;
    getRollupAddresses(): Promise<L1RollupContractAddresses>;
    getFeeJuicePortal(): Promise<EthAddress>;
    getEpochNumberForSlotNumber(slotNumber: bigint): Promise<bigint>;
    getEpochProofPublicInputs(args: readonly [bigint, bigint, EpochProofPublicInputArgs, readonly `0x${string}`[], `0x${string}`]): Promise<readonly `0x${string}`[]>;
    validateHeader(args: readonly [
        `0x${string}`,
        ViemSignature[],
        `0x${string}`,
        bigint,
        `0x${string}`,
        {
            ignoreDA: boolean;
            ignoreSignatures: boolean;
        }
    ], account: `0x${string}` | Account): Promise<void>;
    /**
     * @notice  Calls `canProposeAtTime` with the time of the next Ethereum block and the sender address
     *
     * @dev     Throws if unable to propose
     *
     * @param archive - The archive that we expect to be current state
     * @return [slot, blockNumber] - If you can propose, the L2 slot number and L2 block number of the next Ethereum block,
     * @throws otherwise
     */
    canProposeAtNextEthBlock(archive: Buffer, account: `0x${string}` | Account, slotDuration: bigint | number): Promise<[bigint, bigint]>;
    /** Calls getHasSubmitted directly. Returns whether the given prover has submitted a proof with the given length for the given epoch. */
    getHasSubmittedProof(epochNumber: number, numberOfBlocksInEpoch: number, prover: Hex | EthAddress): Promise<boolean>;
    getManaBaseFeeAt(timestamp: bigint, inFeeAsset: boolean): Promise<bigint>;
    getSlotAt(timestamp: bigint): Promise<bigint>;
    status(blockNumber: bigint, options?: {
        blockNumber?: bigint;
    }): Promise<readonly [bigint, `0x${string}`, bigint, `0x${string}`, `0x${string}`, bigint]>;
    canPruneAtTime(timestamp: bigint, options?: {
        blockNumber?: bigint;
    }): Promise<boolean>;
    archive(): Promise<`0x${string}`>;
    archiveAt(blockNumber: bigint): Promise<`0x${string}`>;
    getSequencerRewards(address: Hex | EthAddress): Promise<bigint>;
    getSpecificProverRewardsForEpoch(epoch: bigint, prover: Hex | EthAddress): Promise<bigint>;
    getAttesters(): Promise<readonly `0x${string}`[]>;
    getInfo(address: Hex | EthAddress): Promise<{
        stake: bigint;
        withdrawer: `0x${string}`;
        proposer: `0x${string}`;
        status: number;
    }>;
    getBlobPublicInputsHash(blockNumber: bigint): Promise<`0x${string}`>;
    getStakingAsset(): Promise<`0x${string}`>;
    getProposerForAttester(attester: Hex | EthAddress): Promise<`0x${string}`>;
}
//# sourceMappingURL=rollup.d.ts.map