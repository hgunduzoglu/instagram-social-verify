import { EthAddress } from '@aztec/foundation/eth-address';
import { createLogger } from '@aztec/foundation/log';
import { RegistryAbi } from '@aztec/l1-artifacts/RegistryAbi';
import { TestERC20Abi } from '@aztec/l1-artifacts/TestERC20Abi';
import { getContract } from 'viem';
import { ReadOnlyGovernanceContract } from './governance.js';
import { RollupContract } from './rollup.js';
export class RegistryContract {
    client;
    address;
    log;
    registry;
    constructor(client, address){
        this.client = client;
        this.log = createLogger('ethereum:contracts:registry');
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        this.address = EthAddress.fromString(address);
        this.registry = getContract({
            address,
            abi: RegistryAbi,
            client
        });
    }
    /**
   * Returns the address of the rollup for a given version.
   * @param version - The version of the rollup. 'canonical' can be used to get the canonical address (i.e. the latest version).
   * @returns The address of the rollup. If the rollup is not set for this version, throws an error.
   */ async getRollupAddress(version) {
        if (version === 'canonical') {
            return this.getCanonicalAddress();
        }
        if (typeof version === 'number') {
            version = BigInt(version);
        }
        try {
            return EthAddress.fromString(await this.registry.read.getRollup([
                version
            ]));
        } catch (e) {
            this.log.warn(`Failed fetching rollup address for version ${version}. Retrying as index.`);
        }
        try {
            const actualVersion = await this.registry.read.getVersion([
                version
            ]);
            const rollupAddress = await this.registry.read.getRollup([
                actualVersion
            ]);
            return EthAddress.fromString(rollupAddress);
        } catch (e) {
            throw new Error('Rollup address is undefined');
        }
    }
    /**
   * Returns the canonical address of the rollup.
   * @returns The canonical address of the rollup. If the rollup is not set, throws an error.
   */ async getCanonicalAddress() {
        return EthAddress.fromString(await this.registry.read.getCanonicalRollup());
    }
    async getGovernanceAddresses() {
        const governanceAddress = await this.registry.read.getGovernance();
        const governance = new ReadOnlyGovernanceContract(governanceAddress, this.client);
        const governanceProposerAddress = await governance.getGovernanceProposerAddress();
        return {
            governanceAddress: governance.address,
            governanceProposerAddress: governanceProposerAddress
        };
    }
    static async collectAddresses(client, registryAddress, rollupVersion) {
        const registry = new RegistryContract(client, registryAddress);
        const governanceAddresses = await registry.getGovernanceAddresses();
        const rollupAddress = await registry.getRollupAddress(rollupVersion);
        if (rollupAddress === undefined) {
            throw new Error('Rollup address is undefined');
        }
        const rollup = new RollupContract(client, rollupAddress);
        const addresses = await rollup.getRollupAddresses();
        const feeAsset = getContract({
            address: addresses.feeJuiceAddress.toString(),
            abi: TestERC20Abi,
            client
        });
        const coinIssuer = await feeAsset.read.owner();
        return {
            registryAddress: registry.address,
            ...governanceAddresses,
            ...addresses,
            coinIssuerAddress: EthAddress.fromString(coinIssuer)
        };
    }
    async getNumberOfVersions() {
        const version = await this.registry.read.numberOfVersions();
        return Number(version);
    }
    async getRollupVersions() {
        const count = await this.getNumberOfVersions();
        const versions = [];
        for(let i = 0; i < count; i++){
            versions.push(await this.registry.read.getVersion([
                BigInt(i)
            ]));
        }
        return versions;
    }
    async getRewardDistributor() {
        return EthAddress.fromString(await this.registry.read.getRewardDistributor());
    }
}
