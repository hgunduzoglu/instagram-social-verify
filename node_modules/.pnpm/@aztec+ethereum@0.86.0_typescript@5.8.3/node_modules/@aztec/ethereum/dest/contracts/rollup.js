function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
import { memoize } from '@aztec/foundation/decorators';
import { EthAddress } from '@aztec/foundation/eth-address';
import { RollupAbi } from '@aztec/l1-artifacts/RollupAbi';
import { RollupStorage } from '@aztec/l1-artifacts/RollupStorage';
import { SlasherAbi } from '@aztec/l1-artifacts/SlasherAbi';
import { getAddress, getContract } from 'viem';
import { getPublicClient } from '../client.js';
import { formatViemError } from '../utils.js';
import { SlashingProposerContract } from './slashing_proposer.js';
export class RollupContract {
    client;
    rollup;
    static get checkBlobStorageSlot() {
        const asString = RollupStorage.find((storage)=>storage.label === 'checkBlob')?.slot;
        if (asString === undefined) {
            throw new Error('checkBlobStorageSlot not found');
        }
        return BigInt(asString);
    }
    static getFromL1ContractsValues(deployL1ContractsValues) {
        const { l1Client, l1ContractAddresses: { rollupAddress } } = deployL1ContractsValues;
        return new RollupContract(l1Client, rollupAddress.toString());
    }
    static getFromConfig(config) {
        const client = getPublicClient(config);
        const address = config.l1Contracts.rollupAddress.toString();
        return new RollupContract(client, address);
    }
    constructor(client, address){
        this.client = client;
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        this.rollup = getContract({
            address,
            abi: RollupAbi,
            client
        });
    }
    get address() {
        return this.rollup.address;
    }
    getContract() {
        return this.rollup;
    }
    async getSlashingProposer() {
        const slasherAddress = await this.rollup.read.getSlasher();
        const slasher = getContract({
            address: slasherAddress,
            abi: SlasherAbi,
            client: this.client
        });
        const proposerAddress = await slasher.read.PROPOSER();
        return new SlashingProposerContract(this.client, proposerAddress);
    }
    getL1StartBlock() {
        return this.rollup.read.L1_BLOCK_AT_GENESIS();
    }
    getL1GenesisTime() {
        return this.rollup.read.getGenesisTime();
    }
    getProofSubmissionWindow() {
        return this.rollup.read.getProofSubmissionWindow();
    }
    getEpochDuration() {
        return this.rollup.read.getEpochDuration();
    }
    getSlotDuration() {
        return this.rollup.read.getSlotDuration();
    }
    getTargetCommitteeSize() {
        return this.rollup.read.getTargetCommitteeSize();
    }
    getMinimumStake() {
        return this.rollup.read.getMinimumStake();
    }
    getManaTarget() {
        return this.rollup.read.getManaTarget();
    }
    getProvingCostPerMana() {
        return this.rollup.read.getProvingCostPerManaInEth();
    }
    getProvingCostPerManaInFeeAsset() {
        return this.rollup.read.getProvingCostPerManaInFeeAsset();
    }
    getManaLimit() {
        return this.rollup.read.getManaLimit();
    }
    getVersion() {
        return this.rollup.read.getVersion();
    }
    async getGenesisArchiveTreeRoot() {
        const block = await this.rollup.read.getBlock([
            0n
        ]);
        return block.archive;
    }
    getSlasher() {
        return this.rollup.read.getSlasher();
    }
    async getSlashingProposerAddress() {
        const slasherAddress = await this.getSlasher();
        const slasher = getContract({
            address: getAddress(slasherAddress.toString()),
            abi: SlasherAbi,
            client: this.client
        });
        return EthAddress.fromString(await slasher.read.PROPOSER());
    }
    getBlockNumber() {
        return this.rollup.read.getPendingBlockNumber();
    }
    getProvenBlockNumber() {
        return this.rollup.read.getProvenBlockNumber();
    }
    getSlotNumber() {
        return this.rollup.read.getCurrentSlot();
    }
    async getCommitteeAt(timestamp) {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCommitteeAt',
            args: [
                timestamp
            ]
        });
        return result;
    }
    getSampleSeedAt(timestamp) {
        return this.rollup.read.getSampleSeedAt([
            timestamp
        ]);
    }
    getCurrentSampleSeed() {
        return this.rollup.read.getCurrentSampleSeed();
    }
    getCurrentEpoch() {
        return this.rollup.read.getCurrentEpoch();
    }
    async getCurrentEpochCommittee() {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCurrentEpochCommittee',
            args: []
        });
        return result;
    }
    async getCurrentProposer() {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCurrentProposer',
            args: []
        });
        return result;
    }
    async getProposerAt(timestamp) {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getProposerAt',
            args: [
                timestamp
            ]
        });
        return result;
    }
    async getEpochCommittee(epoch) {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getEpochCommittee',
            args: [
                epoch
            ]
        });
        return result;
    }
    getBlock(blockNumber) {
        return this.rollup.read.getBlock([
            blockNumber
        ]);
    }
    getTips() {
        return this.rollup.read.getTips();
    }
    getTimestampForSlot(slot) {
        return this.rollup.read.getTimestampForSlot([
            slot
        ]);
    }
    async getEpochNumber(blockNumber) {
        blockNumber ??= await this.getBlockNumber();
        return this.rollup.read.getEpochForBlock([
            BigInt(blockNumber)
        ]);
    }
    async getRollupAddresses() {
        const [inboxAddress, outboxAddress, feeJuicePortalAddress, rewardDistributorAddress, feeJuiceAddress, stakingAssetAddress] = (await Promise.all([
            this.rollup.read.getInbox(),
            this.rollup.read.getOutbox(),
            this.rollup.read.getFeeAssetPortal(),
            this.rollup.read.getRewardDistributor(),
            this.rollup.read.getFeeAsset(),
            this.rollup.read.getStakingAsset()
        ])).map(EthAddress.fromString);
        return {
            rollupAddress: EthAddress.fromString(this.address),
            inboxAddress,
            outboxAddress,
            feeJuicePortalAddress,
            feeJuiceAddress,
            stakingAssetAddress,
            rewardDistributorAddress
        };
    }
    async getFeeJuicePortal() {
        return EthAddress.fromString(await this.rollup.read.getFeeAssetPortal());
    }
    async getEpochNumberForSlotNumber(slotNumber) {
        return await this.rollup.read.getEpochAtSlot([
            slotNumber
        ]);
    }
    getEpochProofPublicInputs(args) {
        return this.rollup.read.getEpochProofPublicInputs(args);
    }
    async validateHeader(args, account) {
        try {
            await this.client.simulateContract({
                address: this.address,
                abi: RollupAbi,
                functionName: 'validateHeader',
                args,
                account
            });
        } catch (error) {
            throw formatViemError(error);
        }
    }
    /**
   * @notice  Calls `canProposeAtTime` with the time of the next Ethereum block and the sender address
   *
   * @dev     Throws if unable to propose
   *
   * @param archive - The archive that we expect to be current state
   * @return [slot, blockNumber] - If you can propose, the L2 slot number and L2 block number of the next Ethereum block,
   * @throws otherwise
   */ async canProposeAtNextEthBlock(archive, account, slotDuration) {
        if (typeof slotDuration === 'number') {
            slotDuration = BigInt(slotDuration);
        }
        const timeOfNextL1Slot = (await this.client.getBlock()).timestamp + slotDuration;
        try {
            const { result: [slot, blockNumber] } = await this.client.simulateContract({
                address: this.address,
                abi: RollupAbi,
                functionName: 'canProposeAtTime',
                args: [
                    timeOfNextL1Slot,
                    `0x${archive.toString('hex')}`
                ],
                account
            });
            return [
                slot,
                blockNumber
            ];
        } catch (err) {
            throw formatViemError(err);
        }
    }
    /** Calls getHasSubmitted directly. Returns whether the given prover has submitted a proof with the given length for the given epoch. */ getHasSubmittedProof(epochNumber, numberOfBlocksInEpoch, prover) {
        if (prover instanceof EthAddress) {
            prover = prover.toString();
        }
        return this.rollup.read.getHasSubmitted([
            BigInt(epochNumber),
            BigInt(numberOfBlocksInEpoch),
            prover
        ]);
    }
    getManaBaseFeeAt(timestamp, inFeeAsset) {
        return this.rollup.read.getManaBaseFeeAt([
            timestamp,
            inFeeAsset
        ]);
    }
    getSlotAt(timestamp) {
        return this.rollup.read.getSlotAt([
            timestamp
        ]);
    }
    status(blockNumber, options) {
        return this.rollup.read.status([
            blockNumber
        ], options);
    }
    canPruneAtTime(timestamp, options) {
        return this.rollup.read.canPruneAtTime([
            timestamp
        ], options);
    }
    archive() {
        return this.rollup.read.archive();
    }
    archiveAt(blockNumber) {
        return this.rollup.read.archiveAt([
            blockNumber
        ]);
    }
    getSequencerRewards(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        return this.rollup.read.getSequencerRewards([
            address
        ]);
    }
    getSpecificProverRewardsForEpoch(epoch, prover) {
        if (prover instanceof EthAddress) {
            prover = prover.toString();
        }
        return this.rollup.read.getSpecificProverRewardsForEpoch([
            epoch,
            prover
        ]);
    }
    getAttesters() {
        return this.rollup.read.getAttesters();
    }
    getInfo(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        return this.rollup.read.getInfo([
            address
        ]);
    }
    getBlobPublicInputsHash(blockNumber) {
        return this.rollup.read.getBlobPublicInputsHash([
            blockNumber
        ]);
    }
    getStakingAsset() {
        return this.rollup.read.getStakingAsset();
    }
    getProposerForAttester(attester) {
        if (attester instanceof EthAddress) {
            attester = attester.toString();
        }
        return this.rollup.read.getProposerForAttester([
            attester
        ]);
    }
}
_ts_decorate([
    memoize
], RollupContract.prototype, "getSlashingProposer", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getL1StartBlock", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getL1GenesisTime", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getProofSubmissionWindow", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getEpochDuration", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getSlotDuration", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getTargetCommitteeSize", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getMinimumStake", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getManaTarget", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getProvingCostPerMana", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getProvingCostPerManaInFeeAsset", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getManaLimit", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getVersion", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getGenesisArchiveTreeRoot", null);
