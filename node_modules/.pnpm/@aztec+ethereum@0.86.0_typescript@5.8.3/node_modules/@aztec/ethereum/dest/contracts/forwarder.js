import { toHex } from '@aztec/foundation/bigint-buffer';
import { ForwarderAbi } from '@aztec/l1-artifacts/ForwarderAbi';
import { ForwarderBytecode } from '@aztec/l1-artifacts/ForwarderBytecode';
import { encodeFunctionData, getContract } from 'viem';
import { deployL1Contract, getExpectedAddress } from '../deploy_l1_contracts.js';
import { RollupContract } from './rollup.js';
export class ForwarderContract {
    client;
    rollupAddress;
    forwarder;
    constructor(client, address, rollupAddress){
        this.client = client;
        this.rollupAddress = rollupAddress;
        this.forwarder = getContract({
            address,
            abi: ForwarderAbi,
            client
        });
    }
    static expectedAddress(owner) {
        const { address } = getExpectedAddress(ForwarderAbi, ForwarderBytecode, [
            owner
        ], owner);
        return address;
    }
    static async create(owner, l1Client, logger, rollupAddress) {
        logger.info('Deploying forwarder contract');
        const { address, txHash } = await deployL1Contract(l1Client, ForwarderAbi, ForwarderBytecode, [
            owner
        ], owner, undefined, logger);
        if (txHash) {
            await l1Client.waitForTransactionReceipt({
                hash: txHash
            });
        }
        logger.info(`Forwarder contract deployed at ${address} with owner ${owner}`);
        return new ForwarderContract(l1Client, address.toString(), rollupAddress);
    }
    getAddress() {
        return this.forwarder.address;
    }
    async forward(requests, l1TxUtils, gasConfig, blobConfig, logger) {
        requests = requests.filter((request)=>request.to !== null);
        const toArgs = requests.map((request)=>request.to);
        const dataArgs = requests.map((request)=>request.data);
        const forwarderFunctionData = {
            abi: ForwarderAbi,
            functionName: 'forward',
            args: [
                toArgs,
                dataArgs
            ]
        };
        const encodedForwarderData = encodeFunctionData(forwarderFunctionData);
        const { receipt, gasPrice } = await l1TxUtils.sendAndMonitorTransaction({
            to: this.forwarder.address,
            data: encodedForwarderData
        }, gasConfig, blobConfig);
        if (receipt.status === 'success') {
            const stats = await l1TxUtils.getTransactionStats(receipt.transactionHash);
            return {
                receipt,
                gasPrice,
                stats
            };
        } else {
            logger.error('Forwarder transaction failed', undefined, {
                receipt
            });
            const args = {
                ...forwarderFunctionData,
                address: this.forwarder.address
            };
            let errorMsg;
            if (blobConfig) {
                const maxFeePerBlobGas = blobConfig.maxFeePerBlobGas ?? gasPrice.maxFeePerBlobGas;
                if (maxFeePerBlobGas === undefined) {
                    errorMsg = 'maxFeePerBlobGas is required to get the error message';
                } else {
                    logger.debug('Trying to get error from reverted tx with blob config');
                    errorMsg = await l1TxUtils.tryGetErrorFromRevertedTx(encodedForwarderData, args, {
                        blobs: blobConfig.blobs,
                        kzg: blobConfig.kzg,
                        maxFeePerBlobGas
                    }, [
                        {
                            address: this.rollupAddress,
                            stateDiff: [
                                {
                                    slot: toHex(RollupContract.checkBlobStorageSlot, true),
                                    value: toHex(0n, true)
                                }
                            ]
                        }
                    ]);
                }
            } else {
                logger.debug('Trying to get error from reverted tx without blob config');
                errorMsg = await l1TxUtils.tryGetErrorFromRevertedTx(encodedForwarderData, args, undefined, []);
            }
            return {
                receipt,
                gasPrice,
                errorMsg
            };
        }
    }
}
