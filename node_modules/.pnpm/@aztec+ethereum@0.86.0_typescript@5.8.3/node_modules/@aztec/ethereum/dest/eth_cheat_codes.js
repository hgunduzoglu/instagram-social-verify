import { toBigIntBE, toHex } from '@aztec/foundation/bigint-buffer';
import { keccak256 } from '@aztec/foundation/crypto';
import { jsonStringify } from '@aztec/foundation/json-rpc';
import { createLogger } from '@aztec/foundation/log';
import { createPublicClient, fallback, http } from 'viem';
/**
 * A class that provides utility functions for interacting with ethereum (L1).
 */ export class EthCheatCodes {
    rpcUrls;
    logger;
    publicClient;
    constructor(/**
     * The RPC URL to use for interacting with the chain
     */ rpcUrls, /**
     * The logger to use for the eth cheatcodes
     */ logger = createLogger('ethereum:cheat_codes')){
        this.rpcUrls = rpcUrls;
        this.logger = logger;
        this.publicClient = createPublicClient({
            transport: fallback(this.rpcUrls.map((url)=>http(url)))
        });
    }
    async rpcCall(method, params) {
        const paramsString = jsonStringify(params);
        this.logger.info(`Calling ${method} with params: ${paramsString} on ${this.rpcUrls.join(', ')}`);
        return await this.publicClient.transport.request({
            method,
            params
        });
    }
    /**
   * Get the auto mine status of the underlying chain
   * @returns True if automine is on, false otherwise
   */ async isAutoMining() {
        try {
            const res = await this.rpcCall('anvil_getAutomine', []);
            return res;
        } catch (err) {
            this.logger.error(`Calling "anvil_getAutomine" failed with:`, err);
        }
        return false;
    }
    /**
   * Get the current blocknumber
   * @returns The current block number
   */ async blockNumber() {
        const res = await this.rpcCall('eth_blockNumber', []);
        return parseInt(res, 16);
    }
    /**
   * Get the current chainId
   * @returns The current chainId
   */ async chainId() {
        const res = await this.rpcCall('eth_chainId', []);
        return parseInt(res, 16);
    }
    /**
   * Get the current timestamp
   * @returns The current timestamp
   */ async timestamp() {
        const res = await this.rpcCall('eth_getBlockByNumber', [
            'latest',
            true
        ]);
        return parseInt(res.timestamp, 16);
    }
    /**
   * Advance the chain by a number of blocks
   * @param numberOfBlocks - The number of blocks to mine
   */ async mine(numberOfBlocks = 1) {
        await this.doMine(numberOfBlocks);
        this.logger.warn(`Mined ${numberOfBlocks} L1 blocks`);
    }
    async doMine(numberOfBlocks = 1) {
        try {
            await this.rpcCall('hardhat_mine', [
                numberOfBlocks
            ]);
        } catch (err) {
            throw new Error(`Error mining: ${err}`);
        }
    }
    /**
   * Mines a single block with evm_mine
   */ async evmMine() {
        try {
            await this.rpcCall('evm_mine', []);
        } catch (err) {
            throw new Error(`Error mining: ${err}`);
        }
    }
    /**
   * Set the balance of an account
   * @param account - The account to set the balance for
   * @param balance - The balance to set
   */ async setBalance(account, balance) {
        try {
            await this.rpcCall('anvil_setBalance', [
                account.toString(),
                toHex(balance)
            ]);
        } catch (err) {
            throw new Error(`Error setting balance for ${account}: ${err}`);
        }
        this.logger.warn(`Set balance for ${account} to ${balance}`);
    }
    /**
   * Set the interval between blocks (block time)
   * @param interval - The interval to use between blocks
   */ async setBlockInterval(interval) {
        try {
            await this.rpcCall('anvil_setBlockTimestampInterval', [
                interval
            ]);
        } catch (err) {
            throw new Error(`Error setting block interval: ${err}`);
        }
        this.logger.warn(`Set L1 block interval to ${interval}`);
    }
    /**
   * Set the next block base fee per gas
   * @param baseFee - The base fee to set
   */ async setNextBlockBaseFeePerGas(baseFee) {
        try {
            await this.rpcCall('anvil_setNextBlockBaseFeePerGas', [
                baseFee.toString()
            ]);
        } catch (err) {
            throw new Error(`Error setting next block base fee per gas: ${err}`);
        }
        this.logger.warn(`Set L1 next block base fee per gas to ${baseFee}`);
    }
    /**
   * Set the interval between blocks (block time)
   * @param seconds - The interval to use between blocks
   */ async setIntervalMining(seconds) {
        try {
            await this.rpcCall('anvil_setIntervalMining', [
                seconds
            ]);
        } catch (err) {
            throw new Error(`Error setting interval mining: ${err}`);
        }
        this.logger.warn(`Set L1 interval mining to ${seconds} seconds`);
    }
    /**
   * Set the automine status of the underlying anvil chain
   * @param automine - The automine status to set
   */ async setAutomine(automine) {
        try {
            await this.rpcCall('anvil_setAutomine', [
                automine
            ]);
        } catch (err) {
            throw new Error(`Error setting automine: ${err}`);
        }
        this.logger.warn(`Set L1 automine to ${automine}`);
    }
    /**
   * Drop a transaction from the mempool
   * @param txHash - The transaction hash
   */ async dropTransaction(txHash) {
        try {
            await this.rpcCall('anvil_dropTransaction', [
                txHash
            ]);
        } catch (err) {
            throw new Error(`Error dropping transaction: ${err}`);
        }
        this.logger.warn(`Dropped transaction ${txHash}`);
    }
    /**
   * Set the next block timestamp
   * @param timestamp - The timestamp to set the next block to
   */ async setNextBlockTimestamp(timestamp) {
        try {
            await this.rpcCall('evm_setNextBlockTimestamp', [
                timestamp
            ]);
        } catch (err) {
            throw new Error(`Error setting next block timestamp: ${err.message}`);
        }
        this.logger.warn(`Set L1 next block timestamp to ${timestamp}`);
    }
    /**
   * Set the next block timestamp and mines the block
   * @param timestamp - The timestamp to set the next block to
   */ async warp(timestamp, silent = false) {
        try {
            await this.rpcCall('evm_setNextBlockTimestamp', [
                Number(timestamp)
            ]);
        } catch (err) {
            throw new Error(`Error warping: ${err}`);
        }
        await this.doMine();
        if (!silent) {
            this.logger.warn(`Warped L1 timestamp to ${timestamp}`);
        }
    }
    /**
   * Load the value at a storage slot of a contract address on eth
   * @param contract - The contract address
   * @param slot - The storage slot
   * @returns - The value at the storage slot
   */ async load(contract, slot) {
        const res = await this.rpcCall('eth_getStorageAt', [
            contract.toString(),
            toHex(slot),
            'latest'
        ]);
        return BigInt(res);
    }
    /**
   * Set the value at a storage slot of a contract address on eth
   * @param contract - The contract address
   * @param slot - The storage slot
   * @param value - The value to set the storage slot to
   */ async store(contract, slot, value) {
        // for the rpc call, we need to change value to be a 32 byte hex string.
        try {
            await this.rpcCall('hardhat_setStorageAt', [
                contract.toString(),
                toHex(slot),
                toHex(value, true)
            ]);
        } catch (err) {
            throw new Error(`Error setting storage for contract ${contract} at ${slot}: ${err}`);
        }
        this.logger.warn(`Set L1 storage for contract ${contract} at ${slot} to ${value}`);
    }
    /**
   * Computes the slot value for a given map and key.
   * @param baseSlot - The base slot of the map (specified in Aztec.nr contract)
   * @param key - The key to lookup in the map
   * @returns The storage slot of the value in the map
   */ keccak256(baseSlot, key) {
        // abi encode (removing the 0x) - concat key and baseSlot (both padded to 32 bytes)
        const abiEncoded = toHex(key, true).substring(2) + toHex(baseSlot, true).substring(2);
        return toBigIntBE(keccak256(Buffer.from(abiEncoded, 'hex')));
    }
    /**
   * Send transactions impersonating an externally owned account or contract.
   * @param who - The address to impersonate
   */ async startImpersonating(who) {
        try {
            await this.rpcCall('hardhat_impersonateAccount', [
                who.toString()
            ]);
        } catch (err) {
            throw new Error(`Error impersonating ${who}: ${err}`);
        }
        this.logger.warn(`Impersonating ${who}`);
    }
    /**
   * Stop impersonating an account that you are currently impersonating.
   * @param who - The address to stop impersonating
   */ async stopImpersonating(who) {
        try {
            await this.rpcCall('hardhat_stopImpersonatingAccount', [
                who.toString()
            ]);
        } catch (err) {
            throw new Error(`Error when stopping the impersonation of ${who}: ${err}`);
        }
        this.logger.warn(`Stopped impersonating ${who}`);
    }
    /**
   * Set the bytecode for a contract
   * @param contract - The contract address
   * @param bytecode - The bytecode to set
   */ async etch(contract, bytecode) {
        try {
            await this.rpcCall('hardhat_setCode', [
                contract.toString(),
                bytecode
            ]);
        } catch (err) {
            throw new Error(`Error setting bytecode for ${contract}: ${err}`);
        }
        this.logger.warn(`Set bytecode for ${contract} to ${bytecode}`);
    }
    /**
   * Get the bytecode for a contract
   * @param contract - The contract address
   * @returns The bytecode for the contract
   */ async getBytecode(contract) {
        const res = await this.rpcCall('eth_getCode', [
            contract.toString(),
            'latest'
        ]);
        return res;
    }
    /**
   * Get the raw transaction object for a given transaction hash
   * @param txHash - The transaction hash
   * @returns The raw transaction
   */ async getRawTransaction(txHash) {
        const res = await this.rpcCall('debug_getRawTransaction', [
            txHash
        ]);
        return res;
    }
    /**
   * Triggers a reorg of the given depth, removing those blocks from the chain.
   * @param depth - The depth of the reorg
   */ async reorg(depth) {
        try {
            await this.rpcCall('anvil_rollback', [
                depth
            ]);
        } catch (err) {
            throw new Error(`Error rolling back: ${err}`);
        }
        this.logger.warn(`Rolled back L1 chain with depth ${depth}`);
    }
    /**
   * Triggers a reorg of the given depth, optionally replacing it with new blocks.
   * The resulting block height will be the same as the original chain.
   * @param depth - The depth of the reorg
   * @param newBlocks - The blocks to replace the old ones with, each represented as a list of txs.
   */ async reorgWithReplacement(depth, newBlocks = []) {
        try {
            await this.rpcCall('anvil_reorg', [
                depth,
                newBlocks.flatMap((txs, index)=>txs.map((tx)=>[
                            typeof tx === 'string' ? tx : {
                                value: 0,
                                ...tx
                            },
                            index
                        ]))
            ]);
        } catch (err) {
            throw new Error(`Error reorging: ${err}`);
        }
        this.logger.warn(`Reorged L1 chain with depth ${depth} and ${newBlocks.length} new blocks`, {
            depth,
            newBlocks
        });
    }
}
