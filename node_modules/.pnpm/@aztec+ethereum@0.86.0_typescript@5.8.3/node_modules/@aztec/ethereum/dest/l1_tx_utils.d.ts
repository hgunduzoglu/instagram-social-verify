import { type ConfigMappingsType } from '@aztec/foundation/config';
import { type Logger } from '@aztec/foundation/log';
import { type Abi, type Account, type Address, type BlockOverrides, type ContractFunctionExecutionError, type Hex, type StateOverride, type TransactionReceipt } from 'viem';
import { type ExtendedViemWalletClient, type ViemClient } from './types.js';
export interface L1TxUtilsConfig {
    /**
     * How much to increase calculated gas limit.
     */
    gasLimitBufferPercentage?: number;
    /**
     * Maximum gas price in gwei
     */
    maxGwei?: bigint;
    /**
     * Maximum blob fee per gas in gwei
     */
    maxBlobGwei?: bigint;
    /**
     * Priority fee bump percentage
     */
    priorityFeeBumpPercentage?: number;
    /**
     * How much to increase priority fee by each attempt (percentage)
     */
    priorityFeeRetryBumpPercentage?: number;
    /**
     * Fixed priority fee per gas in Gwei. Overrides any priority fee bump percentage config
     */
    fixedPriorityFeePerGas?: number;
    /**
     * Maximum number of speed-up attempts
     */
    maxAttempts?: number;
    /**
     * How often to check tx status
     */
    checkIntervalMs?: number;
    /**
     * How long before considering tx stalled
     */
    stallTimeMs?: number;
    /**
     * How long to wait for a tx to be mined before giving up
     */
    txTimeoutMs?: number;
    /**
     * How many attempts will be done to get a tx after it was sent?
     * First attempt is done at 1s, second at 2s, third at 3s, etc.
     */
    txPropagationMaxQueryAttempts?: number;
}
export declare const l1TxUtilsConfigMappings: ConfigMappingsType<L1TxUtilsConfig>;
export declare const defaultL1TxUtilsConfig: L1TxUtilsConfig;
export declare function getL1TxUtilsConfigEnvVars(): L1TxUtilsConfig;
export interface L1TxRequest {
    to: Address | null;
    data?: Hex;
    value?: bigint;
}
export type L1GasConfig = Partial<L1TxUtilsConfig> & {
    gasLimit?: bigint;
    txTimeoutAt?: Date;
};
export interface L1BlobInputs {
    blobs: Uint8Array[];
    kzg: any;
    maxFeePerBlobGas?: bigint;
}
export interface GasPrice {
    maxFeePerGas: bigint;
    maxPriorityFeePerGas: bigint;
    maxFeePerBlobGas?: bigint;
}
export type TransactionStats = {
    /** Address of the sender. */
    sender: string;
    /** Hash of the transaction. */
    transactionHash: string;
    /** Size in bytes of the tx calldata */
    calldataSize: number;
    /** Gas required to pay for the calldata inclusion (depends on size and number of zeros)  */
    calldataGas: number;
};
export declare class ReadOnlyL1TxUtils {
    client: ViemClient;
    protected logger: Logger;
    protected debugMaxGasLimit: boolean;
    readonly config: L1TxUtilsConfig;
    protected interrupted: boolean;
    constructor(client: ViemClient, logger?: Logger, config?: Partial<L1TxUtilsConfig>, debugMaxGasLimit?: boolean);
    interrupt(): void;
    restart(): void;
    getBlock(): Promise<{
        number: bigint;
        hash: `0x${string}`;
        nonce: `0x${string}`;
        logsBloom: `0x${string}`;
        baseFeePerGas: bigint | null;
        blobGasUsed: bigint;
        difficulty: bigint;
        excessBlobGas: bigint;
        extraData: `0x${string}`;
        gasLimit: bigint;
        gasUsed: bigint;
        miner: `0x${string}`;
        mixHash: `0x${string}`;
        parentBeaconBlockRoot?: `0x${string}` | undefined;
        parentHash: `0x${string}`;
        receiptsRoot: `0x${string}`;
        sealFields: `0x${string}`[];
        sha3Uncles: `0x${string}`;
        size: bigint;
        stateRoot: `0x${string}`;
        timestamp: bigint;
        totalDifficulty: bigint | null;
        transactionsRoot: `0x${string}`;
        uncles: `0x${string}`[];
        withdrawals?: import("viem").Withdrawal[] | undefined;
        withdrawalsRoot?: `0x${string}` | undefined;
        transactions: `0x${string}`[];
    }>;
    getBlockNumber(): Promise<bigint>;
    /**
     * Gets the current gas price with bounds checking
     */
    getGasPrice(_gasConfig?: L1TxUtilsConfig, isBlobTx?: boolean, attempt?: number, previousGasPrice?: typeof attempt extends 0 ? never : GasPrice): Promise<GasPrice>;
    /**
     * Estimates gas and adds buffer
     */
    estimateGas(account: Account | Hex, request: L1TxRequest, _gasConfig?: L1TxUtilsConfig, _blobInputs?: L1BlobInputs): Promise<bigint>;
    getTransactionStats(txHash: string): Promise<TransactionStats | undefined>;
    tryGetErrorFromRevertedTx(data: Hex, args: {
        args: readonly any[];
        functionName: string;
        abi: Abi;
        address: Hex;
    }, blobInputs: (L1BlobInputs & {
        maxFeePerBlobGas: bigint;
    }) | undefined, stateOverride?: StateOverride): Promise<string | undefined>;
    simulateGasUsed(request: L1TxRequest & {
        gas?: bigint;
        from?: Hex;
    }, blockOverrides?: BlockOverrides<bigint, number>, stateOverrides?: StateOverride, _gasConfig?: L1TxUtilsConfig & {
        fallbackGasEstimate?: bigint;
    }): Promise<bigint>;
    protected _simulate(call: any, blockOverrides: BlockOverrides<bigint, number> | undefined, stateOverrides: StateOverride | undefined, gasConfig: L1TxUtilsConfig & {
        fallbackGasEstimate?: bigint;
    }): Promise<bigint>;
    bumpGasLimit(gasLimit: bigint, _gasConfig?: L1TxUtilsConfig): bigint;
}
export declare class L1TxUtils extends ReadOnlyL1TxUtils {
    client: ExtendedViemWalletClient;
    protected logger: Logger;
    constructor(client: ExtendedViemWalletClient, logger?: Logger, config?: Partial<L1TxUtilsConfig>, debugMaxGasLimit?: boolean);
    getSenderAddress(): `0x${string}`;
    getSenderBalance(): Promise<bigint>;
    /**
     * Sends a transaction with gas estimation and pricing
     * @param request - The transaction request (to, data, value)
     * @param gasConfig - Optional gas configuration
     * @returns The transaction hash and parameters used
     */
    sendTransaction(request: L1TxRequest, _gasConfig?: L1GasConfig, blobInputs?: L1BlobInputs): Promise<{
        txHash: Hex;
        gasLimit: bigint;
        gasPrice: GasPrice;
    }>;
    /**
     * Monitors a transaction until completion, handling speed-ups if needed
     * @param request - Original transaction request (needed for speed-ups)
     * @param initialTxHash - Hash of the initial transaction
     * @param params - Parameters used in the initial transaction
     * @param gasConfig - Optional gas configuration
     */
    monitorTransaction(request: L1TxRequest, initialTxHash: Hex, params: {
        gasLimit: bigint;
    }, _gasConfig?: Partial<L1TxUtilsConfig> & {
        txTimeoutAt?: Date;
    }, _blobInputs?: L1BlobInputs, isCancelTx?: boolean): Promise<TransactionReceipt>;
    /**
     * Sends a transaction and monitors it until completion
     * @param request - The transaction request (to, data, value)
     * @param gasConfig - Optional gas configuration
     * @returns The receipt of the successful transaction
     */
    sendAndMonitorTransaction(request: L1TxRequest, gasConfig?: L1GasConfig, blobInputs?: L1BlobInputs): Promise<{
        receipt: TransactionReceipt;
        gasPrice: GasPrice;
    }>;
    simulateGasUsed(request: L1TxRequest & {
        gas?: bigint;
        from?: Hex;
    }, blockOverrides?: BlockOverrides<bigint, number>, stateOverrides?: StateOverride, _gasConfig?: L1TxUtilsConfig & {
        fallbackGasEstimate?: bigint;
    }): Promise<bigint>;
    /**
     * Attempts to cancel a transaction by sending a 0-value tx to self with same nonce but higher gas prices
     * @param nonce - The nonce of the transaction to cancel
     * @param previousGasPrice - The gas price of the previous transaction
     * @param attempts - The number of attempts to cancel the transaction
     * @returns The hash of the cancellation transaction
     */
    protected attemptTxCancellation(nonce: number, isBlobTx?: boolean, previousGasPrice?: GasPrice, attempts?: number): Promise<`0x${string}`>;
}
export declare function tryGetCustomErrorNameContractFunction(err: ContractFunctionExecutionError): string;
export declare function getCalldataGasUsage(data: Uint8Array): number;
//# sourceMappingURL=l1_tx_utils.d.ts.map