import { GeneratorIndex, TX_REQUEST_LENGTH } from '@aztec/constants';
import { poseidon2HashWithSeparator } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { AztecAddress } from '../aztec-address/index.js';
import { FunctionData } from './function_data.js';
import { TxContext } from './tx_context.js';
/**
 * Transaction request.
 */ export class TxRequest {
    origin;
    functionData;
    argsHash;
    txContext;
    // docs:start:constructor
    constructor(/** Sender. */ origin, /** Function data representing the function to call. */ functionData, /** Pedersen hash of function arguments. */ argsHash, /** Transaction context. */ txContext){
        this.origin = origin;
        this.functionData = functionData;
        this.argsHash = argsHash;
        this.txContext = txContext;
    }
    // docs:end:constructor
    static getFields(fields) {
        return [
            fields.origin,
            fields.functionData,
            fields.argsHash,
            fields.txContext
        ];
    }
    static from(fields) {
        return new TxRequest(...TxRequest.getFields(fields));
    }
    /**
   * Serialize as a buffer.
   * @returns The buffer.
   */ toBuffer() {
        return serializeToBuffer([
            ...TxRequest.getFields(this)
        ]);
    }
    toFields() {
        const fields = serializeToFields(...TxRequest.getFields(this));
        if (fields.length !== TX_REQUEST_LENGTH) {
            throw new Error(`Invalid number of fields for TxRequest. Expected ${TX_REQUEST_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    /**
   * Deserializes from a buffer or reader, corresponding to a write in cpp.
   * @param buffer - Buffer to read from.
   * @returns The deserialized TxRequest object.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new TxRequest(reader.readObject(AztecAddress), reader.readObject(FunctionData), Fr.fromBuffer(reader), reader.readObject(TxContext));
    }
    hash() {
        return poseidon2HashWithSeparator(this.toFields(), GeneratorIndex.TX_REQUEST);
    }
    static empty() {
        return new TxRequest(AztecAddress.ZERO, FunctionData.empty(), Fr.zero(), TxContext.empty());
    }
    isEmpty() {
        return this.origin.isZero() && this.functionData.isEmpty() && this.argsHash.isZero() && this.txContext.isEmpty();
    }
}
