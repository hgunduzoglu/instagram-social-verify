import { timesParallel } from '@aztec/foundation/collection';
import { randomBytes, randomInt } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { z } from 'zod';
import { NoteSelector } from '../abi/note_selector.js';
import { PrivateCircuitPublicInputs } from '../kernel/private_circuit_public_inputs.js';
import { sortByCounter } from '../kernel/utils/order_and_comparison.js';
import { ContractClassLog } from '../logs/contract_class_log.js';
import { Note } from '../note/note.js';
import { mapSchema, schemas } from '../schemas/index.js';
import { HashedValues } from './hashed_values.js';
/**
 * The contents of a new note.
 */ export class NoteAndSlot {
    note;
    storageSlot;
    noteTypeId;
    constructor(/** The note. */ note, /** The storage slot of the note. */ storageSlot, /** The note type identifier. */ noteTypeId){
        this.note = note;
        this.storageSlot = storageSlot;
        this.noteTypeId = noteTypeId;
    }
    static get schema() {
        return z.object({
            note: Note.schema,
            storageSlot: schemas.Fr,
            noteTypeId: schemas.NoteSelector
        }).transform(NoteAndSlot.from);
    }
    static from(fields) {
        return new NoteAndSlot(fields.note, fields.storageSlot, fields.noteTypeId);
    }
    static random() {
        return new NoteAndSlot(Note.random(), Fr.random(), NoteSelector.random());
    }
}
export class CountedContractClassLog {
    log;
    counter;
    constructor(log, counter){
        this.log = log;
        this.counter = counter;
    }
    static get schema() {
        return z.object({
            log: ContractClassLog.schema,
            counter: schemas.Integer
        }).transform(CountedContractClassLog.from);
    }
    static from(fields) {
        return new CountedContractClassLog(fields.log, fields.counter);
    }
    isEmpty() {
        return this.log.isEmpty() && !this.counter;
    }
}
export class PrivateExecutionResult {
    entrypoint;
    firstNullifier;
    publicFunctionCalldata;
    constructor(entrypoint, /** The first non revertible nullifier, or zero if there was none. */ firstNullifier, /** An array of calldata for the enqueued public function calls and the teardown function call. */ publicFunctionCalldata){
        this.entrypoint = entrypoint;
        this.firstNullifier = firstNullifier;
        this.publicFunctionCalldata = publicFunctionCalldata;
    }
    static get schema() {
        return z.object({
            entrypoint: PrivateCallExecutionResult.schema,
            firstNullifier: schemas.Fr,
            publicFunctionCalldata: z.array(HashedValues.schema)
        }).transform(PrivateExecutionResult.from);
    }
    static from(fields) {
        return new PrivateExecutionResult(fields.entrypoint, fields.firstNullifier, fields.publicFunctionCalldata);
    }
    static async random(nested = 1) {
        return new PrivateExecutionResult(await PrivateCallExecutionResult.random(nested), Fr.random(), [
            HashedValues.random(),
            HashedValues.random()
        ]);
    }
    /**
   * The block number that this execution was simulated with.
   */ getSimulationBlockNumber() {
        return this.entrypoint.publicInputs.historicalHeader.globalVariables.blockNumber.toNumber();
    }
}
/**
 * The result of executing a call to a private function.
 */ export class PrivateCallExecutionResult {
    acir;
    vk;
    partialWitness;
    publicInputs;
    noteHashLeafIndexMap;
    newNotes;
    noteHashNullifierCounterMap;
    returnValues;
    nestedExecutions;
    contractClassLogs;
    constructor(// Needed for prover
    /** The ACIR bytecode. */ acir, /** The verification key. */ vk, /** The partial witness. */ partialWitness, // Needed for the verifier (kernel)
    /** The call stack item. */ publicInputs, /** Mapping of note hash to its index in the note hash tree. Used for building hints for note hash read requests. */ noteHashLeafIndexMap, /** The notes created in the executed function. */ newNotes, /** Mapping of note hash counter to the counter of its nullifier. */ noteHashNullifierCounterMap, /** The raw return values of the executed function. */ returnValues, /** The nested executions. */ nestedExecutions, /**
     * Contract class logs emitted during execution of this function call.
     * Note: These are preimages to `contractClassLogsHashes`.
     */ contractClassLogs){
        this.acir = acir;
        this.vk = vk;
        this.partialWitness = partialWitness;
        this.publicInputs = publicInputs;
        this.noteHashLeafIndexMap = noteHashLeafIndexMap;
        this.newNotes = newNotes;
        this.noteHashNullifierCounterMap = noteHashNullifierCounterMap;
        this.returnValues = returnValues;
        this.nestedExecutions = nestedExecutions;
        this.contractClassLogs = contractClassLogs;
    }
    static get schema() {
        return z.object({
            acir: schemas.Buffer,
            vk: schemas.Buffer,
            partialWitness: mapSchema(z.coerce.number(), z.string()),
            publicInputs: PrivateCircuitPublicInputs.schema,
            noteHashLeafIndexMap: mapSchema(schemas.BigInt, schemas.BigInt),
            newNotes: z.array(NoteAndSlot.schema),
            noteHashNullifierCounterMap: mapSchema(z.coerce.number(), z.number()),
            returnValues: z.array(schemas.Fr),
            nestedExecutions: z.array(z.lazy(()=>PrivateCallExecutionResult.schema)),
            contractClassLogs: z.array(CountedContractClassLog.schema)
        }).transform(PrivateCallExecutionResult.from);
    }
    static from(fields) {
        return new PrivateCallExecutionResult(fields.acir, fields.vk, fields.partialWitness, fields.publicInputs, fields.noteHashLeafIndexMap, fields.newNotes, fields.noteHashNullifierCounterMap, fields.returnValues, fields.nestedExecutions, fields.contractClassLogs);
    }
    static async random(nested = 1) {
        return new PrivateCallExecutionResult(randomBytes(4), randomBytes(4), new Map([
            [
                1,
                'one'
            ]
        ]), PrivateCircuitPublicInputs.empty(), new Map([
            [
                1n,
                1n
            ]
        ]), [
            NoteAndSlot.random()
        ], new Map([
            [
                0,
                0
            ]
        ]), [
            Fr.random()
        ], await timesParallel(nested, ()=>PrivateCallExecutionResult.random(0)), [
            new CountedContractClassLog(await ContractClassLog.random(), randomInt(10))
        ]);
    }
}
export function collectNoteHashLeafIndexMap(execResult) {
    const accum = new Map();
    const collectNoteHashLeafIndexMapRecursive = (callResult, accum)=>{
        callResult.noteHashLeafIndexMap.forEach((value, key)=>accum.set(key, value));
        callResult.nestedExecutions.forEach((nested)=>collectNoteHashLeafIndexMapRecursive(nested, accum));
    };
    collectNoteHashLeafIndexMapRecursive(execResult.entrypoint, accum);
    return accum;
}
export function collectNoteHashNullifierCounterMap(execResult) {
    const accum = new Map();
    const collectNoteHashNullifierCounterMapRecursive = (callResult, accum)=>{
        callResult.noteHashNullifierCounterMap.forEach((value, key)=>accum.set(key, value));
        callResult.nestedExecutions.forEach((nested)=>collectNoteHashNullifierCounterMapRecursive(nested, accum));
    };
    collectNoteHashNullifierCounterMapRecursive(execResult.entrypoint, accum);
    return accum;
}
/**
 * Collect all contract class logs across all nested executions.
 * @param execResult - The topmost execution result.
 * @returns All contract class logs.
 */ function collectContractClassLogs(execResult) {
    return [
        execResult.contractClassLogs,
        ...execResult.nestedExecutions.flatMap(collectContractClassLogs)
    ].flat();
}
/**
 * Collect all contract class logs across all nested executions and sorts by counter.
 * @param execResult - The topmost execution result.
 * @returns All contract class logs.
 */ export function collectSortedContractClassLogs(execResult) {
    const allLogs = collectContractClassLogs(execResult.entrypoint);
    const sortedLogs = sortByCounter(allLogs);
    return sortedLogs.map((l)=>l.log);
}
export function getFinalMinRevertibleSideEffectCounter(execResult) {
    const collectFinalMinRevertibleSideEffectCounterRecursive = (callResult)=>{
        return callResult.nestedExecutions.reduce((counter, exec)=>{
            const nestedCounter = collectFinalMinRevertibleSideEffectCounterRecursive(exec);
            return nestedCounter ? nestedCounter : counter;
        }, callResult.publicInputs.minRevertibleSideEffectCounter.toNumber());
    };
    return collectFinalMinRevertibleSideEffectCounterRecursive(execResult.entrypoint);
}
export function collectNested(executionStack, extractExecutionItems) {
    const thisExecutionReads = executionStack.flatMap(extractExecutionItems);
    return thisExecutionReads.concat(executionStack.flatMap(({ nestedExecutions })=>collectNested(nestedExecutions, extractExecutionItems)));
}
