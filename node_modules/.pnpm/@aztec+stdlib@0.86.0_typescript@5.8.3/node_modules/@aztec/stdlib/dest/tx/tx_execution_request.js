import { Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { inspect } from 'util';
import { z } from 'zod';
import { FunctionSelector } from '../abi/function_selector.js';
import { AuthWitness } from '../auth_witness/auth_witness.js';
import { AztecAddress } from '../aztec-address/index.js';
import { schemas } from '../schemas/index.js';
import { Vector } from '../types/shared.js';
import { Capsule } from './capsule.js';
import { FunctionData } from './function_data.js';
import { HashedValues } from './hashed_values.js';
import { TxContext } from './tx_context.js';
import { TxRequest } from './tx_request.js';
/**
 * Request to execute a transaction. Similar to TxRequest, but has the full args.
 */ export class TxExecutionRequest {
    origin;
    functionSelector;
    firstCallArgsHash;
    txContext;
    argsOfCalls;
    authWitnesses;
    capsules;
    constructor(/**
     * Sender.
     */ origin, /**
     * Selector of the function to call.
     */ functionSelector, /**
     * The hash of arguments of first call to be executed (usually account entrypoint).
     * @dev This hash is a pointer to `argsOfCalls` unordered array.
     */ firstCallArgsHash, /**
     * Transaction context.
     */ txContext, /**
     * An unordered array of packed arguments for each call in the transaction.
     * @dev These arguments are accessed in Noir via oracle and constrained against the args hash. The length of
     * the array is equal to the number of function calls in the transaction (1 args per 1 call).
     */ argsOfCalls, /**
     * Transient authorization witnesses for authorizing the execution of one or more actions during this tx.
     * These witnesses are not expected to be stored in the local witnesses database of the PXE.
     */ authWitnesses, /**
     * Read-only data passed through the oracle calls during this tx execution.
     */ capsules){
        this.origin = origin;
        this.functionSelector = functionSelector;
        this.firstCallArgsHash = firstCallArgsHash;
        this.txContext = txContext;
        this.argsOfCalls = argsOfCalls;
        this.authWitnesses = authWitnesses;
        this.capsules = capsules;
    }
    static get schema() {
        return z.object({
            origin: schemas.AztecAddress,
            functionSelector: schemas.FunctionSelector,
            firstCallArgsHash: schemas.Fr,
            txContext: TxContext.schema,
            argsOfCalls: z.array(HashedValues.schema),
            authWitnesses: z.array(AuthWitness.schema),
            capsules: z.array(Capsule.schema)
        }).transform(TxExecutionRequest.from);
    }
    toTxRequest() {
        return new TxRequest(this.origin, // Entrypoints must be private as as defined by the protocol.
        new FunctionData(this.functionSelector, true), this.firstCallArgsHash, this.txContext);
    }
    static getFields(fields) {
        return [
            fields.origin,
            fields.functionSelector,
            fields.firstCallArgsHash,
            fields.txContext,
            fields.argsOfCalls,
            fields.authWitnesses,
            fields.capsules
        ];
    }
    static from(fields) {
        return new TxExecutionRequest(...TxExecutionRequest.getFields(fields));
    }
    /**
   * Serialize as a buffer.
   * @returns The buffer.
   */ toBuffer() {
        return serializeToBuffer(this.origin, this.functionSelector, this.firstCallArgsHash, this.txContext, new Vector(this.argsOfCalls), new Vector(this.authWitnesses), new Vector(this.capsules));
    }
    /**
   * Serialize as a string.
   * @returns The string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    /**
   * Deserializes from a buffer or reader, corresponding to a write in cpp.
   * @param buffer - Buffer to read from.
   * @returns The deserialized TxRequest object.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new TxExecutionRequest(reader.readObject(AztecAddress), reader.readObject(FunctionSelector), Fr.fromBuffer(reader), reader.readObject(TxContext), reader.readVector(HashedValues), reader.readVector(AuthWitness), reader.readVector(Capsule));
    }
    /**
   * Deserializes from a string, corresponding to a write in cpp.
   * @param str - String to read from.
   * @returns The deserialized TxRequest object.
   */ static fromString(str) {
        return TxExecutionRequest.fromBuffer(hexToBuffer(str));
    }
    static async random() {
        return new TxExecutionRequest(await AztecAddress.random(), FunctionSelector.random(), Fr.random(), TxContext.empty(), [
            HashedValues.random()
        ], [
            AuthWitness.random()
        ], [
            new Capsule(await AztecAddress.random(), Fr.random(), [
                Fr.random(),
                Fr.random()
            ]),
            new Capsule(await AztecAddress.random(), Fr.random(), [
                Fr.random()
            ])
        ]);
    }
    [inspect.custom]() {
        return `TxExecutionRequest(${this.origin} called ${this.functionSelector})`;
    }
}
