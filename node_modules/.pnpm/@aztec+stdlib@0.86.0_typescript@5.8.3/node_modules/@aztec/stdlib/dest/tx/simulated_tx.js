import { z } from 'zod';
import { Gas } from '../gas/gas.js';
import { PrivateKernelTailCircuitPublicInputs } from '../kernel/private_kernel_tail_circuit_public_inputs.js';
import { ClientIvcProof } from '../proofs/client_ivc_proof.js';
import { PrivateExecutionResult, collectSortedContractClassLogs } from './private_execution_result.js';
import { NestedProcessReturnValues, PublicSimulationOutput } from './public_simulation_output.js';
import { Tx } from './tx.js';
export class PrivateSimulationResult {
    privateExecutionResult;
    publicInputs;
    constructor(privateExecutionResult, publicInputs){
        this.privateExecutionResult = privateExecutionResult;
        this.publicInputs = publicInputs;
    }
    getPrivateReturnValues() {
        return accumulatePrivateReturnValues(this.privateExecutionResult);
    }
    toSimulatedTx() {
        const contractClassLogs = collectSortedContractClassLogs(this.privateExecutionResult);
        const tx = new Tx(this.publicInputs, ClientIvcProof.empty(), contractClassLogs, this.privateExecutionResult.publicFunctionCalldata);
        return tx;
    }
}
export class TxSimulationResult {
    privateExecutionResult;
    publicInputs;
    publicOutput;
    constructor(privateExecutionResult, publicInputs, publicOutput){
        this.privateExecutionResult = privateExecutionResult;
        this.publicInputs = publicInputs;
        this.publicOutput = publicOutput;
    }
    get gasUsed() {
        return this.publicOutput?.gasUsed ?? {
            totalGas: this.publicInputs.gasUsed,
            billedGas: this.publicInputs.gasUsed,
            teardownGas: Gas.empty(),
            publicGas: Gas.empty()
        };
    }
    static get schema() {
        return z.object({
            privateExecutionResult: PrivateExecutionResult.schema,
            publicInputs: PrivateKernelTailCircuitPublicInputs.schema,
            publicOutput: PublicSimulationOutput.schema.optional()
        }).transform(TxSimulationResult.from);
    }
    static from(fields) {
        return new TxSimulationResult(fields.privateExecutionResult, fields.publicInputs, fields.publicOutput);
    }
    static fromPrivateSimulationResultAndPublicOutput(privateSimulationResult, publicOutput) {
        return new TxSimulationResult(privateSimulationResult.privateExecutionResult, privateSimulationResult.publicInputs, publicOutput);
    }
    static async random() {
        return new TxSimulationResult(await PrivateExecutionResult.random(), PrivateKernelTailCircuitPublicInputs.empty(), await PublicSimulationOutput.random());
    }
    getPrivateReturnValues() {
        return new PrivateSimulationResult(this.privateExecutionResult, this.publicInputs).getPrivateReturnValues();
    }
    toSimulatedTx() {
        return new PrivateSimulationResult(this.privateExecutionResult, this.publicInputs).toSimulatedTx();
    }
    getPublicReturnValues() {
        return this.publicOutput ? this.publicOutput.publicReturnValues : [];
    }
}
/**
 * Recursively accummulate the return values of a call result and its nested executions,
 * so they can be retrieved in order.
 * @param executionResult
 * @returns
 */ export function accumulatePrivateReturnValues(executionResult) {
    const collectPrivateReturnValuesRecursive = (executionResult)=>{
        const acc = new NestedProcessReturnValues(executionResult.returnValues);
        acc.nested = executionResult.nestedExecutions.map((nestedExecution)=>collectPrivateReturnValuesRecursive(nestedExecution));
        return acc;
    };
    return collectPrivateReturnValuesRecursive(executionResult.entrypoint);
}
