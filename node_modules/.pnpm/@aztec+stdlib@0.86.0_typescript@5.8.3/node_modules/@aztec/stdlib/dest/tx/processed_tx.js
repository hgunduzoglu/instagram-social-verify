import { RevertCode } from '../avm/revert_code.js';
import { Gas } from '../gas/gas.js';
import { siloL2ToL1Message } from '../hash/hash.js';
import { CombinedConstantData } from '../kernel/combined_constant_data.js';
import { TxEffect } from './tx_effect.js';
export var TxExecutionPhase = /*#__PURE__*/ function(TxExecutionPhase) {
    TxExecutionPhase[TxExecutionPhase["SETUP"] = 0] = "SETUP";
    TxExecutionPhase[TxExecutionPhase["APP_LOGIC"] = 1] = "APP_LOGIC";
    TxExecutionPhase[TxExecutionPhase["TEARDOWN"] = 2] = "TEARDOWN";
    return TxExecutionPhase;
}({});
export async function makeProcessedTxFromPrivateOnlyTx(tx, transactionFee, feePaymentPublicDataWrite, globalVariables) {
    const constants = CombinedConstantData.combine(tx.data.constants, globalVariables);
    const data = tx.data.forRollup;
    const txEffect = new TxEffect(RevertCode.OK, await tx.getTxHash(), transactionFee, data.end.noteHashes.filter((h)=>!h.isZero()), data.end.nullifiers.filter((h)=>!h.isZero()), data.end.l2ToL1Msgs.map((message)=>siloL2ToL1Message(message, constants.txContext.version, constants.txContext.chainId)).filter((h)=>!h.isZero()), [
        feePaymentPublicDataWrite
    ], data.end.privateLogs.filter((l)=>!l.isEmpty()), [], await tx.filterContractClassLogs(tx.data.getNonEmptyContractClassLogsHashes(), true));
    const gasUsed = {
        // Billed gas is the same as total gas since there is no teardown execution
        totalGas: tx.data.gasUsed,
        billedGas: tx.data.gasUsed,
        teardownGas: Gas.empty(),
        publicGas: Gas.empty()
    };
    return {
        hash: txEffect.txHash,
        data: tx.data,
        clientIvcProof: tx.clientIvcProof,
        avmProvingRequest: undefined,
        constants,
        txEffect,
        gasUsed,
        revertCode: RevertCode.OK,
        revertReason: undefined
    };
}
export function toNumBlobFields(txs) {
    return txs.reduce((acc, tx)=>{
        return acc + tx.txEffect.toBlobFields().length;
    }, 0);
}
export async function makeProcessedTxFromTxWithPublicCalls(tx, avmProvingRequest, gasUsed, revertCode, revertReason) {
    const avmPublicInputs = avmProvingRequest.inputs.publicInputs;
    const constants = CombinedConstantData.combine(tx.data.constants, avmPublicInputs.globalVariables);
    const publicDataWrites = avmPublicInputs.accumulatedData.publicDataWrites.filter((w)=>!w.isEmpty());
    const privateLogs = [
        ...tx.data.forPublic.nonRevertibleAccumulatedData.privateLogs,
        ...revertCode.isOK() ? tx.data.forPublic.revertibleAccumulatedData.privateLogs : []
    ].filter((l)=>!l.isEmpty());
    const contractClassLogs = [
        ...await tx.getSplitContractClassLogs(false, true),
        ...revertCode.isOK() ? await tx.getSplitContractClassLogs(true, true) : []
    ].filter((l)=>!l.isEmpty());
    const txEffect = new TxEffect(revertCode, await tx.getTxHash(), avmPublicInputs.transactionFee, avmPublicInputs.accumulatedData.noteHashes.filter((h)=>!h.isZero()), avmPublicInputs.accumulatedData.nullifiers.filter((h)=>!h.isZero()), avmPublicInputs.accumulatedData.l2ToL1Msgs.map((message)=>siloL2ToL1Message(message, constants.txContext.version, constants.txContext.chainId)).filter((h)=>!h.isZero()), publicDataWrites, privateLogs, avmPublicInputs.accumulatedData.publicLogs.filter((l)=>!l.isEmpty()), contractClassLogs);
    return {
        hash: txEffect.txHash,
        data: tx.data,
        clientIvcProof: tx.clientIvcProof,
        avmProvingRequest,
        constants,
        txEffect,
        gasUsed,
        revertCode,
        revertReason
    };
}
