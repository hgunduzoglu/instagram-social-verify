import { AVM_PROOF_LENGTH_IN_FIELDS, NESTED_RECURSIVE_PROOF_LENGTH, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, RECURSIVE_PROOF_LENGTH, TUBE_PROOF_LENGTH } from '@aztec/constants';
import { z } from 'zod';
import { AvmCircuitInputs } from '../avm/avm.js';
import { AvmProvingRequestSchema } from '../avm/avm_proving_request.js';
import { BaseParityInputs } from '../parity/base_parity_inputs.js';
import { ParityPublicInputs } from '../parity/parity_public_inputs.js';
import { RootParityInputs } from '../parity/root_parity_inputs.js';
import { ProvingRequestType } from '../proofs/proving_request_type.js';
import { RecursiveProof } from '../proofs/recursive_proof.js';
import { BaseOrMergeRollupPublicInputs } from '../rollup/base_or_merge_rollup_public_inputs.js';
import { BlockMergeRollupInputs } from '../rollup/block_merge_rollup.js';
import { BlockRootOrBlockMergePublicInputs } from '../rollup/block_root_or_block_merge_public_inputs.js';
import { BlockRootRollupInputs, SingleTxBlockRootRollupInputs } from '../rollup/block_root_rollup.js';
import { EmptyBlockRootRollupInputs } from '../rollup/empty_block_root_rollup_inputs.js';
import { MergeRollupInputs } from '../rollup/merge_rollup.js';
import { PrivateBaseRollupInputs } from '../rollup/private_base_rollup_inputs.js';
import { PublicBaseRollupInputs } from '../rollup/public_base_rollup_inputs.js';
import { RootRollupInputs, RootRollupPublicInputs } from '../rollup/root_rollup.js';
import { TubeInputs } from '../rollup/tube_inputs.js';
import { VerificationKeyData } from '../vks/verification_key.js';
function schemaForRecursiveProofAndVerificationKey(proofLength) {
    return z.object({
        proof: RecursiveProof.schemaFor(proofLength),
        verificationKey: VerificationKeyData.schema
    });
}
export function makeProofAndVerificationKey(proof, verificationKey) {
    return {
        proof,
        verificationKey
    };
}
function schemaForPublicInputsAndRecursiveProof(inputs, proofSize) {
    return z.object({
        inputs,
        proof: RecursiveProof.schemaFor(proofSize),
        verificationKey: VerificationKeyData.schema
    });
}
export function makePublicInputsAndRecursiveProof(inputs, proof, verificationKey) {
    return {
        inputs,
        proof,
        verificationKey
    };
}
export function mapProvingRequestTypeToCircuitName(type) {
    switch(type){
        case ProvingRequestType.PUBLIC_VM:
            return 'avm-circuit';
        case ProvingRequestType.PRIVATE_BASE_ROLLUP:
            return 'private-base-rollup';
        case ProvingRequestType.PUBLIC_BASE_ROLLUP:
            return 'public-base-rollup';
        case ProvingRequestType.MERGE_ROLLUP:
            return 'merge-rollup';
        case ProvingRequestType.EMPTY_BLOCK_ROOT_ROLLUP:
            return 'empty-block-root-rollup';
        case ProvingRequestType.BLOCK_ROOT_ROLLUP:
            return 'block-root-rollup';
        case ProvingRequestType.SINGLE_TX_BLOCK_ROOT_ROLLUP:
            return 'single-tx-block-root-rollup';
        case ProvingRequestType.BLOCK_MERGE_ROLLUP:
            return 'block-merge-rollup';
        case ProvingRequestType.ROOT_ROLLUP:
            return 'root-rollup';
        case ProvingRequestType.BASE_PARITY:
            return 'base-parity';
        case ProvingRequestType.ROOT_PARITY:
            return 'root-parity';
        case ProvingRequestType.TUBE_PROOF:
            return 'tube-circuit';
        default:
            {
                const _exhaustive = type;
                throw new Error(`Cannot find circuit name for proving request type: ${type}`);
            }
    }
}
export const ProvingJobInputs = z.discriminatedUnion('type', [
    AvmProvingRequestSchema,
    z.object({
        type: z.literal(ProvingRequestType.BASE_PARITY),
        inputs: BaseParityInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.ROOT_PARITY),
        inputs: RootParityInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.PRIVATE_BASE_ROLLUP),
        inputs: PrivateBaseRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_BASE_ROLLUP),
        inputs: PublicBaseRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.MERGE_ROLLUP),
        inputs: MergeRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_ROLLUP),
        inputs: BlockRootRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.SINGLE_TX_BLOCK_ROOT_ROLLUP),
        inputs: SingleTxBlockRootRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.EMPTY_BLOCK_ROOT_ROLLUP),
        inputs: EmptyBlockRootRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_MERGE_ROLLUP),
        inputs: BlockMergeRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.ROOT_ROLLUP),
        inputs: RootRollupInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.TUBE_PROOF),
        inputs: TubeInputs.schema
    })
]);
export function getProvingJobInputClassFor(type) {
    switch(type){
        case ProvingRequestType.PUBLIC_VM:
            return AvmCircuitInputs;
        case ProvingRequestType.PRIVATE_BASE_ROLLUP:
            return PrivateBaseRollupInputs;
        case ProvingRequestType.PUBLIC_BASE_ROLLUP:
            return PublicBaseRollupInputs;
        case ProvingRequestType.MERGE_ROLLUP:
            return MergeRollupInputs;
        case ProvingRequestType.EMPTY_BLOCK_ROOT_ROLLUP:
            return EmptyBlockRootRollupInputs;
        case ProvingRequestType.BLOCK_ROOT_ROLLUP:
            return BlockRootRollupInputs;
        case ProvingRequestType.SINGLE_TX_BLOCK_ROOT_ROLLUP:
            return SingleTxBlockRootRollupInputs;
        case ProvingRequestType.BLOCK_MERGE_ROLLUP:
            return BlockMergeRollupInputs;
        case ProvingRequestType.ROOT_ROLLUP:
            return RootRollupInputs;
        case ProvingRequestType.BASE_PARITY:
            return BaseParityInputs;
        case ProvingRequestType.ROOT_PARITY:
            return RootParityInputs;
        case ProvingRequestType.TUBE_PROOF:
            return TubeInputs;
        default:
            {
                const _exhaustive = type;
                throw new Error(`Cannot find circuit inputs class for proving type ${type}`);
            }
    }
}
export const ProvingJobResult = z.discriminatedUnion('type', [
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_VM),
        result: schemaForRecursiveProofAndVerificationKey(AVM_PROOF_LENGTH_IN_FIELDS)
    }),
    z.object({
        type: z.literal(ProvingRequestType.PRIVATE_BASE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BaseOrMergeRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_BASE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BaseOrMergeRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.MERGE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BaseOrMergeRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.EMPTY_BLOCK_ROOT_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRootOrBlockMergePublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRootOrBlockMergePublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.SINGLE_TX_BLOCK_ROOT_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRootOrBlockMergePublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_MERGE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRootOrBlockMergePublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.ROOT_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(RootRollupPublicInputs.schema, NESTED_RECURSIVE_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BASE_PARITY),
        result: schemaForPublicInputsAndRecursiveProof(ParityPublicInputs.schema, RECURSIVE_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.ROOT_PARITY),
        result: schemaForPublicInputsAndRecursiveProof(ParityPublicInputs.schema, NESTED_RECURSIVE_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.TUBE_PROOF),
        result: schemaForRecursiveProofAndVerificationKey(TUBE_PROOF_LENGTH)
    })
]);
export const ProvingJobId = z.string();
export const ProofUri = z.string().brand('ProvingJobUri');
export const ProvingJob = z.object({
    id: ProvingJobId,
    type: z.nativeEnum(ProvingRequestType),
    epochNumber: z.number(),
    inputsUri: ProofUri
});
export const makeProvingJobId = (epochNumber, type, inputsHash)=>{
    return `${epochNumber}:${ProvingRequestType[type]}:${inputsHash}`;
};
export const getEpochFromProvingJobId = (id)=>{
    const components = id.split(':');
    const epochNumber = components.length < 1 ? Number.NaN : parseInt(components[0], 10);
    if (!Number.isSafeInteger(epochNumber) || epochNumber < 0) {
        throw new Error(`Proving Job ID ${id} does not contain valid epoch`);
    }
    return epochNumber;
};
export function makeProvingRequestResult(type, result) {
    return {
        type,
        result
    };
}
export const ProvingJobFulfilledResult = z.object({
    status: z.literal('fulfilled'),
    value: ProofUri
});
export const ProvingJobRejectedResult = z.object({
    status: z.literal('rejected'),
    reason: z.string()
});
export const ProvingJobSettledResult = z.discriminatedUnion('status', [
    ProvingJobFulfilledResult,
    ProvingJobRejectedResult
]);
export const ProvingJobStatus = z.discriminatedUnion('status', [
    z.object({
        status: z.literal('in-queue')
    }),
    z.object({
        status: z.literal('in-progress')
    }),
    z.object({
        status: z.literal('not-found')
    }),
    ProvingJobFulfilledResult,
    ProvingJobRejectedResult
]);
