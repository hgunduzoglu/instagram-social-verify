import { createLogger } from '@aztec/foundation/log';
import { makeBackoff, retry } from '@aztec/foundation/retry';
import { createWriteStream } from 'fs';
import { mkdir } from 'fs/promises';
import { dirname } from 'path';
import { Readable } from 'stream';
import { finished } from 'stream/promises';
export class HttpFileStore {
    baseUrl;
    log;
    fetch;
    constructor(baseUrl, log = createLogger('stdlib:http-file-store')){
        this.baseUrl = baseUrl;
        this.log = log;
        this.fetch = async (...args)=>{
            return await retry(()=>fetch(...args), `Fetching ${args[0]}`, makeBackoff([
                1,
                1,
                3
            ]), this.log, /*failSilently=*/ true);
        };
    }
    async read(pathOrUrl) {
        const url = this.getUrl(pathOrUrl);
        const response = await this.fetch(url);
        if (response.ok) {
            return Buffer.from(await response.arrayBuffer());
        } else {
            throw new Error(`Error fetching file from ${url}: ${response.statusText}`);
        }
    }
    async download(pathOrUrl, destPath) {
        const url = this.getUrl(pathOrUrl);
        const response = await this.fetch(url);
        if (response.ok) {
            await mkdir(dirname(destPath), {
                recursive: true
            });
            // Typescript complains about Readable.fromWeb, hence the cast
            await finished(Readable.fromWeb(response.body).pipe(createWriteStream(destPath)));
        } else {
            throw new Error(`Error fetching file from ${url}: ${response.statusText}`);
        }
    }
    async exists(pathOrUrl) {
        const url = this.getUrl(pathOrUrl);
        const response = await this.fetch(url);
        return response.ok;
    }
    getUrl(path) {
        return URL.canParse(path) ? path : `${this.baseUrl.replace(/\/$/, '')}/${path}`;
    }
}
