import { createLogger } from '@aztec/foundation/log';
import { Storage } from '@google-cloud/storage';
import { join } from 'path';
export class GoogleCloudFileStore {
    bucketName;
    basePath;
    log;
    storage;
    constructor(bucketName, basePath, log = createLogger('stdlib:gcs-file-store')){
        this.bucketName = bucketName;
        this.basePath = basePath;
        this.log = log;
        this.storage = new Storage();
    }
    async checkCredentials() {
        await this.storage.getServiceAccount();
    }
    async save(path, data, opts = {
        public: false,
        metadata: {},
        compress: false
    }) {
        const fullPath = this.getFullPath(path);
        try {
            const bucket = this.storage.bucket(this.bucketName);
            const file = bucket.file(fullPath);
            await file.save(data, {
                metadata: opts.metadata,
                gzip: opts.compress
            });
            return this.handleUploadedFile(file, opts);
        } catch (err) {
            throw new Error(`Error saving file to google cloud storage at ${fullPath}: ${err.message ?? err}`);
        }
    }
    async upload(destPath, srcPath, opts = {
        compress: true,
        public: false,
        metadata: {}
    }) {
        const fullPath = this.getFullPath(destPath);
        try {
            const bucket = this.storage.bucket(this.bucketName);
            const file = bucket.file(fullPath);
            const uploadOpts = {
                destination: file,
                gzip: opts.compress,
                metadata: opts.metadata
            };
            await bucket.upload(srcPath, uploadOpts);
            return this.handleUploadedFile(file, opts);
        } catch (err) {
            throw new Error(`Error saving file to google cloud storage at ${fullPath}: ${err.message ?? err}`);
        }
    }
    async handleUploadedFile(file, opts) {
        if (opts.public) {
            try {
                if (!await file.isPublic()) {
                    await file.makePublic();
                }
            } catch (err) {
                this.log.warn(`Error making file ${file.name} public: ${err.message ?? err}. This is expected if we handle public access at the bucket level.`);
            }
            return file.publicUrl().replaceAll('%2F', '/');
        } else {
            return file.cloudStorageURI.toString();
        }
    }
    async read(pathOrUrlStr) {
        const file = await this.getFileObject(pathOrUrlStr);
        const contents = await file.download();
        return contents[0];
    }
    async download(pathOrUrlStr, destPath) {
        const file = await this.getFileObject(pathOrUrlStr);
        await file.download({
            destination: destPath
        });
    }
    async exists(pathOrUrlStr) {
        const { bucketName, fullPath } = this.getBucketAndFullPath(pathOrUrlStr);
        const bucket = this.storage.bucket(bucketName);
        const file = bucket.file(fullPath);
        const [exists] = await file.exists();
        return exists;
    }
    async getFileObject(pathOrUrlStr) {
        const { bucketName, fullPath } = this.getBucketAndFullPath(pathOrUrlStr);
        const bucket = this.storage.bucket(bucketName);
        const file = bucket.file(fullPath);
        if (!await file.exists()) {
            throw new Error(`File at ${fullPath} in gcs bucket ${bucketName} does not exist`);
        }
        return file;
    }
    getBucketAndFullPath(pathOrUrlStr) {
        if (URL.canParse(pathOrUrlStr)) {
            const url = new URL(pathOrUrlStr);
            // Note that we accept reading from anywhere, not just our bucket
            return {
                fullPath: url.pathname.replace(/^\/+/, ''),
                bucketName: url.host
            };
        } else {
            return {
                fullPath: this.getFullPath(pathOrUrlStr),
                bucketName: this.bucketName
            };
        }
    }
    getFullPath(path) {
        return this.basePath && this.basePath.length > 0 ? join(this.basePath, path) : path;
    }
}
