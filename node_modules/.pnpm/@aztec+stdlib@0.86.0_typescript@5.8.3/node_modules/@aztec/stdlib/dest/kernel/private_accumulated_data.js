import { MAX_CONTRACT_CLASS_LOGS_PER_TX, MAX_ENQUEUED_CALLS_PER_TX, MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX, MAX_PRIVATE_LOGS_PER_TX } from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { ScopedL2ToL1Message } from '../messaging/l2_to_l1_message.js';
import { ScopedLogHash } from './log_hash.js';
import { ScopedNoteHash } from './note_hash.js';
import { ScopedNullifier } from './nullifier.js';
import { PrivateCallRequest } from './private_call_request.js';
import { ScopedPrivateLogData } from './private_log_data.js';
import { CountedPublicCallRequest } from './public_call_request.js';
/**
 * Specific accumulated data structure for the final ordering private kernel circuit. It is included
 *  in the final public inputs of private kernel circuit.
 */ export class PrivateAccumulatedData {
    noteHashes;
    nullifiers;
    l2ToL1Msgs;
    privateLogs;
    contractClassLogsHashes;
    publicCallRequests;
    privateCallStack;
    constructor(/**
     * The new note hashes made in this transaction.
     */ noteHashes, /**
     * The new nullifiers made in this transaction.
     */ nullifiers, /**
     * All the new L2 to L1 messages created in this transaction.
     */ l2ToL1Msgs, /**
     * Accumulated logs from all the previous kernel iterations.
     */ privateLogs, /**
     * Accumulated contract class logs from all the previous kernel iterations.
     * Note: Truncated to 31 bytes to fit in Fr.
     */ contractClassLogsHashes, /**
     * Accumulated public call requests from all the previous kernel iterations.
     */ publicCallRequests, /**
     * Current private call stack.
     */ privateCallStack){
        this.noteHashes = noteHashes;
        this.nullifiers = nullifiers;
        this.l2ToL1Msgs = l2ToL1Msgs;
        this.privateLogs = privateLogs;
        this.contractClassLogsHashes = contractClassLogsHashes;
        this.publicCallRequests = publicCallRequests;
        this.privateCallStack = privateCallStack;
    }
    toBuffer() {
        return serializeToBuffer(this.noteHashes, this.nullifiers, this.l2ToL1Msgs, this.privateLogs, this.contractClassLogsHashes, this.publicCallRequests, this.privateCallStack);
    }
    toString() {
        return bufferToHex(this.toBuffer());
    }
    /**
   * Deserializes from a buffer or reader, corresponding to a write in cpp.
   * @param buffer - Buffer or reader to read from.
   * @returns Deserialized object.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateAccumulatedData(reader.readArray(MAX_NOTE_HASHES_PER_TX, ScopedNoteHash), reader.readArray(MAX_NULLIFIERS_PER_TX, ScopedNullifier), reader.readArray(MAX_L2_TO_L1_MSGS_PER_TX, ScopedL2ToL1Message), reader.readArray(MAX_PRIVATE_LOGS_PER_TX, ScopedPrivateLogData), reader.readArray(MAX_CONTRACT_CLASS_LOGS_PER_TX, ScopedLogHash), reader.readArray(MAX_ENQUEUED_CALLS_PER_TX, CountedPublicCallRequest), reader.readArray(MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX, PrivateCallRequest));
    }
    /**
   * Deserializes from a string, corresponding to a write in cpp.
   * @param str - String to read from.
   * @returns Deserialized object.
   */ static fromString(str) {
        return PrivateAccumulatedData.fromBuffer(hexToBuffer(str));
    }
    static empty() {
        return new PrivateAccumulatedData(makeTuple(MAX_NOTE_HASHES_PER_TX, ScopedNoteHash.empty), makeTuple(MAX_NULLIFIERS_PER_TX, ScopedNullifier.empty), makeTuple(MAX_L2_TO_L1_MSGS_PER_TX, ScopedL2ToL1Message.empty), makeTuple(MAX_PRIVATE_LOGS_PER_TX, ScopedPrivateLogData.empty), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ScopedLogHash.empty), makeTuple(MAX_ENQUEUED_CALLS_PER_TX, CountedPublicCallRequest.empty), makeTuple(MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX, PrivateCallRequest.empty));
    }
}
