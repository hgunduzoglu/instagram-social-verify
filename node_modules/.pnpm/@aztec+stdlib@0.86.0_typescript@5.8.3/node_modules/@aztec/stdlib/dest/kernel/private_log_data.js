import { PRIVATE_LOG_DATA_LENGTH } from '@aztec/constants';
import { BufferReader, FieldReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { AztecAddress } from '../aztec-address/index.js';
import { PrivateLog } from '../logs/private_log.js';
export class PrivateLogData {
    log;
    noteHashCounter;
    counter;
    constructor(log, noteHashCounter, counter){
        this.log = log;
        this.noteHashCounter = noteHashCounter;
        this.counter = counter;
    }
    static from(fields) {
        return new PrivateLogData(...PrivateLogData.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.log,
            fields.noteHashCounter,
            fields.counter
        ];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new PrivateLogData(reader.readObject(PrivateLog), reader.readU32(), reader.readU32());
    }
    toFields() {
        const fields = serializeToFields(...PrivateLogData.getFields(this));
        if (fields.length !== PRIVATE_LOG_DATA_LENGTH) {
            throw new Error(`Invalid number of fields for PrivateLogData. Expected ${PRIVATE_LOG_DATA_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateLogData(reader.readObject(PrivateLog), reader.readNumber(), reader.readNumber());
    }
    toBuffer() {
        return serializeToBuffer(...PrivateLogData.getFields(this));
    }
    static empty() {
        return new PrivateLogData(PrivateLog.empty(), 0, 0);
    }
    isEmpty() {
        return this.log.isEmpty() && !this.noteHashCounter && !this.counter;
    }
    [inspect.custom]() {
        return `PrivateLogData {
      log: ${this.log}
      noteHashCounter: ${this.noteHashCounter}
      counter: ${this.counter}
    }`;
    }
}
export class ScopedPrivateLogData {
    inner;
    contractAddress;
    constructor(inner, contractAddress){
        this.inner = inner;
        this.contractAddress = contractAddress;
    }
    static from(fields) {
        return new ScopedPrivateLogData(...ScopedPrivateLogData.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.inner,
            fields.contractAddress
        ];
    }
    toFields() {
        return serializeToFields(...ScopedPrivateLogData.getFields(this));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new ScopedPrivateLogData(reader.readObject(PrivateLogData), AztecAddress.fromField(reader.readField()));
    }
    isEmpty() {
        return this.inner.isEmpty() && this.contractAddress.isZero();
    }
    static empty() {
        return new ScopedPrivateLogData(PrivateLogData.empty(), AztecAddress.ZERO);
    }
    toBuffer() {
        return serializeToBuffer(...ScopedPrivateLogData.getFields(this));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new ScopedPrivateLogData(PrivateLogData.fromBuffer(reader), AztecAddress.fromBuffer(reader));
    }
    [inspect.custom]() {
        return `ScopedPrivateLogData {
      inner: ${this.inner}
      contractAddress: ${this.contractAddress}
    }`;
    }
}
