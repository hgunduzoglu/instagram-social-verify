import { MAX_NOTE_HASH_READ_REQUESTS_PER_TX } from '@aztec/constants';
import { countAccumulatedItems, getNonEmptyItems } from '../utils/order_and_comparison.js';
import { NoteHashReadRequestHintsBuilder } from './note_hash_read_request_hints.js';
import { PendingReadHint, ReadRequestResetStates, ReadRequestState } from './read_request_hints.js';
import { ScopedValueCache } from './scoped_value_cache.js';
export function isValidNoteHashReadRequest(readRequest, noteHash) {
    return noteHash.value.equals(readRequest.value) && noteHash.contractAddress.equals(readRequest.contractAddress) && readRequest.counter > noteHash.counter;
}
export function getNoteHashReadRequestResetStates(noteHashReadRequests, noteHashes, futureNoteHashes) {
    const resetStates = ReadRequestResetStates.empty(MAX_NOTE_HASH_READ_REQUESTS_PER_TX);
    const noteHashMap = new Map();
    getNonEmptyItems(noteHashes).forEach((noteHash, index)=>{
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({
            noteHash,
            index
        });
        noteHashMap.set(value, arr);
    });
    const futureNoteHashMap = new ScopedValueCache(futureNoteHashes);
    const numReadRequests = countAccumulatedItems(noteHashReadRequests);
    for(let i = 0; i < numReadRequests; ++i){
        const readRequest = noteHashReadRequests[i];
        const pendingNoteHash = noteHashMap.get(readRequest.value.toBigInt())?.find((n)=>isValidNoteHashReadRequest(readRequest, n.noteHash));
        if (pendingNoteHash !== undefined) {
            resetStates.states[i] = ReadRequestState.PENDING;
            resetStates.pendingReadHints.push(new PendingReadHint(i, pendingNoteHash.index));
        } else if (!futureNoteHashMap.get(readRequest).find((futureNoteHash)=>isValidNoteHashReadRequest(readRequest, futureNoteHash))) {
            resetStates.states[i] = ReadRequestState.SETTLED;
        }
    }
    return resetStates;
}
export async function buildNoteHashReadRequestHintsFromResetStates(oracle, noteHashReadRequests, noteHashes, resetStates, noteHashLeafIndexMap, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const builder = new NoteHashReadRequestHintsBuilder(maxPending, maxSettled);
    resetStates.pendingReadHints.forEach((hint)=>{
        builder.addPendingReadRequest(hint.readRequestIndex, hint.pendingValueIndex);
    });
    for(let i = 0; i < resetStates.states.length; i++){
        if (resetStates.states[i] === ReadRequestState.SETTLED) {
            const readRequest = noteHashReadRequests[i];
            const leafIndex = noteHashLeafIndexMap.get(readRequest.value.toBigInt());
            if (leafIndex === undefined) {
                throw new Error('Read request is reading an unknown note hash.');
            }
            const membershipWitness = await oracle.getNoteHashMembershipWitness(leafIndex);
            builder.addSettledReadRequest(i, membershipWitness, readRequest.value);
        }
    }
    const noteHashMap = new Map();
    getNonEmptyItems(noteHashes).forEach((noteHash, index)=>{
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({
            noteHash,
            index
        });
        noteHashMap.set(value, arr);
    });
    return builder.toHints();
}
export async function buildNoteHashReadRequestHints(oracle, noteHashReadRequests, noteHashes, noteHashLeafIndexMap, futureNoteHashes, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const resetStates = getNoteHashReadRequestResetStates(noteHashReadRequests, noteHashes, futureNoteHashes);
    return await buildNoteHashReadRequestHintsFromResetStates(oracle, noteHashReadRequests, noteHashes, resetStates, noteHashLeafIndexMap, maxPending, maxSettled);
}
