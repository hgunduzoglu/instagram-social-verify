import { MAX_CONTRACT_CLASS_LOGS_PER_TX, MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PRIVATE_LOGS_PER_TX, PRIVATE_TO_ROLLUP_ACCUMULATED_DATA_LENGTH } from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { arraySerializedSizeOfNonEmpty } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/fields';
import { bufferSchemaFor } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { inspect } from 'util';
import { PrivateLog } from '../logs/private_log.js';
import { ScopedL2ToL1Message } from '../messaging/l2_to_l1_message.js';
import { ScopedLogHash } from './log_hash.js';
/**
 * Data that is accumulated during the execution of the transaction.
 */ export class PrivateToRollupAccumulatedData {
    noteHashes;
    nullifiers;
    l2ToL1Msgs;
    privateLogs;
    contractClassLogsHashes;
    constructor(/**
     * The new note hashes made in this transaction.
     */ noteHashes, /**
     * The new nullifiers made in this transaction.
     */ nullifiers, /**
     * All the new L2 to L1 messages created in this transaction.
     */ l2ToL1Msgs, /**
     * All the logs created emitted from the private functions in this transaction.
     */ privateLogs, /**
     * Accumulated contract class logs hash from all the previous kernel iterations.
     * Note: Truncated to 31 bytes to fit in Fr.
     */ contractClassLogsHashes){
        this.noteHashes = noteHashes;
        this.nullifiers = nullifiers;
        this.l2ToL1Msgs = l2ToL1Msgs;
        this.privateLogs = privateLogs;
        this.contractClassLogsHashes = contractClassLogsHashes;
    }
    getSize() {
        return arraySerializedSizeOfNonEmpty(this.noteHashes) + arraySerializedSizeOfNonEmpty(this.nullifiers) + arraySerializedSizeOfNonEmpty(this.l2ToL1Msgs) + arraySerializedSizeOfNonEmpty(this.privateLogs) + arraySerializedSizeOfNonEmpty(this.contractClassLogsHashes);
    }
    static getFields(fields) {
        return [
            fields.noteHashes,
            fields.nullifiers,
            fields.l2ToL1Msgs,
            fields.privateLogs,
            fields.contractClassLogsHashes
        ];
    }
    static from(fields) {
        return new PrivateToRollupAccumulatedData(...PrivateToRollupAccumulatedData.getFields(fields));
    }
    static get schema() {
        return bufferSchemaFor(PrivateToRollupAccumulatedData);
    }
    toJSON() {
        return this.toBuffer();
    }
    toBuffer() {
        return serializeToBuffer(...PrivateToRollupAccumulatedData.getFields(this));
    }
    toString() {
        return bufferToHex(this.toBuffer());
    }
    /**
   * Deserializes from a buffer or reader, corresponding to a write in cpp.
   * @param buffer - Buffer or reader to read from.
   * @returns Deserialized object.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateToRollupAccumulatedData(reader.readArray(MAX_NOTE_HASHES_PER_TX, Fr), reader.readArray(MAX_NULLIFIERS_PER_TX, Fr), reader.readArray(MAX_L2_TO_L1_MSGS_PER_TX, ScopedL2ToL1Message), reader.readArray(MAX_PRIVATE_LOGS_PER_TX, PrivateLog), reader.readArray(MAX_CONTRACT_CLASS_LOGS_PER_TX, ScopedLogHash));
    }
    /**
   * Deserializes from a string, corresponding to a write in cpp.
   * @param str - String to read from.
   * @returns Deserialized object.
   */ static fromString(str) {
        return PrivateToRollupAccumulatedData.fromBuffer(hexToBuffer(str));
    }
    static empty() {
        return new PrivateToRollupAccumulatedData(makeTuple(MAX_NOTE_HASHES_PER_TX, Fr.zero), makeTuple(MAX_NULLIFIERS_PER_TX, Fr.zero), makeTuple(MAX_L2_TO_L1_MSGS_PER_TX, ScopedL2ToL1Message.empty), makeTuple(MAX_PRIVATE_LOGS_PER_TX, PrivateLog.empty), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ScopedLogHash.empty));
    }
    toFields() {
        const fields = serializeToFields(...PrivateToRollupAccumulatedData.getFields(this));
        if (fields.length !== PRIVATE_TO_ROLLUP_ACCUMULATED_DATA_LENGTH) {
            throw new Error(`Invalid number of fields for PrivateToRollupAccumulatedData. Expected ${PRIVATE_TO_ROLLUP_ACCUMULATED_DATA_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    [inspect.custom]() {
        return `PrivateToRollupAccumulatedData {
      noteHashes: [${this.noteHashes.filter((x)=>!x.isZero()).map((x)=>inspect(x)).join(', ')}],
      nullifiers: [${this.nullifiers.filter((x)=>!x.isZero()).map((x)=>inspect(x)).join(', ')}],
      l2ToL1Msgs: [${this.l2ToL1Msgs.filter((x)=>!x.isEmpty()).map((x)=>inspect(x)).join(', ')}],
      privateLogs:  [${this.privateLogs.filter((x)=>!x.isEmpty()).map((x)=>inspect(x)).join(', ')}]
      contractClassLogsHashes: : [${this.contractClassLogsHashes.filter((x)=>!x.isEmpty()).map((x)=>inspect(x)).join(', ')}],
    }`;
    }
}
