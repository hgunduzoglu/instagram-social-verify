import { MAX_NULLIFIER_READ_REQUESTS_PER_TX } from '@aztec/constants';
import { padArrayEnd } from '@aztec/foundation/collection';
import { AztecAddress } from '../../aztec-address/index.js';
import { siloNullifier } from '../../hash/hash.js';
import { Nullifier } from '../nullifier.js';
import { countAccumulatedItems, getNonEmptyItems } from '../utils/order_and_comparison.js';
import { NullifierReadRequestHintsBuilder } from './nullifier_read_request_hints.js';
import { ReadRequest, ScopedReadRequest } from './read_request.js';
import { PendingReadHint, ReadRequestResetStates, ReadRequestState } from './read_request_hints.js';
import { ScopedValueCache } from './scoped_value_cache.js';
export function isValidNullifierReadRequest(readRequest, nullifier) {
    return readRequest.value.equals(nullifier.value) && nullifier.contractAddress.equals(readRequest.contractAddress) && readRequest.counter > nullifier.counter;
}
export function getNullifierReadRequestResetStates(nullifierReadRequests, nullifiers, futureNullifiers) {
    const resetStates = ReadRequestResetStates.empty(MAX_NULLIFIER_READ_REQUESTS_PER_TX);
    const nullifierMap = new Map();
    getNonEmptyItems(nullifiers).forEach((nullifier, index)=>{
        const value = nullifier.value.toBigInt();
        const arr = nullifierMap.get(value) ?? [];
        arr.push({
            nullifier,
            index
        });
        nullifierMap.set(value, arr);
    });
    const futureNullifiersMap = new ScopedValueCache(futureNullifiers);
    const numReadRequests = countAccumulatedItems(nullifierReadRequests);
    for(let i = 0; i < numReadRequests; ++i){
        const readRequest = nullifierReadRequests[i];
        const pendingNullifier = nullifierMap.get(readRequest.value.toBigInt())?.find(({ nullifier })=>isValidNullifierReadRequest(readRequest, nullifier));
        if (pendingNullifier !== undefined) {
            resetStates.states[i] = ReadRequestState.PENDING;
            resetStates.pendingReadHints.push(new PendingReadHint(i, pendingNullifier.index));
        } else if (!futureNullifiersMap.get(readRequest).some((futureNullifier)=>isValidNullifierReadRequest(readRequest, futureNullifier))) {
            resetStates.states[i] = ReadRequestState.SETTLED;
        }
    }
    return resetStates;
}
export async function buildNullifierReadRequestHintsFromResetStates(oracle, nullifierReadRequests, resetStates, maxPending = MAX_NULLIFIER_READ_REQUESTS_PER_TX, maxSettled = MAX_NULLIFIER_READ_REQUESTS_PER_TX, siloed = false) {
    const builder = new NullifierReadRequestHintsBuilder(maxPending, maxSettled);
    resetStates.pendingReadHints.forEach((hint)=>{
        builder.addPendingReadRequest(hint.readRequestIndex, hint.pendingValueIndex);
    });
    for(let i = 0; i < resetStates.states.length; i++){
        if (resetStates.states[i] === ReadRequestState.SETTLED) {
            const readRequest = nullifierReadRequests[i];
            const siloedValue = siloed ? readRequest.value : await siloNullifier(readRequest.contractAddress, readRequest.value);
            const membershipWitnessWithPreimage = await oracle.getNullifierMembershipWitness(siloedValue);
            builder.addSettledReadRequest(i, membershipWitnessWithPreimage.membershipWitness, membershipWitnessWithPreimage.leafPreimage);
        }
    }
    return builder.toHints();
}
export async function buildNullifierReadRequestHints(oracle, nullifierReadRequests, nullifiers, futureNullifiers, maxPending = MAX_NULLIFIER_READ_REQUESTS_PER_TX, maxSettled = MAX_NULLIFIER_READ_REQUESTS_PER_TX, siloed = false) {
    const resetStates = getNullifierReadRequestResetStates(nullifierReadRequests, nullifiers, futureNullifiers);
    return await buildNullifierReadRequestHintsFromResetStates(oracle, nullifierReadRequests, resetStates, maxPending, maxSettled, siloed);
}
export async function buildSiloedNullifierReadRequestHints(oracle, nullifierReadRequests, nullifiers, maxPending = MAX_NULLIFIER_READ_REQUESTS_PER_TX, maxSettled = MAX_NULLIFIER_READ_REQUESTS_PER_TX) {
    // Nullifiers outputted from public kernels are already siloed while read requests are not.
    // Siloing the read request values and set the contract addresses to zero to find the matching nullifier contexts.
    const nonEmptyNullifierReadRequests = getNonEmptyItems(nullifierReadRequests);
    const readRequests = await Promise.all(nonEmptyNullifierReadRequests.map(async (r)=>new ReadRequest(await siloNullifier(r.contractAddress, r.value), r.counter).scope(AztecAddress.ZERO)));
    const siloedReadRequests = padArrayEnd(readRequests, ScopedReadRequest.empty(), MAX_NULLIFIER_READ_REQUESTS_PER_TX);
    const scopedNullifiers = nullifiers.map((n)=>new Nullifier(n.value, n.counter, n.noteHash).scope(AztecAddress.ZERO));
    return buildNullifierReadRequestHints(oracle, siloedReadRequests, scopedNullifiers, [], maxPending, maxSettled, true);
}
