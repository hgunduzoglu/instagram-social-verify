// Define these utils here as their design is very specific to kernel's accumulated data and not general enough to be put in foundation.
// Returns number of non-empty items in an array.
export function countAccumulatedItems(arr) {
    return arr.reduce((num, item, i)=>{
        if (!item.isEmpty()) {
            if (num !== i) {
                throw new Error('Non-empty items must be placed continuously from index 0.');
            }
            return num + 1;
        }
        return num;
    }, 0);
}
// Merges two arrays of length N into an array of length N.
export function mergeAccumulatedData(arr0, arr1, length = arr0.length) {
    const numNonEmptyItems0 = countAccumulatedItems(arr0);
    const numNonEmptyItems1 = countAccumulatedItems(arr1);
    if (numNonEmptyItems0 + numNonEmptyItems1 > length) {
        throw new Error('Combined non-empty items exceeded the maximum allowed.');
    }
    const arr = [
        ...arr0
    ];
    arr1.slice(0, numNonEmptyItems1).forEach((item, i)=>arr[i + numNonEmptyItems0] = item);
    return arr;
}
// Sort items by a provided compare function. All empty items are padded to the right.
function genericSort(arr, compareFn, ascending = true) {
    return [
        ...arr
    ].sort((a, b)=>{
        if (a.isEmpty()) {
            return 1; // Move empty items to the right.
        }
        if (b.isEmpty()) {
            return -1; // Move non-empty items to the left.
        }
        return ascending ? compareFn(a, b) : compareFn(b, a);
    });
}
function compareByCounter(a, b) {
    return a.counter - b.counter;
}
export function sortByCounter(arr, ascending = true) {
    return genericSort(arr, compareByCounter, ascending);
}
export function isEmptyArray(arr) {
    return arr.every((item)=>item.isEmpty());
}
export function getNonEmptyItems(arr) {
    return arr.filter((item)=>!item.isEmpty());
}
