import { MAX_PROTOCOL_CONTRACTS } from '@aztec/constants';
import { toBigIntBE } from '@aztec/foundation/bigint-buffer';
import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader } from '@aztec/foundation/serialize';
import { z } from 'zod';
/**
 * Class containing the data of a preimage of a single leaf in the protocol contract tree.
 * Note: It's called preimage because this data gets hashed before being inserted as a node into the `IndexedTree`.
 * Note: Though this tree contains addresses, they are converted to fields to avoid unnecessary conversions in the tree.
 */ export class ProtocolContractLeafPreimage {
    address;
    nextAddress;
    nextIndex;
    constructor(/**
     * Leaf value inside the indexed tree's linked list.
     */ address, /**
     * Next value inside the indexed tree's linked list.
     */ nextAddress, /**
     * Index of the next leaf in the indexed tree's linked list.
     */ nextIndex){
        this.address = address;
        this.nextAddress = nextAddress;
        this.nextIndex = nextIndex;
    }
    static get schema() {
        return z.object({
            address: schemas.Fr,
            nextAddress: schemas.Fr,
            nextIndex: schemas.BigInt
        }).transform(({ address, nextAddress, nextIndex })=>new ProtocolContractLeafPreimage(address, nextAddress, nextIndex));
    }
    getKey() {
        return this.address.toBigInt();
    }
    getNextKey() {
        return this.nextAddress.toBigInt();
    }
    getNextIndex() {
        return this.nextIndex;
    }
    asLeaf() {
        return new ProtocolContractLeaf(this.address);
    }
    toBuffer() {
        return Buffer.concat(this.toHashInputs());
    }
    toHashInputs() {
        // Note: the protocol contract leaves only hash the value and next value.
        return [
            Buffer.from(this.address.toBuffer()),
            Buffer.from(this.nextAddress.toBuffer())
        ];
    }
    toFields() {
        return [
            this.address,
            this.nextAddress,
            new Fr(this.nextIndex)
        ];
    }
    static random() {
        return new ProtocolContractLeafPreimage(Fr.random(), Fr.random(), BigInt(Math.floor(Math.random() * 1000) % MAX_PROTOCOL_CONTRACTS));
    }
    static empty() {
        return new ProtocolContractLeafPreimage(Fr.ZERO, Fr.ZERO, 0n);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new ProtocolContractLeafPreimage(reader.readObject(Fr), reader.readObject(Fr), toBigIntBE(reader.readBytes(32)));
    }
}
/**
 * An address to be inserted or checked in the protocol contract tree.
 */ export class ProtocolContractLeaf {
    address;
    constructor(/**
     * Address value.
     */ address){
        this.address = address;
    }
    getKey() {
        return this.address.toBigInt();
    }
    toBuffer() {
        return this.address.toBuffer();
    }
    isEmpty() {
        return this.address.isZero();
    }
    updateTo(_another) {
        throw new Error('Protocol contract tree is insert only');
    }
    static buildDummy(key) {
        return new ProtocolContractLeaf(new Fr(key));
    }
    static fromBuffer(buf) {
        return new ProtocolContractLeaf(Fr.fromBuffer(buf));
    }
}
