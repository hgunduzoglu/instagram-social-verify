import { toBigIntBE, toBufferBE } from '@aztec/foundation/bigint-buffer';
import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
/**
 * Class containing the data of a preimage of a single leaf in the public data tree.
 * Note: It's called preimage because this data gets hashed before being inserted as a node into the `IndexedTree`.
 */ export class PublicDataTreeLeafPreimage {
    leaf;
    nextKey;
    nextIndex;
    constructor(/**
     * The leaf (slot, value).
     */ leaf, /**
     * Next key (slot) inside the indexed tree's linked list.
     */ nextKey, /**
     * Index of the next leaf in the indexed tree's linked list.
     */ nextIndex){
        this.leaf = leaf;
        this.nextKey = nextKey;
        this.nextIndex = nextIndex;
    }
    static get schema() {
        return z.object({
            leaf: PublicDataTreeLeaf.schema,
            nextKey: schemas.Fr,
            nextIndex: schemas.BigInt
        }).transform(({ leaf, nextKey, nextIndex })=>new PublicDataTreeLeafPreimage(leaf, nextKey, nextIndex));
    }
    static get leafSchema() {
        return PublicDataTreeLeaf.schema;
    }
    getKey() {
        return this.leaf.getKey();
    }
    getNextKey() {
        return this.nextKey.toBigInt();
    }
    getNextIndex() {
        return this.nextIndex;
    }
    asLeaf() {
        return this.leaf;
    }
    toBuffer() {
        return Buffer.concat(this.toHashInputs());
    }
    toHashInputs() {
        return [
            ...this.leaf.toHashInputs(),
            Buffer.from(toBufferBE(this.nextIndex, 32)),
            Buffer.from(this.nextKey.toBuffer())
        ];
    }
    clone() {
        return new PublicDataTreeLeafPreimage(this.leaf.clone(), this.nextKey, this.nextIndex);
    }
    static random() {
        return new PublicDataTreeLeafPreimage(PublicDataTreeLeaf.buildDummy(BigInt(Math.floor(Math.random() * 1000))), Fr.random(), BigInt(Math.floor(Math.random() * 1000)));
    }
    static empty() {
        return new PublicDataTreeLeafPreimage(PublicDataTreeLeaf.empty(), Fr.ZERO, 0n);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const value = PublicDataTreeLeaf.fromBuffer(reader);
        const nextIndex = toBigIntBE(reader.readBytes(32));
        const nextSlot = Fr.fromBuffer(reader);
        return new PublicDataTreeLeafPreimage(value, nextSlot, nextIndex);
    }
    static fromLeaf(leaf, nextKey, nextIndex) {
        return new PublicDataTreeLeafPreimage(leaf, new Fr(nextKey), nextIndex);
    }
    static clone(preimage) {
        return preimage.clone();
    }
}
/**
 * A leaf in the public data indexed tree.
 */ export class PublicDataTreeLeaf {
    slot;
    value;
    constructor(/**
     * The slot the value is stored in
     */ slot, /**
     * The value stored in the slot
     */ value){
        this.slot = slot;
        this.value = value;
    }
    getKey() {
        return this.slot.toBigInt();
    }
    toBuffer() {
        return serializeToBuffer([
            this.slot,
            this.value
        ]);
    }
    clone() {
        return new PublicDataTreeLeaf(this.slot, this.value);
    }
    toHashInputs() {
        return [
            this.slot.toBuffer(),
            this.value.toBuffer()
        ];
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicDataTreeLeaf(Fr.fromBuffer(reader), Fr.fromBuffer(reader));
    }
    equals(another) {
        return this.slot.equals(another.slot) && this.value.equals(another.value);
    }
    toString() {
        return `PublicDataTreeLeaf(${this.slot.toString()}, ${this.value.toString()})`;
    }
    isEmpty() {
        return this.slot.isZero() && this.value.isZero();
    }
    updateTo(another) {
        if (!this.slot.equals(another.slot)) {
            throw new Error('Invalid update: slots do not match');
        }
        return new PublicDataTreeLeaf(this.slot, another.value);
    }
    static buildDummy(key) {
        return new PublicDataTreeLeaf(new Fr(key), new Fr(0));
    }
    static empty() {
        return new PublicDataTreeLeaf(Fr.ZERO, Fr.ZERO);
    }
    static get schema() {
        return z.object({
            slot: schemas.Fr,
            value: schemas.Fr
        }).transform(({ slot, value })=>new PublicDataTreeLeaf(slot, value));
    }
}
