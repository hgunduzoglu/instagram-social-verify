import { toBigIntBE, toBufferBE } from '@aztec/foundation/bigint-buffer';
import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader } from '@aztec/foundation/serialize';
import { z } from 'zod';
/**
 * Class containing the data of a preimage of a single leaf in the nullifier tree.
 * Note: It's called preimage because this data gets hashed before being inserted as a node into the `IndexedTree`.
 */ export class NullifierLeafPreimage {
    leaf;
    nextKey;
    nextIndex;
    constructor(/**
     * Leaf value inside the indexed tree's linked list.
     */ leaf, /**
     * Next nullifier inside the indexed tree's linked list.
     */ nextKey, /**
     * Index of the next leaf in the indexed tree's linked list.
     */ nextIndex){
        this.leaf = leaf;
        this.nextKey = nextKey;
        this.nextIndex = nextIndex;
    }
    static get schema() {
        return z.object({
            leaf: NullifierLeaf.schema,
            nextKey: schemas.Fr,
            nextIndex: schemas.BigInt
        }).transform(({ leaf, nextKey, nextIndex })=>new NullifierLeafPreimage(leaf, nextKey, nextIndex));
    }
    static get leafSchema() {
        return NullifierLeaf.schema;
    }
    getKey() {
        return this.leaf.getKey();
    }
    getNextKey() {
        return this.nextKey.toBigInt();
    }
    getNextIndex() {
        return this.nextIndex;
    }
    asLeaf() {
        return this.leaf;
    }
    toBuffer() {
        return Buffer.concat(this.toHashInputs());
    }
    toHashInputs() {
        return [
            ...this.leaf.toHashInputs(),
            Buffer.from(this.nextKey.toBuffer()),
            Buffer.from(toBufferBE(this.nextIndex, 32))
        ];
    }
    toFields() {
        return this.toHashInputs().map((buf)=>Fr.fromBuffer(buf));
    }
    clone() {
        return new NullifierLeafPreimage(this.leaf.clone(), this.nextKey, this.nextIndex);
    }
    static random() {
        return new NullifierLeafPreimage(NullifierLeaf.random(), Fr.random(), BigInt(Math.floor(Math.random() * 1000)));
    }
    static empty() {
        return new NullifierLeafPreimage(NullifierLeaf.empty(), Fr.zero(), 0n);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new NullifierLeafPreimage(NullifierLeaf.fromBuffer(reader), reader.readObject(Fr), toBigIntBE(reader.readBytes(32)));
    }
    static fromLeaf(leaf, nextKey, nextIndex) {
        return new NullifierLeafPreimage(leaf, new Fr(nextKey), nextIndex);
    }
    static clone(preimage) {
        return preimage.clone();
    }
}
/**
 * A nullifier to be inserted in the nullifier tree.
 */ export class NullifierLeaf {
    nullifier;
    constructor(/**
     * Nullifier value.
     */ nullifier){
        this.nullifier = nullifier;
    }
    getKey() {
        return this.nullifier.toBigInt();
    }
    toBuffer() {
        return this.nullifier.toBuffer();
    }
    clone() {
        return new NullifierLeaf(new Fr(this.nullifier));
    }
    toHashInputs() {
        return [
            Buffer.from(this.nullifier.toBuffer())
        ];
    }
    static empty() {
        return new NullifierLeaf(Fr.ZERO);
    }
    static random() {
        return new NullifierLeaf(Fr.random());
    }
    isEmpty() {
        return this.nullifier.isZero();
    }
    updateTo(_another) {
        throw new Error('Nullifiers are create only');
    }
    static buildDummy(key) {
        return new NullifierLeaf(new Fr(key));
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        return new NullifierLeaf(reader.readObject(Fr));
    }
    static get schema() {
        return z.object({
            nullifier: schemas.Fr
        }).transform(({ nullifier })=>new NullifierLeaf(nullifier));
    }
}
