import { fromEntries, getEntries, pick } from '@aztec/foundation/collection';
import { jsonStringify } from '@aztec/foundation/json-rpc';
import { getBasePath, getSnapshotIndex, getSnapshotIndexPath } from './download.js';
export async function uploadSnapshot(localPaths, schemaVersions, metadata, store) {
    const timestamp = Date.now();
    const date = new Date().toISOString().replace(/[-:T]/g, '').replace(/\..+$/, '');
    const basePath = getBasePath(metadata);
    const targetPathFor = (key)=>`${basePath}/${key}-${date}-${metadata.l2BlockHash}.db`;
    const dataUrls = fromEntries(await Promise.all(getEntries(localPaths).map(async ([key, path])=>[
            key,
            await store.upload(targetPathFor(key), path, {
                compress: true,
                public: true
            })
        ])));
    const snapshotsIndex = await getSnapshotIndex(metadata, store) ?? createEmptyIndex(metadata);
    const newSnapshotMetadata = {
        ...pick(metadata, 'l1BlockNumber', 'l2BlockHash', 'l2BlockNumber'),
        schemaVersions,
        timestamp,
        dataUrls
    };
    snapshotsIndex.snapshots.unshift(newSnapshotMetadata);
    await store.save(getSnapshotIndexPath(metadata), Buffer.from(jsonStringify(snapshotsIndex, true)), {
        public: true,
        metadata: {
            ['Cache-control']: 'no-store'
        }
    });
    return newSnapshotMetadata;
}
function createEmptyIndex(metadata) {
    return {
        ...pick(metadata, 'l1ChainId', 'rollupVersion', 'rollupAddress'),
        snapshots: []
    };
}
