import { BlockBlobPublicInputs } from '@aztec/blob-lib';
import { AZTEC_MAX_EPOCH_DURATION } from '@aztec/constants';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
import { bufferSchemaFor } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { GlobalVariables } from '../tx/global_variables.js';
/**
 * Output of the block root and block merge rollup circuits.
 */ export class BlockRootOrBlockMergePublicInputs {
    previousArchive;
    newArchive;
    startGlobalVariables;
    endGlobalVariables;
    outHash;
    fees;
    vkTreeRoot;
    protocolContractTreeRoot;
    proverId;
    blobPublicInputs;
    constructor(/**
     * Archive tree immediately before this block range.
     */ previousArchive, /**
     * Archive tree after adding this block range.
     */ newArchive, /**
     * Global variables for the first block in the range.
     */ startGlobalVariables, /**
     * Global variables for the last block in the range.
     */ endGlobalVariables, /**
     * SHA256 hash of L2 to L1 messages. Used to make public inputs constant-sized (to then be opened on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */ outHash, /**
     * The summed `transaction_fee`s and recipients of the constituent blocks.
     */ fees, /**
     * Root of the verification key tree.
     */ vkTreeRoot, /**
     * Root of the protocol contract tree.
     */ protocolContractTreeRoot, /**
     * TODO(#7346): Temporarily added prover_id while we verify block-root proofs on L1
     */ proverId, /**
     * Public inputs required to verify a blob (challenge point z, evaluation y = p(z), and the commitment to p() for each blob)
     */ blobPublicInputs){
        this.previousArchive = previousArchive;
        this.newArchive = newArchive;
        this.startGlobalVariables = startGlobalVariables;
        this.endGlobalVariables = endGlobalVariables;
        this.outHash = outHash;
        this.fees = fees;
        this.vkTreeRoot = vkTreeRoot;
        this.protocolContractTreeRoot = protocolContractTreeRoot;
        this.proverId = proverId;
        this.blobPublicInputs = blobPublicInputs;
    }
    /**
   * Deserializes from a buffer or reader.
   * @param buffer - Buffer or reader to read from.
   * @returns The deserialized public inputs.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new BlockRootOrBlockMergePublicInputs(reader.readObject(AppendOnlyTreeSnapshot), reader.readObject(AppendOnlyTreeSnapshot), reader.readObject(GlobalVariables), reader.readObject(GlobalVariables), Fr.fromBuffer(reader), reader.readArray(AZTEC_MAX_EPOCH_DURATION, FeeRecipient), Fr.fromBuffer(reader), Fr.fromBuffer(reader), Fr.fromBuffer(reader), reader.readArray(AZTEC_MAX_EPOCH_DURATION, BlockBlobPublicInputs));
    }
    /**
   * Serialize this as a buffer.
   * @returns The buffer.
   */ toBuffer() {
        return serializeToBuffer(this.previousArchive, this.newArchive, this.startGlobalVariables, this.endGlobalVariables, this.outHash, this.fees, this.vkTreeRoot, this.protocolContractTreeRoot, this.proverId, this.blobPublicInputs);
    }
    /**
   * Serialize this as a hex string.
   * @returns - The hex string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    /**
   * Deserializes from a hex string.
   * @param str - A hex string to deserialize from.
   * @returns A new BaseOrMergeRollupPublicInputs instance.
   */ static fromString(str) {
        return BlockRootOrBlockMergePublicInputs.fromBuffer(hexToBuffer(str));
    }
    /** Returns a buffer representation for JSON serialization. */ toJSON() {
        return this.toBuffer();
    }
    /** Creates an instance from a hex string. */ static get schema() {
        return bufferSchemaFor(BlockRootOrBlockMergePublicInputs);
    }
}
export class FeeRecipient {
    recipient;
    value;
    constructor(recipient, value){
        this.recipient = recipient;
        this.value = value;
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new FeeRecipient(reader.readObject(EthAddress), Fr.fromBuffer(reader));
    }
    toBuffer() {
        return serializeToBuffer(this.recipient, this.value);
    }
    static getFields(fields) {
        return [
            fields.recipient,
            fields.value
        ];
    }
    toFields() {
        return serializeToFields(...FeeRecipient.getFields(this));
    }
    isEmpty() {
        return this.value.isZero() && this.recipient.isZero();
    }
    toFriendlyJSON() {
        if (this.isEmpty()) {
            return {};
        }
        return {
            recipient: this.recipient.toString(),
            value: this.value.toString()
        };
    }
    static random() {
        return new FeeRecipient(EthAddress.random(), Fr.random());
    }
}
