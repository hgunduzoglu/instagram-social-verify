import { MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
/**
 * Represents a pending tagged log as it is stored in the pending tagged log array to which the syncNotes oracle
 * inserts found private logs. A TS version of `pending_tagged_log.nr`.
 */ export class PendingTaggedLog {
    log;
    txHash;
    uniqueNoteHashesInTx;
    firstNullifierInTx;
    recipient;
    logIndexInTx;
    txIndexInBlock;
    constructor(log, txHash, uniqueNoteHashesInTx, firstNullifierInTx, recipient, logIndexInTx, txIndexInBlock){
        this.log = log;
        this.txHash = txHash;
        this.uniqueNoteHashesInTx = uniqueNoteHashesInTx;
        this.firstNullifierInTx = firstNullifierInTx;
        this.recipient = recipient;
        this.logIndexInTx = logIndexInTx;
        this.txIndexInBlock = txIndexInBlock;
    }
    toFields() {
        return [
            ...serializeBoundedVec(this.log, PRIVATE_LOG_SIZE_IN_FIELDS),
            this.txHash.hash,
            ...serializeBoundedVec(this.uniqueNoteHashesInTx, MAX_NOTE_HASHES_PER_TX),
            this.firstNullifierInTx,
            this.recipient.toField(),
            new Fr(this.logIndexInTx),
            new Fr(this.txIndexInBlock)
        ];
    }
}
/**
 * Helper function to serialize a bounded vector according to Noir's BoundedVec format
 * @param values - The values to serialize
 * @param maxLength - The maximum length of the bounded vector
 * @returns The serialized bounded vector as Fr[]
 */ function serializeBoundedVec(values, maxLength) {
    const lengthDiff = maxLength - values.length;
    const zeroPaddingArray = Array(lengthDiff).fill(Fr.ZERO);
    const storage = values.concat(zeroPaddingArray);
    return [
        ...storage,
        new Fr(values.length)
    ];
}
