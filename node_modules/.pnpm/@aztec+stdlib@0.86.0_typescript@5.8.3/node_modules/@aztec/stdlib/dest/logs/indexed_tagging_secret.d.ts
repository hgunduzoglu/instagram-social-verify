import { Fr } from '@aztec/foundation/fields';
import type { AztecAddress } from '../aztec-address/index.js';
export declare class IndexedTaggingSecret {
    appTaggingSecret: Fr;
    index: number;
    constructor(appTaggingSecret: Fr, index: number);
    toFields(): Fr[];
    static fromFields(serialized: Fr[]): IndexedTaggingSecret;
    /**
     * Computes the tag based on the app tagging secret, recipient and index.
     * @dev By including the recipient we achieve "directionality" of the tag (when sending a note in the other
     * direction, the tag will be different).
     * @param recipient The recipient of the note
     * @returns The tag.
     */
    computeTag(recipient: AztecAddress): Promise<Fr>;
    /**
     * Computes the siloed tag.
     * @dev We do this second layer of siloing (one was already done as the tagging secret is app-siloed) because kernels
     * do that to protect against contract impersonation attacks. This extra layer of siloing in kernels ensures that
     * a malicious contract cannot emit a note with a tag corresponding to another contract.
     * @param recipient The recipient of the note
     * @param app The app address
     * @returns The siloed tag.
     */
    computeSiloedTag(recipient: AztecAddress, app: AztecAddress): Promise<Fr>;
}
//# sourceMappingURL=indexed_tagging_secret.d.ts.map