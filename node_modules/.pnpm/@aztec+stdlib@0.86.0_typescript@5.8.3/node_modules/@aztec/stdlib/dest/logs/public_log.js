import { PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_LOG_DATA_SIZE_IN_FIELDS, PUBLIC_LOG_SIZE_IN_FIELDS } from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
export class PublicLog {
    contractAddress;
    log;
    static SIZE_IN_BYTES = Fr.SIZE_IN_BYTES * PUBLIC_LOG_SIZE_IN_FIELDS;
    constructor(contractAddress, log){
        this.contractAddress = contractAddress;
        this.log = log;
    }
    toFields() {
        return serializeToFields(...PublicLog.getFields(this));
    }
    static getFields(fields) {
        return [
            fields.contractAddress,
            fields.log
        ];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new PublicLog(reader.readObject(AztecAddress), reader.readFieldArray(PUBLIC_LOG_DATA_SIZE_IN_FIELDS));
    }
    isEmpty() {
        return this.contractAddress.isZero() && this.log.every((f)=>f.isZero());
    }
    static empty() {
        return new PublicLog(AztecAddress.ZERO, makeTuple(PUBLIC_LOG_DATA_SIZE_IN_FIELDS, Fr.zero));
    }
    toBuffer() {
        return serializeToBuffer(...PublicLog.getFields(this));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicLog(reader.readObject(AztecAddress), reader.readArray(PUBLIC_LOG_DATA_SIZE_IN_FIELDS, Fr));
    }
    static async random() {
        return new PublicLog(await AztecAddress.random(), makeTuple(PUBLIC_LOG_DATA_SIZE_IN_FIELDS, Fr.random));
    }
    getEmittedLength() {
        // This assumes that we cut trailing zeroes from the end of the log. In ts, these will always be added back.
        // Does not include length prefix.
        return this.getEmittedFields().length;
    }
    getEmittedFields() {
        const fields = this.toFields();
        const lastNonZeroIndex = fields.findLastIndex((f)=>!f.isZero());
        return fields.slice(0, lastNonZeroIndex + 1);
    }
    equals(other) {
        return this.contractAddress.equals(other.contractAddress) && this.log.reduce((acc, field, i)=>acc && field.equals(other.log[i]), true);
    }
    toHumanReadable() {
        return `PublicLog: (contractAddress: ${this.contractAddress} log: ${this.log})`;
    }
    static get schema() {
        if (PUBLIC_LOG_DATA_SIZE_IN_FIELDS + 1 == PRIVATE_LOG_SIZE_IN_FIELDS) {
            throw new Error('Constants got updated and schema for PrivateLog matches that of PublicLog. This needs to be updated now as Zod is no longer able to differentiate the 2 in TxScopedL2Log.');
        }
        return z.object({
            contractAddress: AztecAddress.schema,
            log: z.array(schemas.Fr)
        }).transform(({ contractAddress, log })=>PublicLog.fromFields([
                contractAddress.toField(),
                ...log
            ]));
    }
    [inspect.custom]() {
        return `PublicLog {
      contractAddress: ${inspect(this.contractAddress)},
      log: [${this.log.map((x)=>inspect(x)).join(', ')}],
    }`;
    }
}
