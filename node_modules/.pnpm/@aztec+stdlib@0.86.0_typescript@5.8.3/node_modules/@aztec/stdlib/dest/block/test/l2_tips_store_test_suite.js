import { times } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/fields';
import { jestExpect as expect } from '@jest/expect';
export function testL2TipsStore(makeTipsStore) {
    let tipsStore;
    beforeEach(async ()=>{
        tipsStore = await makeTipsStore();
    });
    const makeBlock = (number)=>({
            block: {
                number,
                header: {
                    hash: ()=>Promise.resolve(new Fr(number))
                }
            },
            l1: {
                blockNumber: BigInt(number),
                blockHash: `0x${number}`,
                timestamp: BigInt(number)
            },
            signatures: []
        });
    const makeBlockId = (number)=>({
            number,
            hash: new Fr(number).toString()
        });
    const makeTip = (number)=>({
            number,
            hash: number === 0 ? undefined : new Fr(number).toString()
        });
    const makeTips = (latest, proven, finalized)=>({
            latest: makeTip(latest),
            proven: makeTip(proven),
            finalized: makeTip(finalized)
        });
    it('returns zero if no tips are stored', async ()=>{
        const tips = await tipsStore.getL2Tips();
        expect(tips).toEqual(makeTips(0, 0, 0));
    });
    it('stores chain tips', async ()=>{
        await tipsStore.handleBlockStreamEvent({
            type: 'blocks-added',
            blocks: times(20, (i)=>makeBlock(i + 1))
        });
        await tipsStore.handleBlockStreamEvent({
            type: 'chain-finalized',
            block: makeBlockId(5)
        });
        await tipsStore.handleBlockStreamEvent({
            type: 'chain-proven',
            block: makeBlockId(8)
        });
        await tipsStore.handleBlockStreamEvent({
            type: 'chain-pruned',
            block: makeBlockId(10)
        });
        const tips = await tipsStore.getL2Tips();
        expect(tips).toEqual(makeTips(10, 8, 5));
    });
    it('sets latest tip from blocks added', async ()=>{
        await tipsStore.handleBlockStreamEvent({
            type: 'blocks-added',
            blocks: times(3, (i)=>makeBlock(i + 1))
        });
        const tips = await tipsStore.getL2Tips();
        expect(tips).toEqual(makeTips(3, 0, 0));
        expect(await tipsStore.getL2BlockHash(1)).toEqual(new Fr(1).toString());
        expect(await tipsStore.getL2BlockHash(2)).toEqual(new Fr(2).toString());
        expect(await tipsStore.getL2BlockHash(3)).toEqual(new Fr(3).toString());
    });
    it('clears block hashes when setting finalized chain', async ()=>{
        await tipsStore.handleBlockStreamEvent({
            type: 'blocks-added',
            blocks: times(5, (i)=>makeBlock(i + 1))
        });
        await tipsStore.handleBlockStreamEvent({
            type: 'chain-proven',
            block: makeBlockId(3)
        });
        await tipsStore.handleBlockStreamEvent({
            type: 'chain-finalized',
            block: makeBlockId(3)
        });
        const tips = await tipsStore.getL2Tips();
        expect(tips).toEqual(makeTips(5, 3, 3));
        expect(await tipsStore.getL2BlockHash(1)).toBeUndefined();
        expect(await tipsStore.getL2BlockHash(2)).toBeUndefined();
        expect(await tipsStore.getL2BlockHash(3)).toEqual(new Fr(3).toString());
        expect(await tipsStore.getL2BlockHash(4)).toEqual(new Fr(4).toString());
        expect(await tipsStore.getL2BlockHash(5)).toEqual(new Fr(5).toString());
    });
    // Regression test for #13142
    it('does not blow up when setting proven chain on an unseen block number', async ()=>{
        await tipsStore.handleBlockStreamEvent({
            type: 'blocks-added',
            blocks: [
                makeBlock(5)
            ]
        });
        await tipsStore.handleBlockStreamEvent({
            type: 'chain-proven',
            block: makeBlockId(3)
        });
        const tips = await tipsStore.getL2Tips();
        expect(tips).toEqual(makeTips(5, 3, 0));
    });
}
