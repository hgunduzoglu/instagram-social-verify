/**
 * Stores currently synced L2 tips and unfinalized block hashes.
 * @dev tests in kv-store/src/stores/l2_tips_memory_store.test.ts
 */ export class L2TipsMemoryStore {
    l2TipsStore = new Map();
    l2BlockHashesStore = new Map();
    getL2BlockHash(number) {
        return Promise.resolve(this.l2BlockHashesStore.get(number));
    }
    getL2Tips() {
        return Promise.resolve({
            latest: this.getL2Tip('latest'),
            finalized: this.getL2Tip('finalized'),
            proven: this.getL2Tip('proven')
        });
    }
    getL2Tip(tag) {
        const blockNumber = this.l2TipsStore.get(tag);
        if (blockNumber === undefined || blockNumber === 0) {
            return {
                number: 0,
                hash: undefined
            };
        }
        const blockHash = this.l2BlockHashesStore.get(blockNumber);
        if (!blockHash) {
            throw new Error(`Block hash not found for block number ${blockNumber}`);
        }
        return {
            number: blockNumber,
            hash: blockHash
        };
    }
    async handleBlockStreamEvent(event) {
        switch(event.type){
            case 'blocks-added':
                {
                    const blocks = event.blocks.map((b)=>b.block);
                    for (const block of blocks){
                        this.l2BlockHashesStore.set(block.number, await this.computeBlockHash(block));
                    }
                    this.l2TipsStore.set('latest', blocks.at(-1).number);
                    break;
                }
            case 'chain-pruned':
                this.saveTag('latest', event.block);
                break;
            case 'chain-proven':
                this.saveTag('proven', event.block);
                break;
            case 'chain-finalized':
                this.saveTag('finalized', event.block);
                for (const key of this.l2BlockHashesStore.keys()){
                    if (key < event.block.number) {
                        this.l2BlockHashesStore.delete(key);
                    }
                }
                break;
        }
    }
    saveTag(name, block) {
        this.l2TipsStore.set(name, block.number);
        if (block.hash) {
            this.l2BlockHashesStore.set(block.number, block.hash);
        }
    }
    computeBlockHash(block) {
        return block.header.hash().then((hash)=>hash.toString());
    }
}
