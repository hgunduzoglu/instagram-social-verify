import { NUM_MSGS_PER_BASE_PARITY } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
import { bufferSchemaFor } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
export class BaseParityInputs {
    msgs;
    vkTreeRoot;
    constructor(/** Aggregated proof of all the parity circuit iterations. */ msgs, /** Root of the VK tree */ vkTreeRoot){
        this.msgs = msgs;
        this.vkTreeRoot = vkTreeRoot;
    }
    static fromSlice(array, index, vkTreeRoot) {
        const start = index * NUM_MSGS_PER_BASE_PARITY;
        const end = start + NUM_MSGS_PER_BASE_PARITY;
        const msgs = array.slice(start, end);
        return new BaseParityInputs(msgs, vkTreeRoot);
    }
    /** Serializes the inputs to a buffer. */ toBuffer() {
        return serializeToBuffer(this.msgs, this.vkTreeRoot);
    }
    /** Serializes the inputs to a hex string. */ toString() {
        return bufferToHex(this.toBuffer());
    }
    /**
   * Deserializes the inputs from a buffer.
   * @param buffer - The buffer to deserialize from.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new BaseParityInputs(reader.readArray(NUM_MSGS_PER_BASE_PARITY, Fr), Fr.fromBuffer(reader));
    }
    /**
   * Deserializes the inputs from a hex string.
   * @param str - The hex string to deserialize from.
   * @returns - The deserialized inputs.
   */ static fromString(str) {
        return BaseParityInputs.fromBuffer(hexToBuffer(str));
    }
    /** Returns a buffer representation for JSON serialization. */ toJSON() {
        return this.toBuffer();
    }
    /** Creates an instance from a hex string. */ static get schema() {
        return bufferSchemaFor(BaseParityInputs);
    }
}
