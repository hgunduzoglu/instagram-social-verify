/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { type ZodFor } from '../schemas/index.js';
import { TxHash } from '../tx/tx_hash.js';
import { Note } from './note.js';
/**
 * A note with contextual data.
 */
export declare class ExtendedNote {
    /** The note as emitted from the Noir contract. */
    note: Note;
    /** The address whose public key was used to encrypt the note. */
    recipient: AztecAddress;
    /** The contract address this note is created in. */
    contractAddress: AztecAddress;
    /** The specific storage location of the note on the contract. */
    storageSlot: Fr;
    /** The hash of the tx the note was created in. */
    txHash: TxHash;
    constructor(
    /** The note as emitted from the Noir contract. */
    note: Note, 
    /** The address whose public key was used to encrypt the note. */
    recipient: AztecAddress, 
    /** The contract address this note is created in. */
    contractAddress: AztecAddress, 
    /** The specific storage location of the note on the contract. */
    storageSlot: Fr, 
    /** The hash of the tx the note was created in. */
    txHash: TxHash);
    toBuffer(): Buffer;
    static fromBuffer(buffer: Buffer | BufferReader): ExtendedNote;
    static get schema(): ZodFor<ExtendedNote>;
    toString(): `0x${string}`;
    static fromString(str: string): ExtendedNote;
    static random(): Promise<ExtendedNote>;
}
export declare class UniqueNote extends ExtendedNote {
    /** The nonce of the note. */
    nonce: Fr;
    constructor(
    /** The note as emitted from the Noir contract. */
    note: Note, 
    /** The recipient whose public key was used to encrypt the note. */
    recipient: AztecAddress, 
    /** The contract address this note is created in. */
    contractAddress: AztecAddress, 
    /** The specific storage location of the note on the contract. */
    storageSlot: Fr, 
    /** The hash of the tx the note was created in. */
    txHash: TxHash, 
    /** The nonce of the note. */
    nonce: Fr);
    static get schema(): z.ZodEffects<z.ZodObject<{
        note: z.ZodEffects<z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer, string>, z.ZodEffects<z.ZodObject<{
            type: z.ZodLiteral<"Buffer">;
            data: z.ZodArray<z.ZodNumber, "many">;
        }, "strip", z.ZodTypeAny, {
            type: "Buffer";
            data: number[];
        }, {
            type: "Buffer";
            data: number[];
        }>, Buffer, {
            type: "Buffer";
            data: number[];
        }>]>, Note, string | {
            type: "Buffer";
            data: number[];
        }>;
        recipient: ZodFor<AztecAddress>;
        contractAddress: ZodFor<AztecAddress>;
        storageSlot: ZodFor<Fr>;
        txHash: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, Buffer, string>, TxHash, string>;
        nonce: ZodFor<Fr>;
    }, "strip", z.ZodTypeAny, {
        storageSlot: Fr;
        contractAddress: AztecAddress;
        recipient: AztecAddress;
        note: Note;
        txHash: TxHash;
        nonce: Fr;
    }, {
        note: string | {
            type: "Buffer";
            data: number[];
        };
        txHash: string;
        storageSlot?: any;
        contractAddress?: any;
        recipient?: any;
        nonce?: any;
    }>, UniqueNote, {
        note: string | {
            type: "Buffer";
            data: number[];
        };
        txHash: string;
        storageSlot?: any;
        contractAddress?: any;
        recipient?: any;
        nonce?: any;
    }>;
    toBuffer(): Buffer;
    static random(): Promise<UniqueNote>;
    static fromBuffer(buffer: Buffer | BufferReader): UniqueNote;
    static fromString(str: string): UniqueNote;
}
//# sourceMappingURL=extended_note.d.ts.map