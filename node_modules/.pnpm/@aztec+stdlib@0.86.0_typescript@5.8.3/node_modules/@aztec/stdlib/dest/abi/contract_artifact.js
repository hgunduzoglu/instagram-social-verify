import { jsonParseWithSchema, jsonStringify } from '@aztec/foundation/json-rpc';
import { ContractArtifactSchema, FunctionType } from '../abi/index.js';
import { AZTEC_INITIALIZER_ATTRIBUTE, AZTEC_INTERNAL_ATTRIBUTE, AZTEC_PRIVATE_ATTRIBUTE, AZTEC_PUBLIC_ATTRIBUTE, AZTEC_UTILITY_ATTRIBUTE, AZTEC_VIEW_ATTRIBUTE } from '../noir/index.js';
/**
 * Serializes a contract artifact to a buffer for storage.
 * @param artifact - Artifact to serialize.
 * @returns A buffer.
 */ export function contractArtifactToBuffer(artifact) {
    return Buffer.from(jsonStringify(artifact), 'utf-8');
}
/**
 * Deserializes a contract artifact from storage.
 * @param buffer - Buffer to deserialize.
 * @returns Deserialized artifact.
 */ export function contractArtifactFromBuffer(buffer) {
    return jsonParseWithSchema(buffer.toString('utf-8'), ContractArtifactSchema);
}
/**
 * Gets nargo build output and returns a valid contract artifact instance.
 * Does not include public bytecode, apart from the public_dispatch function.
 * @param input - Input object as generated by nargo compile.
 * @returns A valid contract artifact instance.
 */ export function loadContractArtifact(input) {
    if (isContractArtifact(input)) {
        return input;
    }
    return generateContractArtifact(input);
}
/**
 * Gets nargo build output and returns a valid contract artifact instance.
 * Differs from loadContractArtifact() by retaining all bytecode.
 * @param input - Input object as generated by nargo compile.
 * @returns A valid contract artifact instance.
 */ export function loadContractArtifactForPublic(input) {
    return generateContractArtifactForPublic(input);
}
/**
 * Checks if the given input looks like a valid ContractArtifact. The check is not exhaustive,
 * and it's just meant to differentiate between nargo raw build artifacts and the ones
 * produced by this compiler.
 * @param input - Input object.
 * @returns True if it looks like a ContractArtifact.
 */ function isContractArtifact(input) {
    if (typeof input !== 'object') {
        return false;
    }
    const maybeContractArtifact = input;
    if (typeof maybeContractArtifact.name !== 'string') {
        return false;
    }
    if (!Array.isArray(maybeContractArtifact.functions)) {
        return false;
    }
    for (const fn of maybeContractArtifact.functions){
        if (typeof fn.name !== 'string') {
            return false;
        }
        if (typeof fn.functionType !== 'string') {
            return false;
        }
        if (!retainBytecode(fn) && fn.bytecode.length) {
            // We want to remove the bytecode of public fns (apart from the dispatch fn) to save space
            // If the input is private-only, we don't need to use generateContractArtifact() below
            return false;
        }
    }
    if (!Array.isArray(maybeContractArtifact.nonDispatchPublicFunctions)) {
        return false;
    }
    for (const fn of maybeContractArtifact.nonDispatchPublicFunctions){
        if (typeof fn.name !== 'string') {
            return false;
        }
        if (typeof fn.functionType !== 'string') {
            return false;
        }
    }
    return true;
}
/**
 * Generates a function parameter out of one generated by a nargo build.
 * @param param - Noir parameter.
 * @returns A function parameter.
 */ function generateFunctionParameter(param) {
    const { visibility } = param;
    if (visibility === 'databus') {
        throw new Error(`Unsupported visibility ${param.visibility} for noir contract function parameter ${param.name}.`);
    }
    return {
        ...param,
        visibility: visibility
    };
}
/**
 * Returns true if we should retain bytecode
 */ export function retainBytecode(input) {
    const functionType = input.functionType ?? getFunctionType(input);
    return functionType !== FunctionType.PUBLIC || input.name == 'public_dispatch';
}
/**
 * Generates a function abi.
 * @param fn - Noir function entry.
 * @param contract - Parent contract.
 * @returns Function abi.
 */ function generateFunctionAbi(fn, contract) {
    if (fn.custom_attributes === undefined) {
        throw new Error(`No custom attributes found for contract function ${fn.name}. Try rebuilding the contract with the latest nargo version.`);
    }
    const functionType = getFunctionType(fn);
    const isInternal = fn.custom_attributes.includes(AZTEC_INTERNAL_ATTRIBUTE);
    const isStatic = fn.custom_attributes.includes(AZTEC_VIEW_ATTRIBUTE);
    // If the function is not a utility function, the first item is inputs or CallContext which we should omit
    let parameters = fn.abi.parameters.map(generateFunctionParameter);
    if (hasKernelFunctionInputs(parameters)) {
        parameters = parameters.slice(1);
    }
    let returnTypes = [];
    if (functionType === FunctionType.UTILITY) {
        returnTypes = fn.abi.return_type ? [
            fn.abi.return_type.abi_type
        ] : returnTypes;
    } else {
        const pathToFind = `${contract.name}::${fn.name}_abi`;
        const abiStructs = contract.outputs.structs['functions'];
        const returnStruct = abiStructs.find((a)=>a.kind === 'struct' && a.path === pathToFind);
        if (returnStruct) {
            if (returnStruct.kind !== 'struct') {
                throw new Error('Could not generate contract function artifact');
            }
            const returnTypeField = returnStruct.fields.find((field)=>field.name === 'return_type');
            if (returnTypeField) {
                returnTypes = [
                    returnTypeField.type
                ];
            }
        }
    }
    return {
        name: fn.name,
        functionType,
        isInternal,
        isStatic,
        isInitializer: fn.custom_attributes.includes(AZTEC_INITIALIZER_ATTRIBUTE),
        parameters,
        returnTypes,
        errorTypes: fn.abi.error_types,
        ...fn.assert_messages ? {
            assertMessages: fn.assert_messages
        } : undefined
    };
}
/**
 * Generates a function build artifact.
 * @param fn - Noir function entry.
 * @param contract - Parent contract.
 * @returns Function artifact.
 */ function generateFunctionArtifact(fn, contract) {
    const abi = generateFunctionAbi(fn, contract);
    return {
        ...abi,
        bytecode: fn.bytecode,
        debugSymbols: fn.debug_symbols,
        ...fn.verification_key ? {
            verificationKey: fn.verification_key
        } : undefined
    };
}
function getFunctionType(fn) {
    if (fn.custom_attributes.some((attr)=>attr.endsWith(AZTEC_PRIVATE_ATTRIBUTE))) {
        return FunctionType.PRIVATE;
    } else if (fn.custom_attributes.some((attr)=>attr.endsWith(AZTEC_PUBLIC_ATTRIBUTE))) {
        return FunctionType.PUBLIC;
    } else if (fn.custom_attributes.some((attr)=>attr.endsWith(AZTEC_UTILITY_ATTRIBUTE))) {
        return FunctionType.UTILITY;
    } else {
        throw new Error(`Invalid function type for a noir contract function ${fn.name}`);
    }
}
// TODO(https://github.com/noir-lang/noir/issues/7912): Replace the above function with this one once the linked issue
// is fixed.
// function getFunctionType(fn: NoirCompiledContractFunction): FunctionType {
//   if (fn.custom_attributes.includes(AZTEC_PRIVATE_ATTRIBUTE)) {
//     return FunctionType.PRIVATE;
//   } else if (fn.custom_attributes.includes(AZTEC_PUBLIC_ATTRIBUTE)) {
//     return FunctionType.PUBLIC;
//   } else if (fn.custom_attributes.includes(AZTEC_UTILITY_ATTRIBUTE)) {
//     return FunctionType.UTILITY;
//   } else {
//     throw new Error(`Invalid function type for a noir contract function ${fn.name}`);
//   }
// }
/**
 * Returns true if the first parameter is kernel function inputs.
 *
 * Noir macros #[aztec(private|public)] inject the following code
 * fn <name>(inputs: <Public|Private>ContextInputs, ...otherparams) {}
 *
 * Return true if this injected parameter is found
 */ function hasKernelFunctionInputs(params) {
    const firstParam = params[0];
    return firstParam?.type.kind === 'struct' && firstParam.type.path.includes('ContextInputs');
}
/**
 * Generates a storage layout for the contract artifact.
 * @param input - The compiled noir contract to get storage layout for
 * @returns A storage layout for the contract.
 */ function getStorageLayout(input) {
    // If another contract is imported by the main contract, its storage layout its going to also show up here.
    // The layout export includes the contract name, so here we can find the one that belongs to the current one and
    // ignore the rest.
    const storageExports = input.outputs.globals.storage ? input.outputs.globals.storage : [];
    const storageForContract = storageExports.find((storageExport)=>{
        const contractNameField = storageExport.fields.find((field)=>field.name === 'contract_name')?.value;
        return contractNameField.value === input.name;
    });
    const storageFields = storageForContract ? storageForContract.fields.find((field)=>field.name == 'fields').value.fields : [];
    if (storageFields.length === 0) {
        return {};
    }
    return storageFields.reduce((acc, field)=>{
        const name = field.name;
        const slot = field.value.fields[0].value;
        acc[name] = {
            slot: `0x${slot.value}`
        };
        return acc;
    }, {});
}
/**
 * Generates records of the notes with note type ids of the artifact.
 * @param input - The compiled noir contract to get note types for
 * @return A record of the note types and their ids
 */ function getNoteTypes(input) {
    // The type is useless here as it does not give us any guarantee (e.g. `AbiValue` can be one of many different
    // types) so we nuke it and later we manually check the values are as we expect.
    const notes = input.outputs.globals.notes;
    if (!notes) {
        return {};
    }
    return notes.reduce((acc, note)=>{
        const noteFields = note.fields;
        // We find note type id by looking for respective kinds as each of them is unique
        const rawNoteTypeId = noteFields.find((field)=>field.kind === 'integer');
        const rawName = noteFields.find((field)=>field.kind === 'string');
        const rawNoteFields = noteFields.find((field)=>field.kind === 'struct');
        if (!rawNoteTypeId || !rawName || !rawNoteFields) {
            throw new Error(`Could not find note type id, name or fields for note ${note}`);
        }
        const noteTypeId = rawNoteTypeId.value;
        const name = rawName.value;
        // Note type id is encoded as a hex string
        const fields = rawNoteFields.fields.map((field)=>{
            return {
                name: field.name,
                index: parseInt(field.value.fields[0].value.value, 16),
                nullable: field.value.fields[1].value.value
            };
        });
        acc[name] = {
            id: noteTypeId,
            typ: name,
            fields
        };
        return acc;
    }, {});
}
/**
 * Given a Nargo output generates an Aztec-compatible contract artifact.
 * Does not include public bytecode, apart from the public_dispatch function.
 * @param compiled - Noir build output.
 * @returns Aztec contract build artifact.
 */ function generateContractArtifact(contract) {
    try {
        return ContractArtifactSchema.parse({
            name: contract.name,
            functions: contract.functions.filter((f)=>retainBytecode(f)).map((f)=>generateFunctionArtifact(f, contract)),
            nonDispatchPublicFunctions: contract.functions.filter((f)=>!retainBytecode(f)).map((f)=>generateFunctionAbi(f, contract)),
            outputs: contract.outputs,
            storageLayout: getStorageLayout(contract),
            notes: getNoteTypes(contract),
            fileMap: contract.file_map
        });
    } catch (err) {
        throw new Error(`Could not generate contract artifact for ${contract.name}: ${err}`);
    }
}
/**
 * Given a Nargo output generates an Aztec-compatible contract artifact.
 * Retains all public bytecode.
 * @param compiled - Noir build output.
 * @returns Aztec contract build artifact.
 */ function generateContractArtifactForPublic(contract) {
    try {
        return ContractArtifactSchema.parse({
            name: contract.name,
            functions: contract.functions.map((f)=>generateFunctionArtifact(f, contract)),
            nonDispatchPublicFunctions: contract.functions.filter((f)=>!retainBytecode(f)).map((f)=>generateFunctionAbi(f, contract)),
            outputs: contract.outputs,
            storageLayout: getStorageLayout(contract),
            notes: getNoteTypes(contract),
            fileMap: contract.file_map
        });
    } catch (err) {
        throw new Error(`Could not generate contract artifact for ${contract.name}: ${err}`);
    }
}
