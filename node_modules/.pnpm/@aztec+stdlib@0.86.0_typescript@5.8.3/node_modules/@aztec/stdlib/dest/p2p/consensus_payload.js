import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { hexToBuffer } from '@aztec/foundation/string';
import { encodeAbiParameters, parseAbiParameters } from 'viem';
import { z } from 'zod';
import { BlockHeader } from '../tx/block_header.js';
import { TxHash } from '../tx/tx_hash.js';
export class ConsensusPayload {
    header;
    archive;
    txHashes;
    size;
    constructor(/** The block header the attestation is made over */ header, // TODO(https://github.com/AztecProtocol/aztec-packages/pull/7727#discussion_r1713670830): temporary
    archive, /** The sequence of transactions in the block */ txHashes){
        this.header = header;
        this.archive = archive;
        this.txHashes = txHashes;
    }
    static get schema() {
        return z.object({
            header: BlockHeader.schema,
            archive: schemas.Fr,
            txHashes: z.array(TxHash.schema)
        }).transform((obj)=>new ConsensusPayload(obj.header, obj.archive, obj.txHashes));
    }
    static getFields(fields) {
        return [
            fields.header,
            fields.archive,
            fields.txHashes
        ];
    }
    getPayloadToSign(domainSeparator) {
        const abi = parseAbiParameters('uint8, (bytes32, (uint256), bytes, bytes32[])');
        const txArray = this.txHashes.map((tx)=>tx.toString());
        const encodedData = encodeAbiParameters(abi, [
            domainSeparator,
            [
                this.archive.toString(),
                [
                    0n
                ],
                this.header.toString(),
                txArray
            ]
        ]);
        return hexToBuffer(encodedData);
    }
    toBuffer() {
        const buffer = serializeToBuffer([
            this.header,
            this.archive,
            this.txHashes.length,
            this.txHashes
        ]);
        this.size = buffer.length;
        return buffer;
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        return new ConsensusPayload(reader.readObject(BlockHeader), reader.readObject(Fr), reader.readArray(reader.readNumber(), TxHash));
    }
    static fromFields(fields) {
        return new ConsensusPayload(fields.header, fields.archive, fields.txHashes);
    }
    static fromBlock(block) {
        return new ConsensusPayload(block.header, block.archive.root, block.body.txEffects.map((tx)=>tx.txHash));
    }
    static empty() {
        return new ConsensusPayload(BlockHeader.empty(), Fr.ZERO, []);
    }
    /**
   * Get the size of the consensus payload in bytes.
   * @returns The size of the consensus payload.
   */ getSize() {
        // We cache size to avoid recalculating it
        if (this.size) {
            return this.size;
        }
        this.size = this.toBuffer().length;
        return this.size;
    }
}
