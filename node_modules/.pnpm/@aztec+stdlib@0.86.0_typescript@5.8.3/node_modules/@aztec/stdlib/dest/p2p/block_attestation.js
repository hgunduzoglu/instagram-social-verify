import { Buffer32 } from '@aztec/foundation/buffer';
import { keccak256, recoverAddress } from '@aztec/foundation/crypto';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { SignatureDomainSeparator, getHashedSignaturePayloadEthSignedMessage } from './signature_utils.js';
import { TopicType } from './topic_type.js';
export class BlockAttestationHash extends Buffer32 {
    constructor(hash){
        super(hash);
    }
}
/**
 * BlockAttestation
 *
 * A validator that has attested to seeing the contents of a block
 * will produce a block attestation over the header of the block
 */ export class BlockAttestation extends Gossipable {
    payload;
    signature;
    static p2pTopic = TopicType.block_attestation;
    sender;
    constructor(/** The payload of the message, and what the signature is over */ payload, /** The signature of the block attester */ signature){
        super(), this.payload = payload, this.signature = signature;
    }
    static get schema() {
        return z.object({
            payload: ConsensusPayload.schema,
            signature: Signature.schema
        }).transform((obj)=>new BlockAttestation(obj.payload, obj.signature));
    }
    p2pMessageIdentifier() {
        return Promise.resolve(new BlockAttestationHash(keccak256(this.signature.toBuffer())));
    }
    get archive() {
        return this.payload.archive;
    }
    get slotNumber() {
        return this.payload.header.globalVariables.slotNumber;
    }
    get blockNumber() {
        return this.payload.header.globalVariables.blockNumber;
    }
    /**Get sender
   *
   * Lazily evaluate and cache the sender of the attestation
   * @returns The sender of the attestation
   */ getSender() {
        if (!this.sender) {
            // Recover the sender from the attestation
            const hashed = getHashedSignaturePayloadEthSignedMessage(this.payload, SignatureDomainSeparator.blockAttestation);
            // Cache the sender for later use
            this.sender = recoverAddress(hashed, this.signature);
        }
        return this.sender;
    }
    getPayload() {
        return this.payload.getPayloadToSign(SignatureDomainSeparator.blockAttestation);
    }
    toBuffer() {
        return serializeToBuffer([
            this.payload,
            this.signature
        ]);
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        return new BlockAttestation(reader.readObject(ConsensusPayload), reader.readObject(Signature));
    }
    static empty() {
        return new BlockAttestation(ConsensusPayload.empty(), Signature.empty());
    }
    getSize() {
        return this.payload.getSize() + this.signature.getSize();
    }
}
