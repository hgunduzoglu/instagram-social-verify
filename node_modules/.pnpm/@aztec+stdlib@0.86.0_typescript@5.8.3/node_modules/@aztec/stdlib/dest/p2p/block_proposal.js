import { Buffer32 } from '@aztec/foundation/buffer';
import { keccak256, recoverAddress } from '@aztec/foundation/crypto';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { SignatureDomainSeparator, getHashedSignaturePayload, getHashedSignaturePayloadEthSignedMessage } from './signature_utils.js';
import { TopicType } from './topic_type.js';
export class BlockProposalHash extends Buffer32 {
    constructor(hash){
        super(hash);
    }
}
/**
 * BlockProposal
 *
 * A block proposal is created by the leader of the chain proposing a sequence of transactions to
 * be included in the head of the chain
 */ export class BlockProposal extends Gossipable {
    payload;
    signature;
    static p2pTopic = TopicType.block_proposal;
    sender;
    constructor(/** The payload of the message, and what the signature is over */ payload, /** The signer of the BlockProposal over the header of the new block*/ signature){
        super(), this.payload = payload, this.signature = signature;
    }
    p2pMessageIdentifier() {
        return Promise.resolve(new BlockProposalHash(keccak256(this.signature.toBuffer())));
    }
    get archive() {
        return this.payload.archive;
    }
    get slotNumber() {
        return this.payload.header.globalVariables.slotNumber;
    }
    get blockNumber() {
        return this.payload.header.globalVariables.blockNumber;
    }
    static async createProposalFromSigner(payload, payloadSigner) {
        const hashed = getHashedSignaturePayload(payload, SignatureDomainSeparator.blockProposal);
        const sig = await payloadSigner(hashed);
        return new BlockProposal(payload, sig);
    }
    /**Get Sender
   * Lazily evaluate the sender of the proposal; result is cached
   */ getSender() {
        if (!this.sender) {
            const hashed = getHashedSignaturePayloadEthSignedMessage(this.payload, SignatureDomainSeparator.blockProposal);
            // Cache the sender for later use
            this.sender = recoverAddress(hashed, this.signature);
        }
        return this.sender;
    }
    getPayload() {
        return this.payload.getPayloadToSign(SignatureDomainSeparator.blockProposal);
    }
    toBuffer() {
        return serializeToBuffer([
            this.payload,
            this.signature
        ]);
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        return new BlockProposal(reader.readObject(ConsensusPayload), reader.readObject(Signature));
    }
    getSize() {
        return this.payload.getSize() + this.signature.getSize();
    }
}
