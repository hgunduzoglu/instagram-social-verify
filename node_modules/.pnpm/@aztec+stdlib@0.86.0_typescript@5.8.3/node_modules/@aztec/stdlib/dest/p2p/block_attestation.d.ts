/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Buffer32 } from '@aztec/foundation/buffer';
import type { EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import type { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import type { ZodFor } from '../schemas/index.js';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { TopicType } from './topic_type.js';
export declare class BlockAttestationHash extends Buffer32 {
    constructor(hash: Buffer);
}
/**
 * BlockAttestation
 *
 * A validator that has attested to seeing the contents of a block
 * will produce a block attestation over the header of the block
 */
export declare class BlockAttestation extends Gossipable {
    /** The payload of the message, and what the signature is over */
    readonly payload: ConsensusPayload;
    /** The signature of the block attester */
    readonly signature: Signature;
    static p2pTopic: TopicType;
    private sender;
    constructor(
    /** The payload of the message, and what the signature is over */
    payload: ConsensusPayload, 
    /** The signature of the block attester */
    signature: Signature);
    static get schema(): ZodFor<BlockAttestation>;
    p2pMessageIdentifier(): Promise<Buffer32>;
    get archive(): Fr;
    get slotNumber(): Fr;
    get blockNumber(): Fr;
    /**Get sender
     *
     * Lazily evaluate and cache the sender of the attestation
     * @returns The sender of the attestation
     */
    getSender(): EthAddress;
    getPayload(): Buffer;
    toBuffer(): Buffer;
    static fromBuffer(buf: Buffer | BufferReader): BlockAttestation;
    static empty(): BlockAttestation;
    getSize(): number;
}
//# sourceMappingURL=block_attestation.d.ts.map