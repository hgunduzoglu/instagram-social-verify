import { Fr } from '@aztec/foundation/fields';
import { BufferReader, FieldReader } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
export var RevertCodeEnum = /*#__PURE__*/ function(RevertCodeEnum) {
    RevertCodeEnum[RevertCodeEnum["OK"] = 0] = "OK";
    RevertCodeEnum[RevertCodeEnum["APP_LOGIC_REVERTED"] = 1] = "APP_LOGIC_REVERTED";
    RevertCodeEnum[RevertCodeEnum["TEARDOWN_REVERTED"] = 2] = "TEARDOWN_REVERTED";
    RevertCodeEnum[RevertCodeEnum["BOTH_REVERTED"] = 3] = "BOTH_REVERTED";
    return RevertCodeEnum;
}({});
function isRevertCodeEnum(value) {
    return value === 0 || value === 1 || value === 2 || value === 3;
}
/**
 * Wrapper class over a field to safely represent a revert code.
 */ export class RevertCode {
    code;
    constructor(e){
        this.code = e.valueOf();
    }
    static OK = new RevertCode(0);
    static APP_LOGIC_REVERTED = new RevertCode(1);
    static TEARDOWN_REVERTED = new RevertCode(2);
    static BOTH_REVERTED = new RevertCode(3);
    getCode() {
        return this.code;
    }
    equals(other) {
        return this.code === other.code;
    }
    isOK() {
        return this.equals(RevertCode.OK);
    }
    getDescription() {
        switch(this.code){
            case 0:
                return 'OK';
            case 1:
                return 'Application logic reverted';
            case 2:
                return 'Teardown reverted';
            case 3:
                return 'Both reverted';
            default:
                return `Unknown RevertCode: ${this.code}`;
        }
    }
    toJSON() {
        return this.code;
    }
    static get schema() {
        return z.nativeEnum(RevertCodeEnum).transform((value)=>new RevertCode(value));
    }
    /**
   * Having different serialization methods allows for
   * decoupling the serialization for producing the content commitment hash
   * (where we use fields)
   * from serialization for transmitting the data.
   */ static PREIMAGE_SIZE_IN_BYTES = 32;
    toHashPreimage() {
        const padding = Buffer.alloc(RevertCode.PREIMAGE_SIZE_IN_BYTES - RevertCode.PACKED_SIZE_IN_BYTES);
        return Buffer.concat([
            padding,
            this.toBuffer()
        ]);
    }
    static PACKED_SIZE_IN_BYTES = 1;
    toBuffer() {
        const b = Buffer.alloc(RevertCode.PACKED_SIZE_IN_BYTES);
        b.writeUInt8(this.code, 0);
        return b;
    }
    toField() {
        return new Fr(this.toBuffer());
    }
    getSerializedLength() {
        return this.toBuffer().length;
    }
    static fromField(fr) {
        if (!isRevertCodeEnum(fr.toNumber())) {
            throw new Error(`Invalid RevertCode: ${fr.toNumber()}`);
        }
        return new RevertCode(fr.toNumber());
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return RevertCode.fromField(reader.readField());
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const code = reader.readBytes(RevertCode.PACKED_SIZE_IN_BYTES).readUInt8(0);
        if (!isRevertCodeEnum(code)) {
            throw new Error(`Invalid RevertCode: ${code}`);
        }
        return new RevertCode(code);
    }
    static NUM_OPTIONS = 4;
    static random() {
        return new RevertCode(Math.floor(Math.random() * RevertCode.NUM_OPTIONS));
    }
    [inspect.custom]() {
        return `RevertCode<${this.code.toString()}>`;
    }
}
