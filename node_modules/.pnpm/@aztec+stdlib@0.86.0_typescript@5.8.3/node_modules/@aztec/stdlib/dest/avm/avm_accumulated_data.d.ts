/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PUBLIC_LOGS_PER_TX, MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, FieldReader, type Tuple } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { PublicLog } from '../logs/public_log.js';
import { ScopedL2ToL1Message } from '../messaging/l2_to_l1_message.js';
import { PublicDataWrite } from './public_data_write.js';
export declare class AvmAccumulatedData {
    /**
     * The note hashes from private combining with those made in the AVM execution.
     */
    noteHashes: Tuple<Fr, typeof MAX_NOTE_HASHES_PER_TX>;
    /**
     * The nullifiers from private combining with those made in the AVM execution.
     */
    nullifiers: Tuple<Fr, typeof MAX_NULLIFIERS_PER_TX>;
    /**
     * The L2 to L1 messages from private combining with those made in the AVM execution.
     */
    l2ToL1Msgs: Tuple<ScopedL2ToL1Message, typeof MAX_L2_TO_L1_MSGS_PER_TX>;
    /**
     * The public logs emitted from the AVM execution.
     */
    publicLogs: Tuple<PublicLog, typeof MAX_PUBLIC_LOGS_PER_TX>;
    /**
     * The public data writes made in the AVM execution.
     */
    publicDataWrites: Tuple<PublicDataWrite, typeof MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX>;
    constructor(
    /**
     * The note hashes from private combining with those made in the AVM execution.
     */
    noteHashes: Tuple<Fr, typeof MAX_NOTE_HASHES_PER_TX>, 
    /**
     * The nullifiers from private combining with those made in the AVM execution.
     */
    nullifiers: Tuple<Fr, typeof MAX_NULLIFIERS_PER_TX>, 
    /**
     * The L2 to L1 messages from private combining with those made in the AVM execution.
     */
    l2ToL1Msgs: Tuple<ScopedL2ToL1Message, typeof MAX_L2_TO_L1_MSGS_PER_TX>, 
    /**
     * The public logs emitted from the AVM execution.
     */
    publicLogs: Tuple<PublicLog, typeof MAX_PUBLIC_LOGS_PER_TX>, 
    /**
     * The public data writes made in the AVM execution.
     */
    publicDataWrites: Tuple<PublicDataWrite, typeof MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX>);
    static get schema(): z.ZodEffects<z.ZodObject<{
        noteHashes: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        nullifiers: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        l2ToL1Msgs: z.ZodArray<z.ZodEffects<z.ZodObject<{
            message: z.ZodEffects<z.ZodObject<{
                recipient: z.ZodType<import("@aztec/foundation/schemas").EthAddress, any, string>;
                content: z.ZodType<Fr, any, string>;
                counter: z.ZodNumber;
            }, "strip", z.ZodTypeAny, {
                counter: number;
                recipient: import("@aztec/foundation/schemas").EthAddress;
                content: Fr;
            }, {
                counter: number;
                recipient: string;
                content: string;
            }>, import("../messaging/l2_to_l1_message.js").L2ToL1Message, {
                counter: number;
                recipient: string;
                content: string;
            }>;
            contractAddress: import("@aztec/foundation/schemas").ZodFor<import("../aztec-address/index.js").AztecAddress>;
        }, "strip", z.ZodTypeAny, {
            message: import("../messaging/l2_to_l1_message.js").L2ToL1Message;
            contractAddress: import("../aztec-address/index.js").AztecAddress;
        }, {
            message: {
                counter: number;
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }>, ScopedL2ToL1Message, {
            message: {
                counter: number;
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }>, "many">;
        publicLogs: z.ZodArray<import("@aztec/foundation/schemas").ZodFor<PublicLog>, "many">;
        publicDataWrites: z.ZodArray<z.ZodEffects<z.ZodObject<{
            leafSlot: z.ZodType<Fr, any, string>;
            value: z.ZodType<Fr, any, string>;
        }, "strip", z.ZodTypeAny, {
            value: Fr;
            leafSlot: Fr;
        }, {
            value: string;
            leafSlot: string;
        }>, PublicDataWrite, {
            value: string;
            leafSlot: string;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        noteHashes: Fr[];
        nullifiers: Fr[];
        l2ToL1Msgs: ScopedL2ToL1Message[];
        publicLogs: PublicLog[];
        publicDataWrites: PublicDataWrite[];
    }, {
        noteHashes: string[];
        nullifiers: string[];
        l2ToL1Msgs: {
            message: {
                counter: number;
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }[];
        publicLogs: any[];
        publicDataWrites: {
            value: string;
            leafSlot: string;
        }[];
    }>, AvmAccumulatedData, {
        noteHashes: string[];
        nullifiers: string[];
        l2ToL1Msgs: {
            message: {
                counter: number;
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }[];
        publicLogs: any[];
        publicDataWrites: {
            value: string;
            leafSlot: string;
        }[];
    }>;
    getSize(): number;
    static fromBuffer(buffer: Buffer | BufferReader): AvmAccumulatedData;
    toBuffer(): Buffer;
    static fromFields(fields: Fr[] | FieldReader): AvmAccumulatedData;
    static fromString(str: string): AvmAccumulatedData;
    toString(): `0x${string}`;
    static empty(): AvmAccumulatedData;
    isEmpty(): boolean;
    [inspect.custom](): string;
}
//# sourceMappingURL=avm_accumulated_data.d.ts.map