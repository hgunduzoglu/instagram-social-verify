import { Fq, Fr, Point } from '@aztec/foundation/fields';
import { strict as assert } from 'assert';
import { Encoder, addExtension } from 'msgpackr';
import { AztecAddress } from '../aztec-address/index.js';
export function serializeWithMessagePack(obj) {
    setUpMessagePackExtensions();
    const encoder = new Encoder({
        // always encode JS objects as MessagePack maps
        // this makes it compatible with other MessagePack decoders
        useRecords: false,
        int64AsType: 'bigint'
    });
    return encoder.encode(obj);
}
let messagePackWasSetUp = false;
function setUpMessagePackExtensions() {
    if (messagePackWasSetUp) {
        return;
    }
    // C++ Fr and Fq classes work well with the buffer serialization.
    addExtension({
        Class: Fr,
        write: (fr)=>fr.toBuffer()
    });
    addExtension({
        Class: Fq,
        write: (fq)=>fq.toBuffer()
    });
    // AztecAddress is a class that has a field in TS, but just a field in C++.
    addExtension({
        Class: AztecAddress,
        write: (addr)=>addr.toField()
    });
    // Affine points are a mess, we do our best.
    addExtension({
        Class: Point,
        write: (p)=>{
            assert(!p.inf, 'Cannot serialize infinity');
            // TODO: should these be Frs?
            return {
                x: new Fq(p.x.toBigInt()),
                y: new Fq(p.y.toBigInt())
            };
        }
    });
    messagePackWasSetUp = true;
}
