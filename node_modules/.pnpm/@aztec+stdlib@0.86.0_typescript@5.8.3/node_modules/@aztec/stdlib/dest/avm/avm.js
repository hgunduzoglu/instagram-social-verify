import { jsonParseWithSchema, jsonStringify } from '@aztec/foundation/json-rpc';
import { schemas } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { PublicKeys } from '../keys/public_keys.js';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { MerkleTreeId } from '../trees/merkle_tree_id.js';
import { NullifierLeafPreimage } from '../trees/nullifier_leaf.js';
import { PublicDataTreeLeafPreimage } from '../trees/public_data_leaf.js';
import { GlobalVariables, TreeSnapshots } from '../tx/index.js';
import { AvmCircuitPublicInputs } from './avm_circuit_public_inputs.js';
import { serializeWithMessagePack } from './message_pack.js';
////////////////////////////////////////////////////////////////////////////
// Hints (contracts)
////////////////////////////////////////////////////////////////////////////
export class AvmContractClassHint {
    classId;
    artifactHash;
    privateFunctionsRoot;
    packedBytecode;
    constructor(classId, artifactHash, privateFunctionsRoot, packedBytecode){
        this.classId = classId;
        this.artifactHash = artifactHash;
        this.privateFunctionsRoot = privateFunctionsRoot;
        this.packedBytecode = packedBytecode;
    }
    static get schema() {
        return z.object({
            classId: schemas.Fr,
            artifactHash: schemas.Fr,
            privateFunctionsRoot: schemas.Fr,
            packedBytecode: schemas.Buffer
        }).transform(({ classId, artifactHash, privateFunctionsRoot, packedBytecode })=>new AvmContractClassHint(classId, artifactHash, privateFunctionsRoot, packedBytecode));
    }
}
export class AvmBytecodeCommitmentHint {
    classId;
    commitment;
    constructor(classId, commitment){
        this.classId = classId;
        this.commitment = commitment;
    }
    static get schema() {
        return z.object({
            classId: schemas.Fr,
            commitment: schemas.Fr
        }).transform(({ classId, commitment })=>new AvmBytecodeCommitmentHint(classId, commitment));
    }
}
export class AvmContractInstanceHint {
    address;
    salt;
    deployer;
    currentContractClassId;
    originalContractClassId;
    initializationHash;
    publicKeys;
    constructor(address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys){
        this.address = address;
        this.salt = salt;
        this.deployer = deployer;
        this.currentContractClassId = currentContractClassId;
        this.originalContractClassId = originalContractClassId;
        this.initializationHash = initializationHash;
        this.publicKeys = publicKeys;
    }
    static get schema() {
        return z.object({
            address: AztecAddress.schema,
            salt: schemas.Fr,
            deployer: AztecAddress.schema,
            currentContractClassId: schemas.Fr,
            originalContractClassId: schemas.Fr,
            initializationHash: schemas.Fr,
            publicKeys: PublicKeys.schema
        }).transform(({ address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys })=>new AvmContractInstanceHint(address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys));
    }
}
////////////////////////////////////////////////////////////////////////////
// Hints (merkle db)
////////////////////////////////////////////////////////////////////////////
// Hint for MerkleTreeDB.getSiblingPath.
export class AvmGetSiblingPathHint {
    hintKey;
    treeId;
    index;
    path;
    constructor(hintKey, // params
    treeId, index, // return
    path){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.index = index;
        this.path = path;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            index: schemas.BigInt,
            path: schemas.Fr.array()
        }).transform(({ hintKey, treeId, index, path })=>new AvmGetSiblingPathHint(hintKey, treeId, index, path));
    }
}
// Hint for MerkleTreeDB.getPreviousValueIndex.
export class AvmGetPreviousValueIndexHint {
    hintKey;
    treeId;
    value;
    index;
    alreadyPresent;
    constructor(hintKey, // params
    treeId, value, // return
    index, alreadyPresent){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.value = value;
        this.index = index;
        this.alreadyPresent = alreadyPresent;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            value: schemas.Fr,
            index: schemas.BigInt,
            alreadyPresent: z.boolean()
        }).transform(({ hintKey, treeId, value, index, alreadyPresent })=>new AvmGetPreviousValueIndexHint(hintKey, treeId, value, index, alreadyPresent));
    }
}
// Hint for MerkleTreeDB.getLeafPreimage.
// NOTE: I need this factory because in order to get hold of the schema, I need an actual instance of the class,
// having the type doesn't suffice since TS does type erasure in the end.
function AvmGetLeafPreimageHintFactory(klass) {
    return class AvmGetLeafPreimageHint {
        hintKey;
        index;
        leafPreimage;
        constructor(hintKey, // params (tree id will be implicit)
        index, // return
        leafPreimage){
            this.hintKey = hintKey;
            this.index = index;
            this.leafPreimage = leafPreimage;
        }
        static get schema() {
            return z.object({
                hintKey: AppendOnlyTreeSnapshot.schema,
                index: schemas.BigInt,
                leafPreimage: klass.schema
            }).transform(({ hintKey, index, leafPreimage })=>new AvmGetLeafPreimageHint(hintKey, index, leafPreimage));
        }
    };
}
// Note: only supported for PUBLIC_DATA_TREE and NULLIFIER_TREE.
export class AvmGetLeafPreimageHintPublicDataTree extends AvmGetLeafPreimageHintFactory(PublicDataTreeLeafPreimage) {
}
export class AvmGetLeafPreimageHintNullifierTree extends AvmGetLeafPreimageHintFactory(NullifierLeafPreimage) {
}
// Hint for MerkleTreeDB.getLeafValue.
// Note: only supported for NOTE_HASH_TREE and L1_TO_L2_MESSAGE_TREE.
export class AvmGetLeafValueHint {
    hintKey;
    treeId;
    index;
    value;
    constructor(hintKey, // params
    treeId, index, // return
    value){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.index = index;
        this.value = value;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            index: schemas.BigInt,
            value: schemas.Fr
        }).transform(({ hintKey, treeId, index, value })=>new AvmGetLeafValueHint(hintKey, treeId, index, value));
    }
}
// Hint for MerkleTreeDB.sequentialInsert.
// NOTE: I need this factory because in order to get hold of the schema, I need an actual instance of the class,
// having the type doesn't suffice since TS does type erasure in the end.
function AvmSequentialInsertHintFactory(klass) {
    return class AvmSequentialInsertHint {
        hintKey;
        stateAfter;
        treeId;
        leaf;
        lowLeavesWitnessData;
        insertionWitnessData;
        constructor(hintKey, stateAfter, // params
        treeId, leaf, // return
        lowLeavesWitnessData, insertionWitnessData){
            this.hintKey = hintKey;
            this.stateAfter = stateAfter;
            this.treeId = treeId;
            this.leaf = leaf;
            this.lowLeavesWitnessData = lowLeavesWitnessData;
            this.insertionWitnessData = insertionWitnessData;
        }
        static get schema() {
            return z.object({
                hintKey: AppendOnlyTreeSnapshot.schema,
                stateAfter: AppendOnlyTreeSnapshot.schema,
                treeId: z.number().int().nonnegative(),
                leaf: klass.leafSchema,
                lowLeavesWitnessData: z.object({
                    leaf: klass.schema,
                    index: schemas.BigInt,
                    path: schemas.Fr.array()
                }),
                insertionWitnessData: z.object({
                    leaf: klass.schema,
                    index: schemas.BigInt,
                    path: schemas.Fr.array()
                })
            }).transform(({ hintKey, stateAfter, treeId, leaf, lowLeavesWitnessData, insertionWitnessData })=>new AvmSequentialInsertHint(hintKey, stateAfter, treeId, leaf, lowLeavesWitnessData, insertionWitnessData));
        }
    };
}
// Note: only supported for PUBLIC_DATA_TREE and NULLIFIER_TREE.
export class AvmSequentialInsertHintPublicDataTree extends AvmSequentialInsertHintFactory(PublicDataTreeLeafPreimage) {
}
export class AvmSequentialInsertHintNullifierTree extends AvmSequentialInsertHintFactory(NullifierLeafPreimage) {
}
// Hint for MerkleTreeDB.appendLeaves.
// Note: only supported for NOTE_HASH_TREE and L1_TO_L2_MESSAGE_TREE.
export class AvmAppendLeavesHint {
    hintKey;
    stateAfter;
    treeId;
    leaves;
    constructor(hintKey, stateAfter, // params
    treeId, leaves){
        this.hintKey = hintKey;
        this.stateAfter = stateAfter;
        this.treeId = treeId;
        this.leaves = leaves;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            stateAfter: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            leaves: schemas.Fr.array()
        }).transform(({ hintKey, stateAfter, treeId, leaves })=>new AvmAppendLeavesHint(hintKey, stateAfter, treeId, leaves));
    }
}
// Hint for checkpoint actions that don't change the state.
class AvmCheckpointActionNoStateChangeHint {
    actionCounter;
    oldCheckpointId;
    newCheckpointId;
    constructor(// key
    actionCounter, // current checkpoint evolution
    oldCheckpointId, newCheckpointId){
        this.actionCounter = actionCounter;
        this.oldCheckpointId = oldCheckpointId;
        this.newCheckpointId = newCheckpointId;
    }
    static get schema() {
        return z.object({
            actionCounter: z.number().int().nonnegative(),
            oldCheckpointId: z.number().int().nonnegative(),
            newCheckpointId: z.number().int().nonnegative()
        }).transform(({ actionCounter, oldCheckpointId, newCheckpointId })=>new AvmCheckpointActionNoStateChangeHint(actionCounter, oldCheckpointId, newCheckpointId));
    }
}
// Hint for MerkleTreeDB.createCheckpoint.
export class AvmCreateCheckpointHint extends AvmCheckpointActionNoStateChangeHint {
}
// Hint for MerkleTreeDB.commitCheckpoint.
export class AvmCommitCheckpointHint extends AvmCheckpointActionNoStateChangeHint {
}
// Hint for MerkleTreeDB.revertCheckpoint.
export class AvmRevertCheckpointHint {
    actionCounter;
    oldCheckpointId;
    newCheckpointId;
    stateBefore;
    stateAfter;
    // We use explicit fields for MessagePack.
    constructor(// key
    actionCounter, // current checkpoint evolution
    oldCheckpointId, newCheckpointId, // state evolution
    stateBefore, stateAfter){
        this.actionCounter = actionCounter;
        this.oldCheckpointId = oldCheckpointId;
        this.newCheckpointId = newCheckpointId;
        this.stateBefore = stateBefore;
        this.stateAfter = stateAfter;
    }
    static create(actionCounter, oldCheckpointId, newCheckpointId, stateBefore, stateAfter) {
        return new AvmRevertCheckpointHint(actionCounter, oldCheckpointId, newCheckpointId, new TreeSnapshots(stateBefore[MerkleTreeId.L1_TO_L2_MESSAGE_TREE], stateBefore[MerkleTreeId.NOTE_HASH_TREE], stateBefore[MerkleTreeId.NULLIFIER_TREE], stateBefore[MerkleTreeId.PUBLIC_DATA_TREE]), new TreeSnapshots(stateAfter[MerkleTreeId.L1_TO_L2_MESSAGE_TREE], stateAfter[MerkleTreeId.NOTE_HASH_TREE], stateAfter[MerkleTreeId.NULLIFIER_TREE], stateAfter[MerkleTreeId.PUBLIC_DATA_TREE]));
    }
    static get schema() {
        return z.object({
            actionCounter: z.number().int().nonnegative(),
            oldCheckpointId: z.number().int().nonnegative(),
            newCheckpointId: z.number().int().nonnegative(),
            stateBefore: TreeSnapshots.schema,
            stateAfter: TreeSnapshots.schema
        }).transform(({ actionCounter, oldCheckpointId, newCheckpointId, stateBefore, stateAfter })=>new AvmRevertCheckpointHint(actionCounter, oldCheckpointId, newCheckpointId, stateBefore, stateAfter));
    }
}
////////////////////////////////////////////////////////////////////////////
// Hints (other)
////////////////////////////////////////////////////////////////////////////
export class AvmEnqueuedCallHint {
    msgSender;
    contractAddress;
    calldata;
    isStaticCall;
    constructor(msgSender, contractAddress, calldata, isStaticCall){
        this.msgSender = msgSender;
        this.contractAddress = contractAddress;
        this.calldata = calldata;
        this.isStaticCall = isStaticCall;
    }
    static get schema() {
        return z.object({
            msgSender: AztecAddress.schema,
            contractAddress: AztecAddress.schema,
            calldata: schemas.Fr.array(),
            isStaticCall: z.boolean()
        }).transform(({ msgSender, contractAddress, calldata, isStaticCall })=>new AvmEnqueuedCallHint(msgSender, contractAddress, calldata, isStaticCall));
    }
}
export class AvmTxHint {
    hash;
    globalVariables;
    nonRevertibleAccumulatedData;
    revertibleAccumulatedData;
    setupEnqueuedCalls;
    appLogicEnqueuedCalls;
    teardownEnqueuedCall;
    constructor(hash, globalVariables, nonRevertibleAccumulatedData, revertibleAccumulatedData, setupEnqueuedCalls, appLogicEnqueuedCalls, // We need this to be null and not undefined because that's what
    // MessagePack expects for an std::optional.
    teardownEnqueuedCall){
        this.hash = hash;
        this.globalVariables = globalVariables;
        this.nonRevertibleAccumulatedData = nonRevertibleAccumulatedData;
        this.revertibleAccumulatedData = revertibleAccumulatedData;
        this.setupEnqueuedCalls = setupEnqueuedCalls;
        this.appLogicEnqueuedCalls = appLogicEnqueuedCalls;
        this.teardownEnqueuedCall = teardownEnqueuedCall;
    }
    static async fromTx(tx) {
        const setupCallRequests = tx.getNonRevertiblePublicCallRequestsWithCalldata();
        const appLogicCallRequests = tx.getRevertiblePublicCallRequestsWithCalldata();
        const teardownCallRequest = tx.getTeardownPublicCallRequestWithCalldata();
        // For informational purposes. Assumed quick because it should be cached.
        const txHash = await tx.getTxHash();
        return new AvmTxHint(txHash.hash.toString(), tx.data.constants.historicalHeader.globalVariables, {
            noteHashes: tx.data.forPublic.nonRevertibleAccumulatedData.noteHashes.filter((x)=>!x.isZero()),
            nullifiers: tx.data.forPublic.nonRevertibleAccumulatedData.nullifiers.filter((x)=>!x.isZero())
        }, {
            noteHashes: tx.data.forPublic.revertibleAccumulatedData.noteHashes.filter((x)=>!x.isZero()),
            nullifiers: tx.data.forPublic.revertibleAccumulatedData.nullifiers.filter((x)=>!x.isZero())
        }, setupCallRequests.map((call)=>new AvmEnqueuedCallHint(call.request.msgSender, call.request.contractAddress, call.calldata, call.request.isStaticCall)), appLogicCallRequests.map((call)=>new AvmEnqueuedCallHint(call.request.msgSender, call.request.contractAddress, call.calldata, call.request.isStaticCall)), teardownCallRequest ? new AvmEnqueuedCallHint(teardownCallRequest.request.msgSender, teardownCallRequest.request.contractAddress, teardownCallRequest.calldata, teardownCallRequest.request.isStaticCall) : null);
    }
    static empty() {
        return new AvmTxHint('', GlobalVariables.empty(), {
            noteHashes: [],
            nullifiers: []
        }, {
            noteHashes: [],
            nullifiers: []
        }, [], [], null);
    }
    static get schema() {
        return z.object({
            hash: z.string(),
            globalVariables: GlobalVariables.schema,
            nonRevertibleAccumulatedData: z.object({
                noteHashes: schemas.Fr.array(),
                nullifiers: schemas.Fr.array()
            }),
            revertibleAccumulatedData: z.object({
                noteHashes: schemas.Fr.array(),
                nullifiers: schemas.Fr.array()
            }),
            setupEnqueuedCalls: AvmEnqueuedCallHint.schema.array(),
            appLogicEnqueuedCalls: AvmEnqueuedCallHint.schema.array(),
            teardownEnqueuedCall: AvmEnqueuedCallHint.schema.nullable()
        }).transform(({ hash, globalVariables, nonRevertibleAccumulatedData, revertibleAccumulatedData, setupEnqueuedCalls, appLogicEnqueuedCalls, teardownEnqueuedCall })=>new AvmTxHint(hash, globalVariables, nonRevertibleAccumulatedData, revertibleAccumulatedData, setupEnqueuedCalls, appLogicEnqueuedCalls, teardownEnqueuedCall));
    }
}
export class AvmExecutionHints {
    tx;
    contractInstances;
    contractClasses;
    bytecodeCommitments;
    startingTreeRoots;
    getSiblingPathHints;
    getPreviousValueIndexHints;
    getLeafPreimageHintsPublicDataTree;
    getLeafPreimageHintsNullifierTree;
    getLeafValueHints;
    sequentialInsertHintsPublicDataTree;
    sequentialInsertHintsNullifierTree;
    appendLeavesHints;
    createCheckpointHints;
    commitCheckpointHints;
    revertCheckpointHints;
    constructor(tx, // Contract hints.
    contractInstances = [], contractClasses = [], bytecodeCommitments = [], // Merkle DB hints.
    startingTreeRoots = TreeSnapshots.empty(), getSiblingPathHints = [], getPreviousValueIndexHints = [], getLeafPreimageHintsPublicDataTree = [], getLeafPreimageHintsNullifierTree = [], getLeafValueHints = [], sequentialInsertHintsPublicDataTree = [], sequentialInsertHintsNullifierTree = [], appendLeavesHints = [], createCheckpointHints = [], commitCheckpointHints = [], revertCheckpointHints = []){
        this.tx = tx;
        this.contractInstances = contractInstances;
        this.contractClasses = contractClasses;
        this.bytecodeCommitments = bytecodeCommitments;
        this.startingTreeRoots = startingTreeRoots;
        this.getSiblingPathHints = getSiblingPathHints;
        this.getPreviousValueIndexHints = getPreviousValueIndexHints;
        this.getLeafPreimageHintsPublicDataTree = getLeafPreimageHintsPublicDataTree;
        this.getLeafPreimageHintsNullifierTree = getLeafPreimageHintsNullifierTree;
        this.getLeafValueHints = getLeafValueHints;
        this.sequentialInsertHintsPublicDataTree = sequentialInsertHintsPublicDataTree;
        this.sequentialInsertHintsNullifierTree = sequentialInsertHintsNullifierTree;
        this.appendLeavesHints = appendLeavesHints;
        this.createCheckpointHints = createCheckpointHints;
        this.commitCheckpointHints = commitCheckpointHints;
        this.revertCheckpointHints = revertCheckpointHints;
    }
    static empty() {
        return new AvmExecutionHints(AvmTxHint.empty());
    }
    static get schema() {
        return z.object({
            tx: AvmTxHint.schema,
            contractInstances: AvmContractInstanceHint.schema.array(),
            contractClasses: AvmContractClassHint.schema.array(),
            bytecodeCommitments: AvmBytecodeCommitmentHint.schema.array(),
            startingTreeRoots: TreeSnapshots.schema,
            getSiblingPathHints: AvmGetSiblingPathHint.schema.array(),
            getPreviousValueIndexHints: AvmGetPreviousValueIndexHint.schema.array(),
            getLeafPreimageHintsPublicDataTree: AvmGetLeafPreimageHintPublicDataTree.schema.array(),
            getLeafPreimageHintsNullifierTree: AvmGetLeafPreimageHintNullifierTree.schema.array(),
            getLeafValueHints: AvmGetLeafValueHint.schema.array(),
            sequentialInsertHintsPublicDataTree: AvmSequentialInsertHintPublicDataTree.schema.array(),
            sequentialInsertHintsNullifierTree: AvmSequentialInsertHintNullifierTree.schema.array(),
            appendLeavesHints: AvmAppendLeavesHint.schema.array(),
            createCheckpointHints: AvmCreateCheckpointHint.schema.array(),
            commitCheckpointHints: AvmCommitCheckpointHint.schema.array(),
            revertCheckpointHints: AvmRevertCheckpointHint.schema.array()
        }).transform(({ tx, contractInstances, contractClasses, bytecodeCommitments, startingTreeRoots, getSiblingPathHints, getPreviousValueIndexHints, getLeafPreimageHintsPublicDataTree, getLeafPreimageHintsNullifierTree, getLeafValueHints, sequentialInsertHintsPublicDataTree, sequentialInsertHintsNullifierTree, appendLeavesHints, createCheckpointHints, commitCheckpointHints, revertCheckpointHints })=>new AvmExecutionHints(tx, contractInstances, contractClasses, bytecodeCommitments, startingTreeRoots, getSiblingPathHints, getPreviousValueIndexHints, getLeafPreimageHintsPublicDataTree, getLeafPreimageHintsNullifierTree, getLeafValueHints, sequentialInsertHintsPublicDataTree, sequentialInsertHintsNullifierTree, appendLeavesHints, createCheckpointHints, commitCheckpointHints, revertCheckpointHints));
    }
}
export class AvmCircuitInputs {
    hints;
    publicInputs;
    constructor(hints, publicInputs){
        this.hints = hints;
        this.publicInputs = publicInputs;
    }
    static empty() {
        return new AvmCircuitInputs(AvmExecutionHints.empty(), AvmCircuitPublicInputs.empty());
    }
    static get schema() {
        return z.object({
            hints: AvmExecutionHints.schema,
            publicInputs: AvmCircuitPublicInputs.schema
        }).transform(({ hints, publicInputs })=>new AvmCircuitInputs(hints, publicInputs));
    }
    serializeWithMessagePack() {
        return serializeWithMessagePack(this);
    }
    // These are used by the prover to generate an id, and also gcs_proof_store.ts.
    toBuffer() {
        return Buffer.from(jsonStringify(this));
    }
    static fromBuffer(buf) {
        return jsonParseWithSchema(buf.toString(), this.schema);
    }
}
