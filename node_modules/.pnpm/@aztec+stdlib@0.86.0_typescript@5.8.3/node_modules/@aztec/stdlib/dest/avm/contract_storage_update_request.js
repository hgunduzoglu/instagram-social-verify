import { CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, FieldReader, serializeToBuffer } from '@aztec/foundation/serialize';
/**
 * Contract storage update request for a slot on a specific contract.
 *
 * Note: Similar to `PublicDataUpdateRequest` but it's from the POV of contract storage so we are not working with
 * public data tree leaf index but storage slot index.
 */ export class ContractStorageUpdateRequest {
    storageSlot;
    newValue;
    counter;
    contractAddress;
    constructor(/**
     * Storage slot we are updating.
     */ storageSlot, /**
     * New value of the storage slot.
     */ newValue, /**
     * Side effect counter tracking position of this event in tx execution.
     */ counter, /**
     * Contract address whose storage is being read.
     */ contractAddress){
        this.storageSlot = storageSlot;
        this.newValue = newValue;
        this.counter = counter;
        this.contractAddress = contractAddress;
    }
    toBuffer() {
        return serializeToBuffer(this.storageSlot, this.newValue, this.counter);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new ContractStorageUpdateRequest(Fr.fromBuffer(reader), Fr.fromBuffer(reader), reader.readNumber());
    }
    /**
   * Create ContractStorageUpdateRequest from a fields dictionary.
   * @param fields - The dictionary.
   * @returns A ContractStorageUpdateRequest object.
   */ static from(fields) {
        return new ContractStorageUpdateRequest(...ContractStorageUpdateRequest.getFields(fields));
    }
    /**
   * Serialize into a field array. Low-level utility.
   * @param fields - Object with fields.
   * @returns The array.
   */ static getFields(fields) {
        return [
            fields.storageSlot,
            fields.newValue,
            fields.counter,
            fields.contractAddress
        ];
    }
    static empty() {
        return new ContractStorageUpdateRequest(Fr.ZERO, Fr.ZERO, 0);
    }
    isEmpty() {
        return this.storageSlot.isZero() && this.newValue.isZero();
    }
    toFriendlyJSON() {
        return `Slot=${this.storageSlot.toFriendlyJSON()}: ${this.newValue.toFriendlyJSON()}, sideEffectCounter=${this.counter}`;
    }
    toFields() {
        const fields = [
            this.storageSlot,
            this.newValue,
            new Fr(this.counter)
        ];
        if (fields.length !== CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH) {
            throw new Error(`Invalid number of fields for ContractStorageUpdateRequest. Expected ${CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        const storageSlot = reader.readField();
        const newValue = reader.readField();
        return new ContractStorageUpdateRequest(storageSlot, newValue, reader.readU32());
    }
}
