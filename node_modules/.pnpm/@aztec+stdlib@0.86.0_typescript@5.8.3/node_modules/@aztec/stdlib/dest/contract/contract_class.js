import { vkAsFieldsMegaHonk } from '@aztec/foundation/crypto';
import { FunctionSelector, FunctionType } from '../abi/index.js';
import { hashVK } from '../hash/hash.js';
import { computeArtifactHash } from './artifact_hash.js';
import { computeContractClassIdWithPreimage } from './contract_class_id.js';
const cmpFunctionArtifacts = (a, b)=>a.selector.toField().cmp(b.selector.toField());
/** Creates a ContractClass from a contract compilation artifact. */ export async function getContractClassFromArtifact(artifact) {
    const artifactHash = 'artifactHash' in artifact ? artifact.artifactHash : await computeArtifactHash(artifact);
    const publicFunctions = artifact.functions.filter((f)=>f.functionType === FunctionType.PUBLIC);
    if (publicFunctions.length > 1) {
        throw new Error(`Contract should contain at most one public function artifact. Received ${publicFunctions.length}.`);
    }
    const packedBytecode = publicFunctions[0]?.bytecode ?? Buffer.alloc(0);
    const privateFunctions = artifact.functions.filter((f)=>f.functionType === FunctionType.PRIVATE);
    const privateArtifactFunctions = await Promise.all(privateFunctions.map(getContractClassPrivateFunctionFromArtifact));
    privateArtifactFunctions.sort(cmpFunctionArtifacts);
    const contractClass = {
        version: 1,
        artifactHash,
        packedBytecode,
        privateFunctions: privateArtifactFunctions
    };
    return {
        ...contractClass,
        ...await computeContractClassIdWithPreimage(contractClass)
    };
}
export async function getContractClassPrivateFunctionFromArtifact(f) {
    return {
        selector: await FunctionSelector.fromNameAndParameters(f.name, f.parameters),
        vkHash: await computeVerificationKeyHash(f)
    };
}
/**
 * For a given private function, computes the hash of its vk.
 */ export async function computeVerificationKeyHash(f) {
    if (!f.verificationKey) {
        throw new Error(`Private function ${f.name} must have a verification key`);
    }
    return hashVK(await vkAsFieldsMegaHonk(Buffer.from(f.verificationKey, 'base64')));
}
