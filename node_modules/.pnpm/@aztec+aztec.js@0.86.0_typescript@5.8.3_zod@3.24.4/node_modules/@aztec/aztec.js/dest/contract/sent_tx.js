import { retryUntil } from '@aztec/foundation/retry';
import { TxStatus } from '@aztec/stdlib/tx';
export const DefaultWaitOpts = {
    ignoreDroppedReceiptsFor: 5,
    timeout: 60,
    interval: 1
};
/**
 * The SentTx class represents a sent transaction through the PXE (or directly to a node) providing methods to fetch
 * its hash, receipt, and mining status.
 */ export class SentTx {
    pxeWalletOrNode;
    txHashPromise;
    constructor(pxeWalletOrNode, txHashPromise){
        this.pxeWalletOrNode = pxeWalletOrNode;
        this.txHashPromise = txHashPromise;
    }
    /**
   * Retrieves the transaction hash of the SentTx instance.
   * The function internally awaits for the 'txHashPromise' to resolve, and then returns the resolved transaction hash.
   *
   * @returns A promise that resolves to the transaction hash of the SentTx instance.
   * TODO(#7717): Don't throw here.
   */ getTxHash() {
        return this.txHashPromise;
    }
    /**
   * Retrieve the transaction receipt associated with the current SentTx instance.
   * The function fetches the transaction hash using 'getTxHash' and then queries
   * the PXE to get the corresponding transaction receipt.
   *
   * @returns A promise that resolves to a TxReceipt object representing the fetched transaction receipt.
   */ async getReceipt() {
        const txHash = await this.getTxHash();
        return await this.pxeWalletOrNode.getTxReceipt(txHash);
    }
    /**
   * Awaits for a tx to be mined and returns the receipt. Throws if tx is not mined.
   * @param opts - Options for configuring the waiting for the tx to be mined.
   * @returns The transaction receipt.
   */ async wait(opts) {
        const receipt = await this.waitForReceipt(opts);
        if (receipt.status !== TxStatus.SUCCESS && !opts?.dontThrowOnRevert) {
            throw new Error(`Transaction ${await this.getTxHash()} was ${receipt.status}. Reason: ${receipt.error ?? 'unknown'}`);
        }
        return receipt;
    }
    async waitForReceipt(opts) {
        const txHash = await this.getTxHash();
        const startTime = Date.now();
        const ignoreDroppedReceiptsFor = opts?.ignoreDroppedReceiptsFor ?? DefaultWaitOpts.ignoreDroppedReceiptsFor;
        return await retryUntil(async ()=>{
            const txReceipt = await this.pxeWalletOrNode.getTxReceipt(txHash);
            // If receipt is not yet available, try again
            if (txReceipt.status === TxStatus.PENDING) {
                return undefined;
            }
            // If the tx was "dropped", either return it or ignore based on timing.
            // We can ignore it at first because the transaction may have been sent to node 1, and now we're asking node 2 for the receipt.
            // If we don't allow a short grace period, we could incorrectly return a TxReceipt with status DROPPED.
            if (txReceipt.status === TxStatus.DROPPED) {
                const elapsedSeconds = (Date.now() - startTime) / 1000;
                if (!ignoreDroppedReceiptsFor || elapsedSeconds > ignoreDroppedReceiptsFor) {
                    return txReceipt;
                }
                return undefined;
            }
            return txReceipt;
        }, 'isMined', opts?.timeout ?? DefaultWaitOpts.timeout, opts?.interval ?? DefaultWaitOpts.interval);
    }
}
