import { ExecutionPayload } from '@aztec/entrypoints/payload';
import type { TxExecutionRequest } from '@aztec/stdlib/tx';
import type { Wallet } from '../wallet/wallet.js';
import { BaseContractInteraction } from './base_contract_interaction.js';
import type { RequestMethodOptions, SendMethodOptions, SimulateMethodOptions } from './interaction_options.js';
/** A batch of function calls to be sent as a single transaction through a wallet. */
export declare class BatchCall extends BaseContractInteraction {
    protected calls: BaseContractInteraction[];
    constructor(wallet: Wallet, calls: BaseContractInteraction[]);
    /**
     * Create a transaction execution request that represents this batch, encoded and authenticated by the
     * user's wallet, ready to be simulated.
     * @param options - An optional object containing additional configuration for the transaction.
     * @returns A Promise that resolves to a transaction instance.
     */
    create(options?: SendMethodOptions): Promise<TxExecutionRequest>;
    /**
     * Returns an execution request that represents this operation.
     * @param options - An optional object containing additional configuration for the request generation.
     * @returns An execution payload wrapped in promise.
     */
    request(options?: RequestMethodOptions): Promise<ExecutionPayload>;
    /**
     * Simulate a transaction and get its return values
     * Differs from prove in a few important ways:
     * 1. It returns the values of the function execution
     * 2. It supports `utility`, `private` and `public` functions
     *
     * @param options - An optional object containing additional configuration for the transaction.
     * @returns The result of the transaction as returned by the contract function.
     */
    simulate(options?: SimulateMethodOptions): Promise<any>;
    private getRequests;
}
//# sourceMappingURL=batch_call.d.ts.map