/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import cKzg from 'c-kzg';
import type { Blob as BlobBuffer } from 'c-kzg';
import type { BlobJson } from './interface.js';
export declare const VERSIONED_HASH_VERSION_KZG = 1;
/**
 * A class to create, manage, and prove EVM blobs.
 */
export declare class Blob {
    /** The blob to be broadcast on L1 in bytes form. */
    readonly data: BlobBuffer;
    /** The hash of all tx effects inside the blob. Used in generating the challenge z and proving that we have included all required effects. */
    readonly fieldsHash: Fr;
    /** Challenge point z (= H(H(tx_effects), kzgCommmitment). Used such that p(z) = y. */
    readonly challengeZ: Fr;
    /** Evaluation y = p(z), where p() is the blob polynomial. BLS12 field element, rep. as BigNum in nr, bigint in ts. */
    readonly evaluationY: Buffer;
    /** Commitment to the blob C. Used in compressed BLS12 point format (48 bytes). */
    readonly commitment: Buffer;
    /** KZG opening proof for y = p(z). The commitment to quotient polynomial Q, used in compressed BLS12 point format (48 bytes). */
    readonly proof: Buffer;
    constructor(
    /** The blob to be broadcast on L1 in bytes form. */
    data: BlobBuffer, 
    /** The hash of all tx effects inside the blob. Used in generating the challenge z and proving that we have included all required effects. */
    fieldsHash: Fr, 
    /** Challenge point z (= H(H(tx_effects), kzgCommmitment). Used such that p(z) = y. */
    challengeZ: Fr, 
    /** Evaluation y = p(z), where p() is the blob polynomial. BLS12 field element, rep. as BigNum in nr, bigint in ts. */
    evaluationY: Buffer, 
    /** Commitment to the blob C. Used in compressed BLS12 point format (48 bytes). */
    commitment: Buffer, 
    /** KZG opening proof for y = p(z). The commitment to quotient polynomial Q, used in compressed BLS12 point format (48 bytes). */
    proof: Buffer);
    /**
     * The encoded version of the blob will determine the end of the blob based on the transaction encoding.
     * This is required when the fieldsHash of a blob will contain trailing zeros.
     *
     * See `./encoding.ts` for more details.
     *
     * This method is used to create a Blob from a buffer.
     * @param blob - The buffer to create the Blob from.
     * @param multiBlobFieldsHash - The fields hash to use for the Blob.
     * @returns A Blob created from the buffer.
     *
     * @throws If unable to deserialize the blob.
     */
    static fromEncodedBlobBuffer(blob: BlobBuffer, multiBlobFieldsHash?: Fr): Promise<Blob>;
    /**
     * Create a Blob from an array of fields.
     *
     * @param fields - The array of fields to create the Blob from.
     * @param multiBlobFieldsHash - The fields hash to use for the Blob.
     * @returns A Blob created from the array of fields.
     */
    static fromFields(fields: Fr[], multiBlobFieldsHash?: Fr): Promise<Blob>;
    /**
     * Create a Blob from a JSON object.
     *
     * Blobs will be in this form when requested from the blob sink, or from
     * the beacon chain via `getBlobSidecars`
     * https://ethereum.github.io/beacon-APIs/?urls.primaryName=dev#/Beacon/getBlobSidecars
     *
     * @dev WARNING: by default json deals with encoded buffers
     *
     * @param json - The JSON object to create the Blob from.
     * @returns A Blob created from the JSON object.
     */
    static fromJson(json: BlobJson): Promise<Blob>;
    /**
     * Get the JSON representation of the blob.
     *
     * @dev WARNING: by default json deals with encoded buffers
     * @param index - optional - The index of the blob in the block.
     * @returns The JSON representation of the blob.
     */
    toJson(index: number): BlobJson;
    /**
     * Get the fields from the blob.
     *
     * @dev WARNING: this method does not take into account trailing zeros
     *
     * @returns The fields from the blob.
     */
    toFields(): Fr[];
    /**
     * Get the encoded fields from the blob.
     *
     * @dev This method takes into account trailing zeros
     *
     * @returns The encoded fields from the blob.
     *
     * @throws If unable to deserialize the blob.
     */
    toEncodedFields(): Fr[];
    /**
     * Get the encoded fields from multiple blobs.
     *
     * @dev This method takes into account trailing zeros
     *
     * @returns The encoded fields from the blobs.
     */
    static toEncodedFields(blobs: Blob[]): Fr[];
    /**
     * Get the commitment fields from the blob.
     *
     * The 48-byte commitment is encoded into two field elements:
     * +------------------+------------------+
     * | Field Element 1  | Field Element 2  |
     * | [bytes 0-31]     | [bytes 32-47]   |
     * +------------------+------------------+
     * |     32 bytes     |     16 bytes    |
     * +------------------+------------------+
     * @returns The commitment fields from the blob.
     */
    commitmentToFields(): [Fr, Fr];
    getEthVersionedBlobHash(): Buffer;
    static getEthVersionedBlobHash(commitment: Buffer): Buffer;
    /**
     * Get the buffer representation of the ENTIRE blob.
     *
     * @dev WARNING: this buffer contains all metadata aswell as the data itself
     *
     * @returns The buffer representation of the blob.
     */
    toBuffer(): Buffer;
    /**
     * Create a Blob from a buffer.
     *
     * @dev WARNING: this method contains all metadata aswell as the data itself
     *
     * @param buf - The buffer to create the Blob from.
     * @returns A Blob created from the buffer.
     */
    static fromBuffer(buf: Buffer | BufferReader): Blob;
    /**
     * Get the size of the blob in bytes
     */
    getSize(): number;
    /**
     * Returns a proof of opening of the blob to verify on L1 using the point evaluation precompile:
     *
     * input[:32]     - versioned_hash
     * input[32:64]   - z
     * input[64:96]   - y
     * input[96:144]  - commitment C
     * input[144:192] - proof (a commitment to the quotient polynomial q(X))
     *
     * See https://eips.ethereum.org/EIPS/eip-4844#point-evaluation-precompile
     */
    getEthBlobEvaluationInputs(): `0x${string}`;
    static getEthBlobEvaluationInputs(blobs: Blob[]): `0x${string}`;
    static getViemKzgInstance(): {
        blobToKzgCommitment: typeof cKzg.blobToKzgCommitment;
        computeBlobKzgProof: typeof cKzg.computeBlobKzgProof;
    };
    static getBlobs(fields: Fr[]): Promise<Blob[]>;
}
//# sourceMappingURL=blob.d.ts.map