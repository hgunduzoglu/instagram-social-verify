import { Fr } from '@aztec/foundation/fields';
import type { Blob as BlobBuffer } from 'c-kzg';
export declare const TX_START_PREFIX = 8392562855083340404n;
export declare const TX_START_PREFIX_BYTES_LENGTH: number;
export declare const TX_EFFECT_PREFIX_BYTE_LENGTH: number;
export declare const REVERT_CODE_PREFIX = 1;
/**
 * Deserializes a blob buffer into an array of field elements.
 *
 * Blobs are converted into BN254 fields to perform a poseidon2 hash on them (fieldHash).
 * This method is sparse, meaning it does not include trailing zeros at the end of the blob.
 *
 * However, we cannot simply trim the zero's from the end of the blob, as some logs may include zero's
 * within them.
 * If we end on a set of zeros, such as the log below:
 * length 7: [ a, b, c, d, e, 0, 0]
 *
 * we will end up with the incorrect hash if we trim the zeros from the end.
 *
 * Each transactions logs contains a TX start prefix, which includes a string followed
 * by the length ( in field elements ) of the transaction's log.
 *
 * This function finds the end of the last transaction's logs, and returns the array up to this point.
 *
 * We search for a series of Tx Prefixes progressing the cursor in the field reader until we hit
 * a field that is not a Tx Prefix, this indicates that we have reached the end of the last transaction's logs.
 *
 * +------------------+------------------+------------------+------------------+
 * | TX1 Start Prefix | TX1 Log Fields   | TX2 Start Prefix | Padded zeros     |
 * | [3 a,b,c]        | [3, a, b, c]     | [5 d,e,f,0,0]    | [0, 0, 0, .., 0] |
 * +------------------+------------------+------------------+------------------+
 *                                                          ^
 *                                                          |
 * Function reads until here --------------------------------
 *
 * @param blob - The blob buffer to deserialize.
 * @returns An array of field elements.
 */
export declare function deserializeEncodedBlobToFields(blob: BlobBuffer): Fr[];
/**
 * Get the length of the transaction from the first field.
 *
 * @param firstField - The first field of the transaction.
 * @returns The length of the transaction.
 *
 * @throws If the first field does not include the correct prefix - encoding invalid.
 */
export declare function getLengthFromFirstField(firstField: Fr): number;
/**
 * Determines whether a field is the first field of a tx effect
 */
export declare function isValidFirstField(field: Fr): boolean;
/**
 * Extract the fields from a blob buffer, but do not take into account encoding
 * that will include trailing zeros.
 *
 * +------------------+------------------+------------------+------------------+
 * |                  |                  |                  | Padded zeros     |
 * | [3 a,b,c]        | [3, a, b, c]     | [5 d,e,f,0,0]    | [0, 0, 0, .., 0] |
 * +------------------+------------------+------------------+------------------+
 *                                                ^
 *                                                |
 * Function reads until here ----------------------
 */
export declare function extractBlobFieldsFromBuffer(blob: BlobBuffer): Fr[];
//# sourceMappingURL=encoding.d.ts.map