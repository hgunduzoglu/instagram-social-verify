import { UltraPlonkBackend, UltraHonkBackend } from '@aztec/bb.js';
import { Noir } from '@noir-lang/noir_js';
import fs from 'node:fs';
import path from 'node:path';
import json2toml from 'json2toml';
import { inspect } from 'node:util';
import { z } from 'zod';

// src/prover.ts
var Prover = class {
  plonk;
  honk;
  noir;
  provingBackend;
  /**
   * Creates a new instance of the Prover.
   *
   * @param circuit - The compiled Noir circuit to use for proving
   * @param provingBackend - Configuration for the proving backend
   *
   * @throws {Error} If the circuit bytecode is invalid or malformed
   * @throws {Error} If the proving backend configuration is invalid
   * @throws {Error} If backend initialization fails
   */
  constructor(circuit, provingBackend) {
    const acirBytecode = circuit.bytecode;
    if (provingBackend.type === "plonk" || provingBackend.type === "all") {
      this.plonk = new UltraPlonkBackend(
        acirBytecode,
        provingBackend.options,
        provingBackend.circuitOptions
      );
    }
    if (provingBackend.type === "honk" || provingBackend.type === "all") {
      this.honk = new UltraHonkBackend(
        acirBytecode,
        provingBackend.options,
        provingBackend.circuitOptions
      );
    }
    this.provingBackend = provingBackend;
    this.noir = new Noir(circuit);
  }
  /**
   * Simulates the circuit execution to generate a witness.
   * This method executes the circuit with the given inputs to produce
   * a witness that can be used for proof generation.
   *
   * @param input - The input values for the circuit
   * @returns A promise that resolves to an object containing:
   *          - witness: The generated witness as a Uint8Array
   *          - returnValue: The circuit's return value
   *
   * @throws {Error} If the circuit execution fails
   * @throws {Error} If the input values are invalid or malformed
   * @throws {Error} If witness generation fails
   */
  async simulateWitness(input) {
    return await this.noir.execute(input);
  }
  /**
   * Generates a zero-knowledge proof from a witness.
   *
   * @param witness - The witness generated from circuit execution
   * @param provingBackend - Optional override for the proving backend configuration
   * @returns A promise that resolves to the generated proof
   *
   * @throws {Error} If the witness is invalid or malformed
   * @throws {Error} If the proving backend is not initialized
   * @throws {Error} If proof generation fails
   */
  async prove(witness, provingBackend) {
    const backend = this.getProvingBackend(provingBackend?.type);
    return await backend.generateProof(witness);
  }
  /**
   * Generates a complete zero-knowledge proof from circuit inputs.
   * This is a convenience method that combines witness generation and proof generation.
   *
   * @param input - The input values for the circuit
   * @param provingBackend - Optional override for the proving backend configuration
   * @returns A promise that resolves to the generated proof
   *
   * @throws {Error} If witness generation fails
   * @throws {Error} If proof generation fails
   * @throws {Error} If the input values are invalid
   */
  async fullProve(input, provingBackend) {
    const { witness } = await this.simulateWitness(input);
    return this.prove(witness, provingBackend);
  }
  /**
   * Verifies a zero-knowledge proof.
   *
   * @param proof - The proof to verify
   * @param provingBackend - Optional override for the proving backend configuration
   * @returns A promise that resolves to true if the proof is valid, false otherwise
   *
   * @throws {Error} If the proof is invalid or malformed
   * @throws {Error} If the proving backend is not initialized
   * @throws {Error} If verification fails
   */
  async verify(proof, provingBackend) {
    const backend = this.getProvingBackend(provingBackend?.type);
    return await backend.verifyProof(proof);
  }
  /**
   * Cleans up resources used by the proving backends.
   * This method should be called when the prover is no longer needed
   * to free up system resources. It is recommended to call this method
   * in a finally block or when the prover instance is being disposed.
   *
   * @returns A promise that resolves when cleanup is complete
   *
   * @throws {Error} If resource cleanup fails
   */
  async destroy() {
    if (this.plonk) {
      await this.plonk.destroy();
    }
    if (this.honk) {
      await this.honk.destroy();
    }
  }
  /**
   * Gets the appropriate proving backend based on the specified type.
   * This method handles backend selection and initialization state checking.
   *
   * @param backendType - Optional override for the backend type
   * @returns The initialized proving backend
   *
   * @throws {Error} If the backend type is invalid
   * @throws {Error} If the requested backend is not initialized
   *
   * @private
   */
  getProvingBackend(backendType) {
    let type;
    if (backendType === "plonk" || this.provingBackend.type === "plonk") {
      type = "plonk";
    } else if (backendType === "honk" || this.provingBackend.type === "honk") {
      type = "honk";
    } else {
      throw new Error(
        'Specify a proving backend from either "plonk" or "honk"'
      );
    }
    let backend;
    if (type === "plonk" && this.plonk) {
      backend = this.plonk;
    } else if (type === "honk" && this.honk) {
      backend = this.honk;
    } else {
      throw new Error(`Proving backend ${type} not initialized`);
    }
    return backend;
  }
};
var generateToml = (data, filePath, formatterOpts) => {
  if (!path.isAbsolute(filePath)) {
    throw new Error(
      `The provided file path must be absolute. Received: ${filePath}`
    );
  }
  const tomlContent = json2toml(data, formatterOpts);
  const dir = path.dirname(filePath);
  fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(filePath, tomlContent, "utf-8");
};

// src/data-types/array.ts
var FixedSizeArray = class {
  length;
  items;
  constructor(length, items) {
    if (length !== items.length) {
      throw new Error(
        `Length mismatch: expected ${length}, got ${items.length}`
      );
    }
    this.length = length;
    this.items = [...items];
  }
  len() {
    return this.length;
  }
  toArray() {
    return [...this.items];
  }
  get(index) {
    if (index < 0 || index >= this.length) {
      throw new Error(`Index ${index} out of bounds`);
    }
    return this.items[index];
  }
  at(index) {
    const adjustedIndex = index < 0 ? this.length + index : index;
    return this.get(adjustedIndex);
  }
  set(index, item) {
    if (index < 0 || index >= this.length) {
      throw new Error(`Index ${index} out of bounds`);
    }
    this.items[index] = item;
  }
  forEach(callback) {
    this.items.forEach(callback);
  }
  map(callback) {
    return this.items.map(callback);
  }
  toCircuitInputs() {
    return this.items.map(getInputRepresentation);
  }
};

// src/data-types/bool.ts
var Bool = class _Bool {
  /** The underlying boolean value */
  val;
  /**
   * Creates a new boolean instance with the specified value.
   *
   * @param value - The boolean value to initialize the instance with
   */
  constructor(value) {
    this.val = value;
  }
  /**
   * Returns the underlying boolean value.
   *
   * @returns The boolean value
   */
  value() {
    return this.val;
  }
  /**
   * Compares this boolean with another for equality.
   *
   * @param other - The boolean to compare with
   * @returns true if both booleans have the same value, false otherwise
   */
  eq(other) {
    return this.val === other.val;
  }
  /**
   * Performs a logical NOT operation on this boolean.
   * Returns a new boolean instance with the negated value.
   *
   * @returns A new boolean instance with the opposite value
   */
  not() {
    return new _Bool(!this.val);
  }
  /**
   * Converts the boolean to its Circuit Input representation.
   * Returns the underlying primitive boolean value.
   *
   * @returns The boolean value as a primitive
   */
  toCircuitInputs() {
    return this.val;
  }
};

// src/data-types/bounded-vec.ts
var BoundedVec = class {
  /** Maximum number of elements the vector can hold */
  maxSize;
  /** Current number of elements in the vector */
  length;
  /** Internal storage for vector elements */
  items;
  /**
   * Creates a new bounded vector with the specified maximum size.
   * The vector is initialized with default values up to the maximum size.
   *
   * @param maxSize - The maximum number of elements the vector can hold
   * @param defaultValue - Default value for initialization
   * @param initialItems - Initial items to add to the vector
   * @throws {Error} If maxSize is negative
   */
  constructor(maxSize, defaultValue, initialItems = []) {
    if (maxSize < 0) {
      throw new Error("Max size must be non-negative");
    }
    this.maxSize = maxSize;
    this.items = Array.from({ length: maxSize }, () => defaultValue);
    this.length = 0;
    this.extendFromArray(initialItems);
  }
  /**
   * Returns the current number of elements in the vector.
   *
   * @returns The number of elements currently stored in the vector
   */
  len() {
    return this.length;
  }
  /**
   * Returns the maximum number of elements the vector can hold.
   *
   * @returns The maximum capacity of the vector
   */
  maxLen() {
    return this.maxSize;
  }
  /**
   * Checks if the vector is empty.
   *
   * @returns true if the vector contains no elements, false otherwise
   */
  isEmpty() {
    return this.length === 0;
  }
  /**
   * Checks if the vector has reached its maximum capacity.
   *
   * @returns true if the vector is at maximum capacity, false otherwise
   */
  isFull() {
    return this.length === this.maxSize;
  }
  /**
   * Returns the internal storage for the vector.
   */
  storage() {
    return this.items;
  }
  /**
   * Retrieves the element at the specified index.
   *
   * @param index - The zero-based index of the element to retrieve
   * @returns The element at the specified index
   * @throws {Error} If the index is out of bounds (index < 0 or index >= length)
   */
  get(index) {
    if (index < 0 || index >= this.length) {
      throw new Error("Index out of bounds");
    }
    return this.items[index];
  }
  /**
   * Retrieves the element at the specified index, supporting negative indices.
   * Negative indices count from the end of the vector (-1 is the last element).
   *
   * @param index - The index of the element to retrieve (can be negative)
   * @returns The element at the specified index
   * @throws {Error} If the index is out of bounds after adjustment
   */
  at(index) {
    const adjustedIndex = index < 0 ? this.length + index : index;
    return this.get(adjustedIndex);
  }
  /**
   * Adds an element to the end of the vector.
   *
   * @param item - The element to add to the vector
   * @throws {Error} If the vector is at maximum capacity
   */
  push(item) {
    if (this.isFull()) {
      throw new Error("Vector is full");
    }
    this.items[this.length] = item;
    this.length++;
  }
  /**
   * Sets the element at the specified index to the given value.
   *
   * @param index - The zero-based index where the element should be set
   * @param item - The new value to set at the specified index
   * @throws {Error} If the index is out of bounds (index < 0 or index >= length)
   */
  set(index, item) {
    if (index < 0 || index >= this.length) {
      throw new Error("Index out of bounds");
    }
    this.items[index] = item;
  }
  /**
   * Removes and returns the last element of the vector.
   *
   * @returns The last element of the vector
   * @throws {Error} If the vector is empty
   */
  pop() {
    if (this.isEmpty()) {
      throw new Error("Vector is empty");
    }
    const item = this.items[this.length - 1];
    this.length--;
    return item;
  }
  /**
   * Extends the vector by adding all elements from the given array.
   *
   * @param arr - The array of elements to add to the vector
   * @throws {Error} If adding the elements would exceed the vector's maximum capacity
   */
  extendFromArray(arr) {
    if (this.length + arr.length > this.maxSize) {
      throw new Error("Vector overflow");
    }
    for (const item of arr) {
      this.push(item);
    }
  }
  /**
   * Extends the vector by adding all elements from another bounded vector.
   *
   * @param vec - The bounded vector whose elements should be added
   * @throws {Error} If adding the elements would exceed the vector's maximum capacity
   */
  extendFromVec(vec) {
    this.extendFromArray(vec.toArray());
  }
  /**
   * Returns a copy of the vector's elements as an array.
   * Only includes elements up to the current length.
   *
   * @returns An array containing the vector's elements
   */
  toArray() {
    return this.items.slice(0, this.length);
  }
  /**
   * Converts the BoundedVec to a Circuit Input representation.
   * The JSON object contains both the elements and the current length.
   *
   * @returns Noir Circuit Input representation of the BoundedVec
   */
  toCircuitInputs() {
    return {
      storage: this.storage().map((item) => getInputRepresentation(item)),
      len: this.length
    };
  }
};
var MAX_FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495616n;
var fieldInputSchema = z.union([
  z.number().int("Field input must be an integer"),
  z.bigint(),
  z.string().refine(
    (str) => /^0x[0-9a-fA-F]+$/.test(str) || /^\d+$/.test(str),
    "String must be a decimal or hexadecimal number"
  )
]);
var FieldValidator = fieldInputSchema.transform((val) => {
  if (typeof val === "string") {
    return BigInt(val);
  }
  return BigInt(val);
}).refine(
  (n) => n <= MAX_FIELD_SIZE && n >= -MAX_FIELD_SIZE,
  "Field value must be between -MAX_FIELD_SIZE and MAX_FIELD_SIZE"
);
var IntegerValidator = (min, max) => fieldInputSchema.transform((n) => BigInt(n)).refine((n) => n >= min && n <= max, {
  message: `Value must be in range [${min}, ${max}]`
});

// src/data-types/field.ts
var Field = class _Field {
  /** The internal bigint representation of the field value */
  value;
  /** The maximum bit size of a Field */
  static MAX_BIT_SIZE = 254n;
  /** The modulus of the field */
  static MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
  /**
   * Creates a new Field instance from various input types.
   *
   * @param input - The input value to convert to a field element
   * @throws Error if the input cannot be parsed as a valid field value
   */
  constructor(input) {
    const parsed = FieldValidator.parse(input);
    this.value = parsed % _Field.MODULUS;
  }
  [inspect.custom]() {
    return `Field<${this.value.toString()}>`;
  }
  /**
   * Internal helper function to compute the log2 of a large value (0-2^254).
   *
   * @param value - The value to compute the log2 of
   * @returns The log2 of the value
   */
  log2(value) {
    if (value <= 0n) {
      throw new Error("log2 is undefined for non-positive values");
    }
    let result = 0n;
    let v = value;
    while (v > 1n) {
      v >>= 1n;
      result += 1n;
    }
    return result;
  }
  /**
   * Converts the field value to an array of bits in little-endian order.
   *
   * @param length - The number of bits to extract
   * @returns An array of bits (0 or 1) in little-endian order
   * @throws Error if length is negative or exceeds Field.MAX_BIT_SIZE or if length is less than the minimum required bits to represent the value
   */
  toLeBits(length) {
    const minLengthRequired = this.value === 0n ? 0 : Math.ceil(Number(this.log2(this.value)) + 1);
    if (length < minLengthRequired || length > _Field.MAX_BIT_SIZE) {
      throw new Error(
        `Length must be between ${minLengthRequired} and ${_Field.MAX_BIT_SIZE}`
      );
    }
    const bits = [];
    for (let i = 0; i < length; i++) {
      const bit = this.value >> BigInt(i) & 1n;
      bits.push(Number(bit));
    }
    return bits;
  }
  /**
   * Converts the field value to an array of bits in big-endian order.
   *
   * @param length - The number of bits to extract
   * @returns An array of bits (0 or 1) in big-endian order
   * @throws Error if length is negative or exceeds Field.MAX_BIT_SIZE or if length is less than the minimum required bits to represent the value
   */
  toBeBits(length) {
    const minLengthRequired = this.value === 0n ? 0 : Math.ceil(Number(this.log2(this.value)) + 1);
    if (length < minLengthRequired || length > _Field.MAX_BIT_SIZE) {
      throw new Error(
        `Length must be between ${minLengthRequired} and ${_Field.MAX_BIT_SIZE}`
      );
    }
    const bits = [];
    for (let i = length - 1; i >= 0; i--) {
      const bit = this.value >> BigInt(i) & 1n;
      bits.push(Number(bit));
    }
    return bits;
  }
  /**
   * Converts the field value to an array of bytes in little-endian order.
   *
   * @param length - The number of bytes to extract
   * @returns An array of bytes in little-endian order
   * @throws Error if length is negative or exceeds Field.MAX_BIT_SIZE or if length is less than the minimum required bytes to represent the value
   */
  toLeBytes(length) {
    const minLengthRequired = Math.ceil(this.value.toString(2).length / 8);
    if (length < minLengthRequired || length > _Field.modLeBytes().length) {
      throw new Error(
        `Length must be between ${minLengthRequired} and ${_Field.modLeBytes().length}`
      );
    }
    const bytes = [];
    for (let i = 0; i < length; i++) {
      const byte = Number(this.value >> BigInt(8 * i) & 0xffn);
      bytes.push(byte);
    }
    return bytes;
  }
  /**
   * Converts the field value to an array of bytes in big-endian order.
   *
   * @param length - The number of bytes to extract
   * @returns An array of bytes in big-endian order, sized by the length parameter
   * @throws Error if length is negative, or exceeds maximum bit size or if length is less than the minimum required bytes to represent the value
   */
  toBeBytes(length) {
    const minLengthRequired = Math.ceil(this.value.toString(2).length / 8);
    if (length < minLengthRequired || length > _Field.modBeBytes().length) {
      throw new Error(
        `Length must be between ${minLengthRequired} and ${_Field.modBeBytes().length}`
      );
    }
    const bytes = [];
    for (let i = length - 1; i >= 0; i--) {
      const byte = Number(this.value >> BigInt(8 * i) & 0xffn);
      bytes.push(byte);
    }
    return bytes;
  }
  /**
   * Calculates the minimum length needed to represent a value in a given radix, rounded up to the nearest power of 2.
   *
   * This function is used internally to determine the minimum number of digits required to represent
   * a field value in a given base (radix). The result is always rounded up to the nearest power of 2
   * to ensure consistent sizing for cryptographic operations.
   *
   * @param value - The bigint value to calculate the representation length for
   * @param radix - The base to represent the value in (must be a power of 2)
   * @returns The minimum number of digits needed to represent the value in the given radix, rounded up to the nearest power of 2
   * @throws {Error} If the value is negative
   * @throws {Error} If the radix is not a power of 2
   * @throws {Error} If the radix is less than 2
   */
  minRadixLength(value, radix) {
    if (value < 0n) throw new Error("value must be non-negative");
    if ((radix & radix - 1) !== 0)
      throw new Error("radix must be a power of 2");
    if (radix < 2) throw new Error("radix must be >= 2");
    if (value === 0n) return 1;
    let radixBits = 0;
    let r = radix;
    while ((r >>= 1) > 0) {
      radixBits++;
    }
    let bits = 0;
    let v = value;
    while (v > 0n) {
      v >>= 1n;
      bits++;
    }
    const rawLen = Math.ceil(bits / radixBits);
    let rounded = 1;
    while (rounded < rawLen) {
      rounded <<= 1;
    }
    return rounded;
  }
  /**
   * Converts the field value to an array of digits in little-endian order using the specified radix.
   *
   * @param radix - The base to use for conversion
   * @param length - The number of digits to extract
   * @returns An array of digits in little-endian order
   * @throws Error if radix is invalid or length is negative or if length is less than the minimum required digits to represent the value, or if length is greater than 256
   */
  toLeRadix(radix, length) {
    const minimumRequired = this.minRadixLength(this.value, radix);
    if (length < minimumRequired || length > 256) {
      throw new Error(`Length must be between ${minimumRequired} and 256`);
    }
    const r = BigInt(radix);
    const digits = [];
    let v = this.value;
    for (let i = 0; i < length; i++) {
      digits.push(Number(v % r));
      v /= r;
    }
    while (digits.length < length) digits.push(0);
    return digits;
  }
  /**
   * Converts the field value to an array of digits in big-endian order using the specified radix.
   *
   * @param radix - The base to use for conversion (must be a power of 2 between 2 and 256)
   * @param length - The number of digits to extract
   * @returns An array of digits in big-endian order
   * @throws Error if radix is invalid or length is negative or if length is less than the minimum required digits to represent the value, or if length is greater than 256
   */
  toBeRadix(radix, length) {
    const minimumRequired = this.minRadixLength(this.value, radix);
    if (length < minimumRequired || length > 256) {
      throw new Error(`Length must be between ${minimumRequired} and 256`);
    }
    const r = BigInt(radix);
    const digits = [];
    let v = this.value;
    for (let i = 0; i < length; i++) {
      digits.push(Number(v % r));
      v /= r;
    }
    while (digits.length < length) digits.push(0);
    return digits.reverse();
  }
  /**
   * Raises the field value to the specified power.
   *
   * @param exponent - The power to raise to
   * @returns A new Field instance with the result
   * @throws Error if exponent is negative or greater than equal to 2^32
   */
  pow32(exponent) {
    const exp = exponent.value;
    const MAX_EXP = BigInt(2 ** 32);
    if (exp < 0n)
      throw new Error("Negative exponents are not allowed");
    if (exp >= MAX_EXP)
      throw new Error("Exponent too large: exceeds 2^32 limit");
    let result = 1n;
    let b = this.value % _Field.MODULUS;
    let e = exp;
    while (e > 0n) {
      if (e & 1n) {
        result = result * b % _Field.MODULUS;
      }
      b = b * b % _Field.MODULUS;
      e >>= 1n;
    }
    return new _Field(result);
  }
  /**
   * Asserts that the field value does not exceed the specified bit size.
   *
   * @param bitSize - The maximum allowed bit size
   * @throws Error if the field value exceeds the specified bit size
   */
  assertMaxBitSize(bitSize) {
    if (this.value < 0n) {
      throw new Error("Negative field values are not allowed");
    }
    let bitLength = 0;
    let v = this.value;
    while (v > 0n) {
      v >>= 1n;
      bitLength++;
    }
    if (bitLength > bitSize) {
      throw new Error(`Field value exceeds ${bitSize} bits`);
    }
  }
  /**
   * Returns the sign of the field value (0 or 1).
   * This is used in cryptographic operations to determine the sign of a field element.
   *
   * @returns 0 if the value is even, 1 if odd
   */
  sgn0() {
    return Number(this.value & 1n);
  }
  /**
   * Returns a string representation of the field value.
   *
   * @returns The field value as a decimal string
   */
  toString() {
    return this.value.toString(10);
  }
  /**
   * Converts the field value to a hexadecimal string.
   *
   * @param length - Optional length in bytes to pad the hex string to
   * @returns The field value as a hexadecimal string with '0x' prefix
   */
  toHex() {
    const hex = this.value.toString(16);
    return `0x${hex}`;
  }
  /**
   * Converts the field value to its Circuit Input representation.
   * Returns the field value as a hexadecimal string.
   *
   */
  toCircuitInputs() {
    return this.toHex();
  }
  /**
   * Checks if this field value equals another value.
   *
   * @param other - The value to compare against (can be Field, number, string, or bigint)
   * @returns true if the values are equal
   */
  equals(other) {
    if (other instanceof _Field) {
      return this.value === other.value;
    }
    return this.value === BigInt(other);
  }
  /**
   * Adds another value to this field value.
   *
   * @param input - The value to add (can be Field, number, string, or bigint)
   * @returns A new Field instance with the sum
   */
  add(input) {
    const rhs = input instanceof _Field ? input.value : BigInt(input);
    const sum = this.value + rhs;
    const reduced = sum >= _Field.MODULUS ? sum - _Field.MODULUS : sum;
    return new _Field(reduced);
  }
  /**
   * Subtracts another value from this field value.
   *
   * @param input - The value to subtract (can be Field, number, string, or bigint)
   * @returns A new Field instance with the difference
   */
  sub(input) {
    const otherField = input instanceof _Field ? input : new _Field(input);
    const res = (this.value - otherField.value + _Field.MODULUS) % _Field.MODULUS;
    return new _Field(res);
  }
  /**
   * Multiplies this field value by another value.
   *
   * @param input - The value to multiply by (can be Field, number, string, or bigint)
   * @returns A new Field instance with the product
   */
  mul(input) {
    const otherField = input instanceof _Field ? input : new _Field(input);
    return new _Field(this.value * otherField.value % _Field.MODULUS);
  }
  /**
   * Computes the modular inverse of a field element.
   *
   * @param a - The field element to compute the inverse of
   * @param mod - The modulus to use for the computation
   *
   * @returns The modular inverse of the field element
   */
  modInv(a, mod) {
    let t = 0n;
    let newT = 1n;
    let r = mod;
    let newR = a;
    while (newR !== 0n) {
      const quotient = r / newR;
      [t, newT] = [newT, t - quotient * newT];
      [r, newR] = [newR, r - quotient * newR];
    }
    if (r > 1n) throw new Error("Input is not invertible");
    if (t < 0n) t += mod;
    return t;
  }
  /**
   * Divides this field value by another value.
   *
   * @param input - The value to divide by (can be Field, number, string, or bigint)
   * @returns A new Field instance with the quotient
   * @throws Error if dividing by zero
   */
  div(input) {
    const otherField = input instanceof _Field ? input : new _Field(input);
    if (otherField.value === 0n) {
      throw new Error("Division by zero");
    }
    const inv = this.modInv(otherField.value, _Field.MODULUS);
    const result = this.value * inv % _Field.MODULUS;
    return new _Field(result);
  }
  /**
   * Computes the remainder of division of this field value by another value.
   *
   * @param input - The value to divide by (can be Field, number, string, or bigint)
   * @returns A new Field instance with the remainder
   * @throws Error if dividing by zero
   */
  mod(input) {
    const rhs = input instanceof _Field ? input.value : new _Field(input).value;
    if (rhs === 0n) {
      throw new Error("Cannot modulo by zero");
    }
    const result = (this.value % rhs + rhs) % rhs;
    return new _Field(result);
  }
  /**
   * Creates a copy of this field value.
   *
   * @returns A new Field instance with the same value
   */
  clone() {
    return new _Field(this.value);
  }
  static modBeBits() {
    return [
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      1,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ];
  }
  static modBeBytes() {
    return [
      48,
      100,
      78,
      114,
      225,
      49,
      160,
      41,
      184,
      80,
      69,
      182,
      129,
      129,
      88,
      93,
      40,
      51,
      232,
      72,
      121,
      185,
      112,
      145,
      67,
      225,
      245,
      147,
      240,
      0,
      0,
      1
    ];
  }
  static modLeBits() {
    return [
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1
    ];
  }
  static modLeBytes() {
    return [
      1,
      0,
      0,
      240,
      147,
      245,
      225,
      67,
      145,
      112,
      185,
      121,
      72,
      232,
      51,
      40,
      93,
      88,
      129,
      129,
      182,
      69,
      80,
      184,
      41,
      160,
      49,
      225,
      114,
      78,
      100,
      48
    ];
  }
  static modNumBits() {
    return _Field.MAX_BIT_SIZE;
  }
};

// src/data-types/integer.ts
var AbstractInteger = class extends Field {
  /** Maximum value that can be represented by this integer type */
  static MAX_VALUE;
  /** Minimum value that can be represented by this integer type */
  static MIN_VALUE;
  /**
   * Gets the minimum value that can be represented by this integer type.
   * @returns The minimum value as a bigint
   */
  min() {
    return this.constructor.MIN_VALUE;
  }
  /**
   * Gets the maximum value that can be represented by this integer type.
   * @returns The maximum value as a bigint
   */
  max() {
    return this.constructor.MAX_VALUE;
  }
  /**
   * Creates a new instance of the concrete integer type.
   * @param value - The value to initialize the new instance with
   * @returns A new instance of the concrete integer type
   */
  newInstance(value) {
    const ConcreteClass = Object.getPrototypeOf(this).constructor;
    if (value instanceof Field) {
      return new ConcreteClass(value.value);
    }
    return new ConcreteClass(value);
  }
  /**
   * Constructs a new integer instance with the given value.
   * Validates that the input value is within the allowed range.
   * @param input - The value to initialize this integer with
   * @throws {ZodError} If the input value is outside the allowed range
   */
  constructor(input) {
    super(input);
    const min = this.constructor.MIN_VALUE;
    const max = this.constructor.MAX_VALUE;
    IntegerValidator(min, max).parse(input);
  }
  /**
   * Adds another integer to this one with overflow checking.
   * @param other - The integer to add
   * @returns A new integer representing the sum
   * @throws {Error} If the result would overflow
   */
  add(other) {
    return this.newInstance(super.add(other));
  }
  /**
   * Subtracts another integer from this one with overflow checking.
   * @param other - The integer to subtract
   * @returns A new integer representing the difference
   * @throws {Error} If the result would overflow
   */
  sub(other) {
    return this.newInstance(super.sub(other));
  }
  /**
   * Multiplies this integer by another with overflow checking.
   * @param other - The integer to multiply by
   * @returns A new integer representing the product
   * @throws {Error} If the result would overflow
   */
  mul(other) {
    return this.newInstance(super.mul(other));
  }
  /**
   * Divides this integer by another with overflow checking.
   * @param other - The integer to divide by
   * @returns A new integer representing the quotient
   * @throws {Error} If the result would overflow or if dividing by zero
   */
  div(other) {
    return this.newInstance(super.div(other));
  }
  /**
   * Computes the remainder of dividing this integer by another.
   * @param other - The integer to divide by
   * @returns A new integer representing the remainder
   * @throws {Error} If dividing by zero
   */
  mod(other) {
    return super.mod(other);
  }
  /**
   * Performs wrapping addition of two integers.
   * If the result would overflow, it wraps around to the minimum value.
   * @param other - The integer to add
   * @returns A new integer representing the wrapped sum
   */
  wrappingAdd(other) {
    const min = this.min();
    const max = this.max();
    const range = max - min + 1n;
    const a = this.value - min;
    const b = other.value - min;
    const mask = range - 1n;
    const sum = a + b & mask;
    return this.newInstance(sum + min);
  }
  /**
   * Performs wrapping subtraction of two integers.
   * If the result would underflow, it wraps around to the maximum value.
   * @param other - The integer to subtract
   * @returns A new integer representing the wrapped difference
   */
  wrappingSub(other) {
    const min = this.min();
    const max = this.max();
    const range = max - min + 1n;
    const a = this.value - min;
    const b = other.value - min;
    const mask = range - 1n;
    const diff = a - b & mask;
    return this.newInstance(diff + min);
  }
  /**
   * Performs wrapping multiplication of two integers.
   * If the result would overflow, it wraps around to the minimum value.
   * @param other - The integer to multiply by
   * @returns A new integer representing the wrapped product
   */
  wrappingMul(other) {
    const min = this.min();
    const max = this.max();
    const range = max - min + 1n;
    const a = this.value - min;
    const b = other.value - min;
    const mask = range - 1n;
    const prod = a * b & mask;
    return this.newInstance(prod + min);
  }
};
var U1 = class extends AbstractInteger {
  static MAX_VALUE = 1n;
  static MIN_VALUE = 0n;
};
var U8 = class extends AbstractInteger {
  static MAX_VALUE = 255n;
  static MIN_VALUE = 0n;
};
var U16 = class extends AbstractInteger {
  static MAX_VALUE = 65535n;
  static MIN_VALUE = 0n;
};
var U32 = class extends AbstractInteger {
  static MAX_VALUE = 4294967295n;
  static MIN_VALUE = 0n;
};
var U64 = class extends AbstractInteger {
  static MAX_VALUE = 18446744073709551615n;
  static MIN_VALUE = 0n;
};
var I1 = class extends AbstractInteger {
  static MAX_VALUE = 0n;
  static MIN_VALUE = -0n;
};
var I8 = class extends AbstractInteger {
  static MAX_VALUE = 127n;
  static MIN_VALUE = -128n;
};
var I16 = class extends AbstractInteger {
  static MAX_VALUE = 32767n;
  static MIN_VALUE = -32768n;
};
var I32 = class extends AbstractInteger {
  static MAX_VALUE = 2147483647n;
  static MIN_VALUE = -2147483648n;
};
var I64 = class extends AbstractInteger {
  static MAX_VALUE = 9223372036854775807n;
  static MIN_VALUE = -9223372036854775808n;
};

// src/data-types/string.ts
var Str = class {
  /** The underlying string value */
  val;
  /**
   * Creates a new string instance with the specified value.
   *
   * @param value - The string value to initialize the instance with
   */
  constructor(value) {
    this.val = value;
  }
  /**
   * Returns the underlying string value.
   *
   * @returns The string value
   */
  value() {
    return this.val;
  }
  /**
   * Returns the length of the string.
   *
   * @returns The number of characters in the string
   */
  len() {
    return this.val.length;
  }
  /**
   * Converts the string to an array of UTF-8 encoded bytes.
   * Each byte is represented as a U8 integer value.
   *
   * @returns An array of U8 integers representing the UTF-8 encoded bytes
   */
  asBytes() {
    const encoder = new TextEncoder();
    const encoded = encoder.encode(this.val);
    const res = [];
    for (const ele of encoded) {
      res.push(new U8(ele));
    }
    return res;
  }
  /**
   * Compares this string with another for equality.
   *
   * @param other - The string to compare with
   * @returns true if both strings have the same value, false otherwise
   */
  eq(other) {
    return this.val === other.val;
  }
  /**
   * Converts the string to its Circuit Input representation.
   * Returns the underlying primitive string value.
   */
  toCircuitInputs() {
    return this.val;
  }
};

// src/data-types/index.ts
var getInputRepresentation = (value) => {
  if (value instanceof AbstractInteger) {
    return value.toString();
  }
  if (value instanceof Bool) {
    return value.toCircuitInputs();
  }
  if (value instanceof Str) {
    return value.toCircuitInputs();
  }
  if (value instanceof Field) {
    return value.toCircuitInputs();
  }
  if (value instanceof BoundedVec) {
    return value.toCircuitInputs();
  }
  if (value instanceof FixedSizeArray) {
    return value.toCircuitInputs();
  }
  if (typeof value === "object" && value !== null) {
    const result = {};
    for (const [key, val] of Object.entries(value)) {
      result[key] = getInputRepresentation(val);
    }
    return result;
  }
  throw new Error(
    `Invalid value type: ${value === null ? "null" : typeof value}`
  );
};
function toCircuitInputs(value) {
  return getInputRepresentation(value);
}

export { AbstractInteger, Bool, BoundedVec, Field, FieldValidator, FixedSizeArray, I1, I16, I32, I64, I8, IntegerValidator, Prover, Str, U1, U16, U32, U64, U8, generateToml, getInputRepresentation, toCircuitInputs };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm92ZXIudHMiLCIuLi9zcmMvZ2VuZXJhdGUtdG9tbC50cyIsIi4uL3NyYy9kYXRhLXR5cGVzL2FycmF5LnRzIiwiLi4vc3JjL2RhdGEtdHlwZXMvYm9vbC50cyIsIi4uL3NyYy9kYXRhLXR5cGVzL2JvdW5kZWQtdmVjLnRzIiwiLi4vc3JjL2RhdGEtdHlwZXMvem9kL2luZGV4LnRzIiwiLi4vc3JjL2RhdGEtdHlwZXMvZmllbGQudHMiLCIuLi9zcmMvZGF0YS10eXBlcy9pbnRlZ2VyLnRzIiwiLi4vc3JjL2RhdGEtdHlwZXMvc3RyaW5nLnRzIiwiLi4vc3JjL2RhdGEtdHlwZXMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBb0NPLElBQU0sU0FBTixNQUFhO0FBQUEsRUFDbEIsS0FBQTtBQUFBLEVBQ0EsSUFBQTtBQUFBLEVBQ0EsSUFBQTtBQUFBLEVBQ0EsY0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFZQSxXQUFBLENBQVksU0FBMEIsY0FBZ0MsRUFBQTtBQUNwRSxJQUFBLE1BQU0sZUFBZSxPQUFRLENBQUEsUUFBQTtBQUM3QixJQUFBLElBQUksY0FBZSxDQUFBLElBQUEsS0FBUyxPQUFXLElBQUEsY0FBQSxDQUFlLFNBQVMsS0FBTyxFQUFBO0FBQ3BFLE1BQUEsSUFBQSxDQUFLLFFBQVEsSUFBSSxpQkFBQTtBQUFBLFFBQ2YsWUFBQTtBQUFBLFFBQ0EsY0FBZSxDQUFBLE9BQUE7QUFBQSxRQUNmLGNBQWUsQ0FBQTtBQUFBLE9BQ2pCO0FBQUE7QUFFRixJQUFBLElBQUksY0FBZSxDQUFBLElBQUEsS0FBUyxNQUFVLElBQUEsY0FBQSxDQUFlLFNBQVMsS0FBTyxFQUFBO0FBQ25FLE1BQUEsSUFBQSxDQUFLLE9BQU8sSUFBSSxnQkFBQTtBQUFBLFFBQ2QsWUFBQTtBQUFBLFFBQ0EsY0FBZSxDQUFBLE9BQUE7QUFBQSxRQUNmLGNBQWUsQ0FB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LENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUN4RSxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFDeEUsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQ3hFLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUN4RSxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFDeEUsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQ3hFLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUN4RSxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFDeEUsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQ3hFLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUN4RSxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRztBQUFBLEtBQ1g7QUFBQTtBQUNGLEVBRUEsT0FBTyxVQUF1QixHQUFBO0FBQzVCLElBQU8sT0FBQTtBQUFBLE1BQ0wsRUFBQTtBQUFBLE1BQUksR0FBQTtBQUFBLE1BQUssRUFBQTtBQUFBLE1BQUksR0FBQTtBQUFBLE1BQUssR0FBQTtBQUFBLE1BQUssRUFBQTtBQUFBLE1BQUksR0FBQTtBQUFBLE1BQUssRUFBQTtBQUFBLE1BQUksR0FBQTtBQUFBLE1BQUssRUFBQTtBQUFBLE1BQUksRUFBQTtBQUFBLE1BQUksR0FBQTtBQUFBLE1BQUssR0FBQTtBQUFBLE1BQUssR0FBQTtBQUFBLE1BQUssRUFBQTtBQUFBLE1BQUksRUFBQTtBQUFBLE1BQ3BFLEVBQUE7QUFBQSxNQUFJLEVBQUE7QUFBQSxNQUFJLEdBQUE7QUFBQSxNQUFLLEVBQUE7QUFBQSxNQUFJLEdBQUE7QUFBQSxNQUFLLEdBQUE7QUFBQSxNQUFLLEdBQUE7QUFBQSxNQUFLLEdBQUE7QUFBQSxNQUFLLEVBQUE7QUFBQSxNQUFJLEdBQUE7QUFBQSxNQUFLLEdBQUE7QUFBQSxNQUFLLEdBQUE7QUFBQSxNQUFLLEdBQUE7QUFBQSxNQUFLLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHO0FBQUEsS0FDckU7QUFBQTtBQUNGLEVBRUEsT0FBTyxTQUFtQixHQUFBO0FBQ3hCLElBQU8sT0FBQTtBQUFBLE1BQ0wsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQ3hFLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUN4RSxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFDeEUsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQ3hFLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUN4RSxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFDeEUsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQ3hFLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUFHLENBQUE7QUFBQSxNQUN4RSxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFBRyxDQUFBO0FBQUEsTUFDeEUsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQUcsQ0FBQTtBQUFBLE1BQ3hFLENBQUE7QUFB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QUFLLEVBQUE7QUFDeEIsSUFBQSxPQUFPLE1BQU0sZUFBZ0IsRUFBQTtBQUFBO0FBRS9CLEVBQUEsSUFBSSxpQkFBaUIsS0FBTyxFQUFBO0FBQzFCLElBQUEsT0FBTyxNQUFNLGVBQWdCLEVBQUE7QUFBQTtBQUUvQixFQUFBLElBQUksaUJBQWlCLFVBQVksRUFBQTtBQUMvQixJQUFBLE9BQU8sTUFBTSxlQUFnQixFQUFBO0FBQUE7QUFHL0IsRUFBQSxJQUFJLGlCQUFpQixjQUFnQixFQUFBO0FBQ25DLElBQUEsT0FBTyxNQUFNLGVBQWdCLEVBQUE7QUFBQTtBQUcvQixFQUFBLElBQUksT0FBTyxLQUFBLEtBQVUsUUFBWSxJQUFBLEtBQUEsS0FBVSxJQUFNLEVBQUE7QUFDL0MsSUFBQSxNQUFNLFNBQXFCLEVBQUM7QUFDNUIsSUFBQSxLQUFBLE1BQVcsQ0FBQyxHQUFLLEVBQUEsR0FBRyxLQUFLLE1BQU8sQ0FBQSxPQUFBLENBQVEsS0FBSyxDQUFHLEVBQUE7QUFDOUMsTUFBTyxNQUFBLENBQUEsR0FBRyxDQUFJLEdBQUEsc0JBQUEsQ0FBdUIsR0FBRyxDQUFBO0FBQUE7QUFFMUMsSUFBTyxPQUFBLE1BQUE7QUFBQTtBQUdULEVBQUEsTUFBTSxJQUFJLEtBQUE7QUFBQSxJQUNSLENBQXVCLG9CQUFBLEVBQUEsS0FBQSxLQUFVLElBQU8sR0FBQSxNQUFBLEdBQVMsT0FBTyxLQUFLLENBQUE7QUFBQSxHQUMvRDtBQUNGO0FBRU8sU0FBUyxnQkFBZ0IsS0FBNEIsRUFBQTtBQUMxRCxFQUFBLE9BQU8sdUJBQXVCLEtBQUssQ0FBQTtBQUNyQyIsImZpbGUiOiJpbmRleC5tanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICB0eXBlIFByb29mRGF0YSxcbiAgVWx0cmFIb25rQmFja2VuZCxcbiAgVWx0cmFQbG9ua0JhY2tlbmQsXG59IGZyb20gJ0BhenRlYy9iYi5qcyc7XG5pbXBvcnQgeyB0eXBlIENvbXBpbGVkQ2lyY3VpdCwgdHlwZSBJbnB1dE1hcCwgTm9pciB9IGZyb20gJ0Bub2lyLWxhbmcvbm9pcl9qcyc7XG5pbXBvcnQgdHlwZSB7IElucHV0VmFsdWUsIFByb3ZpbmdCYWNrZW5kIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQSBoaWdoLXBlcmZvcm1hbmNlIHplcm8ta25vd2xlZGdlIHByb3ZlciBzdXBwb3J0aW5nIG11bHRpcGxlIHByb3Zpbmcgc3lzdGVtcy5cbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZ2VuZXJhdGluZyBhbmQgdmVyaWZ5aW5nXG4gKiB6ZXJvLWtub3dsZWRnZSBwcm9vZnMgdXNpbmcgZWl0aGVyIFBMT05LIG9yIEhPTksgcHJvdmluZyBzeXN0ZW1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBJbml0aWFsaXplIHRoZSBwcm92ZXIgd2l0aCBhIGNvbXBpbGVkIGNpcmN1aXRcbiAqIGNvbnN0IGNpcmN1aXQgPSBhd2FpdCBOb2lyLmNvbXBpbGUoY2lyY3VpdFNvdXJjZSk7XG4gKiBjb25zdCBwcm92ZXIgPSBuZXcgUHJvdmVyKGNpcmN1aXQsIHtcbiAqICAgdHlwZTogJ3Bsb25rJyxcbiAqICAgY2lyY3VpdE9wdGlvbnM6IHsgcmVjdXJzaXZlOiB0cnVlIH1cbiAqIH0pO1xuICpcbiAqIHRyeSB7XG4gKiAgIC8vIEdlbmVyYXRlIGEgcHJvb2ZcbiAqICAgY29uc3QgcHJvb2YgPSBhd2FpdCBwcm92ZXIuZnVsbFByb3ZlKGlucHV0cyk7XG4gKlxuICogICAvLyBWZXJpZnkgdGhlIHByb29mXG4gKiAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBwcm92ZXIudmVyaWZ5KHByb29mKTtcbiAqXG4gKiAgIGNvbnNvbGUubG9nKCdQcm9vZiB2ZXJpZmljYXRpb246JywgaXNWYWxpZCk7XG4gKiB9IGZpbmFsbHkge1xuICogICAvLyBDbGVhbiB1cCByZXNvdXJjZXNcbiAqICAgYXdhaXQgcHJvdmVyLmRlc3Ryb3koKTtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUHJvdmVyIHtcbiAgcGxvbms/OiBVbHRyYVBsb25rQmFja2VuZDtcbiAgaG9uaz86IFVsdHJhSG9ua0JhY2tlbmQ7XG4gIG5vaXI6IE5vaXI7XG4gIHByb3ZpbmdCYWNrZW5kOiBQcm92aW5nQmFja2VuZDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUHJvdmVyLlxuICAgKlxuICAgKiBAcGFyYW0gY2lyY3VpdCAtIFRoZSBjb21waWxlZCBOb2lyIGNpcmN1aXQgdG8gdXNlIGZvciBwcm92aW5nXG4gICAqIEBwYXJhbSBwcm92aW5nQmFja2VuZCAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBwcm92aW5nIGJhY2tlbmRcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjaXJjdWl0IGJ5dGVjb2RlIGlzIGludmFsaWQgb3IgbWFsZm9ybWVkXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJvdmluZyBiYWNrZW5kIGNvbmZpZ3VyYXRpb24gaXMgaW52YWxpZFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYmFja2VuZCBpbml0aWFsaXphdGlvbiBmYWlsc1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2lyY3VpdDogQ29tcGlsZWRDaXJjdWl0LCBwcm92aW5nQmFja2VuZDogUHJvdmluZ0JhY2tlbmQpIHtcbiAgICBjb25zdCBhY2lyQnl0ZWNvZGUgPSBjaXJjdWl0LmJ5dGVjb2RlO1xuICAgIGlmIChwcm92aW5nQmFja2VuZC50eXBlID09PSAncGxvbmsnIHx8IHByb3ZpbmdCYWNrZW5kLnR5cGUgPT09ICdhbGwnKSB7XG4gICAgICB0aGlzLnBsb25rID0gbmV3IFVsdHJhUGxvbmtCYWNrZW5kKFxuICAgICAgICBhY2lyQnl0ZWNvZGUsXG4gICAgICAgIHByb3ZpbmdCYWNrZW5kLm9wdGlvbnMsXG4gICAgICAgIHByb3ZpbmdCYWNrZW5kLmNpcmN1aXRPcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocHJvdmluZ0JhY2tlbmQudHlwZSA9PT0gJ2hvbmsnIHx8IHByb3ZpbmdCYWNrZW5kLnR5cGUgPT09ICdhbGwnKSB7XG4gICAgICB0aGlzLmhvbmsgPSBuZXcgVWx0cmFIb25rQmFja2VuZChcbiAgICAgICAgYWNpckJ5dGVjb2RlLFxuICAgICAgICBwcm92aW5nQmFja2VuZC5vcHRpb25zLFxuICAgICAgICBwcm92aW5nQmFja2VuZC5jaXJjdWl0T3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5wcm92aW5nQmFja2VuZCA9IHByb3ZpbmdCYWNrZW5kO1xuICAgIHRoaXMubm9pciA9IG5ldyBOb2lyKGNpcmN1aXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyB0aGUgY2lyY3VpdCBleGVjdXRpb24gdG8gZ2VuZXJhdGUgYSB3aXRuZXNzLlxuICAgKiBUaGlzIG1ldGhvZCBleGVjdXRlcyB0aGUgY2lyY3VpdCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgdG8gcHJvZHVjZVxuICAgKiBhIHdpdG5lc3MgdGhhdCBjYW4gYmUgdXNlZCBmb3IgcHJvb2YgZ2VuZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHZhbHVlcyBmb3IgdGhlIGNpcmN1aXRcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqICAgICAgICAgIC0gd2l0bmVzczogVGhlIGdlbmVyYXRlZCB3aXRuZXNzIGFzIGEgVWludDhBcnJheVxuICAgKiAgICAgICAgICAtIHJldHVyblZhbHVlOiBUaGUgY2lyY3VpdCdzIHJldHVybiB2YWx1ZVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNpcmN1aXQgZXhlY3V0aW9uIGZhaWxzXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBpbnZhbGlkIG9yIG1hbGZvcm1lZFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgd2l0bmVzcyBnZW5lcmF0aW9uIGZhaWxzXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVdpdG5lc3MoXG4gICAgaW5wdXQ6IElucHV0TWFwXG4gICk6IFByb21pc2U8eyB3aXRuZXNzOiBVaW50OEFycmF5OyByZXR1cm5WYWx1ZTogSW5wdXRWYWx1ZSB9PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubm9pci5leGVjdXRlKGlucHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB6ZXJvLWtub3dsZWRnZSBwcm9vZiBmcm9tIGEgd2l0bmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHdpdG5lc3MgLSBUaGUgd2l0bmVzcyBnZW5lcmF0ZWQgZnJvbSBjaXJjdWl0IGV4ZWN1dGlvblxuICAgKiBAcGFyYW0gcHJvdmluZ0JhY2tlbmQgLSBPcHRpb25hbCBvdmVycmlkZSBmb3IgdGhlIHByb3ZpbmcgYmFja2VuZCBjb25maWd1cmF0aW9uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBnZW5lcmF0ZWQgcHJvb2ZcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB3aXRuZXNzIGlzIGludmFsaWQgb3IgbWFsZm9ybWVkXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJvdmluZyBiYWNrZW5kIGlzIG5vdCBpbml0aWFsaXplZFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcHJvb2YgZ2VuZXJhdGlvbiBmYWlsc1xuICAgKi9cbiAgYXN5bmMgcHJvdmUoXG4gICAgd2l0bmVzczogVWludDhBcnJheSxcbiAgICBwcm92aW5nQmFja2VuZD86IFByb3ZpbmdCYWNrZW5kXG4gICk6IFByb21pc2U8UHJvb2ZEYXRhPiB7XG4gICAgY29uc3QgYmFja2VuZCA9IHRoaXMuZ2V0UHJvdmluZ0JhY2tlbmQocHJvdmluZ0JhY2tlbmQ/LnR5cGUpO1xuICAgIHJldHVybiBhd2FpdCBiYWNrZW5kLmdlbmVyYXRlUHJvb2Yod2l0bmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgY29tcGxldGUgemVyby1rbm93bGVkZ2UgcHJvb2YgZnJvbSBjaXJjdWl0IGlucHV0cy5cbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNvbWJpbmVzIHdpdG5lc3MgZ2VuZXJhdGlvbiBhbmQgcHJvb2YgZ2VuZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIGlucHV0IHZhbHVlcyBmb3IgdGhlIGNpcmN1aXRcbiAgICogQHBhcmFtIHByb3ZpbmdCYWNrZW5kIC0gT3B0aW9uYWwgb3ZlcnJpZGUgZm9yIHRoZSBwcm92aW5nIGJhY2tlbmQgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZ2VuZXJhdGVkIHByb29mXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB3aXRuZXNzIGdlbmVyYXRpb24gZmFpbHNcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHByb29mIGdlbmVyYXRpb24gZmFpbHNcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIGludmFsaWRcbiAgICovXG4gIGFzeW5jIGZ1bGxQcm92ZShcbiAgICBpbnB1dDogSW5wdXRNYXAsXG4gICAgcHJvdmluZ0JhY2tlbmQ/OiBQcm92aW5nQmFja2VuZFxuICApOiBQcm9taXNlPFByb29mRGF0YT4ge1xuICAgIGNvbnN0IHsgd2l0bmVzcyB9ID0gYXdhaXQgdGhpcy5zaW11bGF0ZVdpdG5lc3MoaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLnByb3ZlKHdpdG5lc3MsIHByb3ZpbmdCYWNrZW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIHplcm8ta25vd2xlZGdlIHByb29mLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvb2YgLSBUaGUgcHJvb2YgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSBwcm92aW5nQmFja2VuZCAtIE9wdGlvbmFsIG92ZXJyaWRlIGZvciB0aGUgcHJvdmluZyBiYWNrZW5kIGNvbmZpZ3VyYXRpb25cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgcHJvb2YgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByb29mIGlzIGludmFsaWQgb3IgbWFsZm9ybWVkXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJvdmluZyBiYWNrZW5kIGlzIG5vdCBpbml0aWFsaXplZFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdmVyaWZpY2F0aW9uIGZhaWxzXG4gICAqL1xuICBhc3luYyB2ZXJpZnkoXG4gICAgcHJvb2Y6IFByb29mRGF0YSxcbiAgICBwcm92aW5nQmFja2VuZD86IFByb3ZpbmdCYWNrZW5kXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGJhY2tlbmQgPSB0aGlzLmdldFByb3ZpbmdCYWNrZW5kKHByb3ZpbmdCYWNrZW5kPy50eXBlKTtcbiAgICByZXR1cm4gYXdhaXQgYmFja2VuZC52ZXJpZnlQcm9vZihwcm9vZik7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBwcm92aW5nIGJhY2tlbmRzLlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIHByb3ZlciBpcyBubyBsb25nZXIgbmVlZGVkXG4gICAqIHRvIGZyZWUgdXAgc3lzdGVtIHJlc291cmNlcy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gY2FsbCB0aGlzIG1ldGhvZFxuICAgKiBpbiBhIGZpbmFsbHkgYmxvY2sgb3Igd2hlbiB0aGUgcHJvdmVyIGluc3RhbmNlIGlzIGJlaW5nIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGNsZWFudXAgaXMgY29tcGxldGVcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHJlc291cmNlIGNsZWFudXAgZmFpbHNcbiAgICovXG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGxvbmspIHtcbiAgICAgIGF3YWl0IHRoaXMucGxvbmsuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ob25rKSB7XG4gICAgICBhd2FpdCB0aGlzLmhvbmsuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBwcm92aW5nIGJhY2tlbmQgYmFzZWQgb24gdGhlIHNwZWNpZmllZCB0eXBlLlxuICAgKiBUaGlzIG1ldGhvZCBoYW5kbGVzIGJhY2tlbmQgc2VsZWN0aW9uIGFuZCBpbml0aWFsaXphdGlvbiBzdGF0ZSBjaGVja2luZy5cbiAgICpcbiAgICogQHBhcmFtIGJhY2tlbmRUeXBlIC0gT3B0aW9uYWwgb3ZlcnJpZGUgZm9yIHRoZSBiYWNrZW5kIHR5cGVcbiAgICogQHJldHVybnMgVGhlIGluaXRpYWxpemVkIHByb3ZpbmcgYmFja2VuZFxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJhY2tlbmQgdHlwZSBpcyBpbnZhbGlkXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcmVxdWVzdGVkIGJhY2tlbmQgaXMgbm90IGluaXRpYWxpemVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGdldFByb3ZpbmdCYWNrZW5kKGJhY2tlbmRUeXBlPzogUHJvdmluZ0JhY2tlbmRbJ3R5cGUnXSkge1xuICAgIGxldCB0eXBlOiAncGxvbmsnIHwgJ2hvbmsnO1xuICAgIGlmIChiYWNrZW5kVHlwZSA9PT0gJ3Bsb25rJyB8fCB0aGlzLnByb3ZpbmdCYWNrZW5kLnR5cGUgPT09ICdwbG9uaycpIHtcbiAgICAgIHR5cGUgPSAncGxvbmsnO1xuICAgIH0gZWxzZSBpZiAoYmFja2VuZFR5cGUgPT09ICdob25rJyB8fCB0aGlzLnByb3ZpbmdCYWNrZW5kLnR5cGUgPT09ICdob25rJykge1xuICAgICAgdHlwZSA9ICdob25rJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnU3BlY2lmeSBhIHByb3ZpbmcgYmFja2VuZCBmcm9tIGVpdGhlciBcInBsb25rXCIgb3IgXCJob25rXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBiYWNrZW5kOiBVbHRyYVBsb25rQmFja2VuZCB8IFVsdHJhSG9ua0JhY2tlbmQ7XG4gICAgaWYgKHR5cGUgPT09ICdwbG9uaycgJiYgdGhpcy5wbG9uaykge1xuICAgICAgYmFja2VuZCA9IHRoaXMucGxvbms7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaG9uaycgJiYgdGhpcy5ob25rKSB7XG4gICAgICBiYWNrZW5kID0gdGhpcy5ob25rO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpbmcgYmFja2VuZCAke3R5cGV9IG5vdCBpbml0aWFsaXplZGApO1xuICAgIH1cblxuICAgIHJldHVybiBiYWNrZW5kO1xuICB9XG59XG4iLCJpbXBvcnQgZnMgZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IGpzb24ydG9tbCwgeyB0eXBlIE9wdGlvbnMgfSBmcm9tICdqc29uMnRvbWwnO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIFRPTUwgZmlsZSBmcm9tIGEgSlNPTiBvYmplY3QuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgSlNPTiBvYmplY3QgdG8gY29udmVydCB0byBUT01MLlxuICogQHBhcmFtIGZpbGVQYXRoIC0gVGhlIGFic29sdXRlIHBhdGggdG8gdGhlIFRPTUwgZmlsZS5cbiAqIEBwYXJhbSBmb3JtYXR0ZXJPcHRzIHtAbGluayBPcHRpb25zfSAtIE9wdGlvbmFsIGZvcm1hdHRlciBvcHRpb25zLlxuICpcbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgZmlsZVBhdGggaXMgbm90IGFic29sdXRlLFxuICogICAgICAgICBvciBpZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIGZpbGUgc3lzdGVtIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVRvbWwgPSAoXG4gIGRhdGE6IG9iamVjdCxcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgZm9ybWF0dGVyT3B0cz86IE9wdGlvbnNcbik6IHZvaWQgPT4ge1xuICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgcGF0aCBpcyBhYnNvbHV0ZS5cbiAgaWYgKCFwYXRoLmlzQWJzb2x1dGUoZmlsZVBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBwcm92aWRlZCBmaWxlIHBhdGggbXVzdCBiZSBhYnNvbHV0ZS4gUmVjZWl2ZWQ6ICR7ZmlsZVBhdGh9YFxuICAgICk7XG4gIH1cblxuICBjb25zdCB0b21sQ29udGVudCA9IGpzb24ydG9tbChkYXRhLCBmb3JtYXR0ZXJPcHRzKTtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgZnMubWtkaXJTeW5jKGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIHRvbWxDb250ZW50LCAndXRmLTgnKTtcbn07XG4iLCJpbXBvcnQgdHlwZSB7IElucHV0VmFsdWUgfSBmcm9tICd+L3R5cGVzJztcbmltcG9ydCB7IHR5cGUgRGF0YVR5cGUsIGdldElucHV0UmVwcmVzZW50YXRpb24gfSBmcm9tICcuJztcblxuZXhwb3J0IGNsYXNzIEZpeGVkU2l6ZUFycmF5PFQgZXh0ZW5kcyBEYXRhVHlwZSwgTiBleHRlbmRzIG51bWJlcj4ge1xuICBwcml2YXRlIHJlYWRvbmx5IGxlbmd0aDogbnVtYmVyO1xuICBwcml2YXRlIGl0ZW1zOiBUW107XG5cbiAgY29uc3RydWN0b3IobGVuZ3RoOiBOLCBpdGVtczogVFtdKSB7XG4gICAgaWYgKGxlbmd0aCAhPT0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBMZW5ndGggbWlzbWF0Y2g6IGV4cGVjdGVkICR7bGVuZ3RofSwgZ290ICR7aXRlbXMubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaXRlbXMgPSBbLi4uaXRlbXNdO1xuICB9XG5cbiAgbGVuKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgdG9BcnJheSgpOiBUW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5pdGVtc107XG4gIH1cblxuICBnZXQoaW5kZXg6IG51bWJlcik6IFQge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gb3V0IG9mIGJvdW5kc2ApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpbmRleF07XG4gIH1cblxuICBhdChpbmRleDogbnVtYmVyKTogVCB7XG4gICAgY29uc3QgYWRqdXN0ZWRJbmRleCA9IGluZGV4IDwgMCA/IHRoaXMubGVuZ3RoICsgaW5kZXggOiBpbmRleDtcbiAgICByZXR1cm4gdGhpcy5nZXQoYWRqdXN0ZWRJbmRleCk7XG4gIH1cblxuICBzZXQoaW5kZXg6IG51bWJlciwgaXRlbTogVCk6IHZvaWQge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5kZXggJHtpbmRleH0gb3V0IG9mIGJvdW5kc2ApO1xuICAgIH1cbiAgICB0aGlzLml0ZW1zW2luZGV4XSA9IGl0ZW07XG4gIH1cblxuICBmb3JFYWNoKGNhbGxiYWNrOiAoaXRlbTogVCwgaW5kZXg6IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuaXRlbXMuZm9yRWFjaChjYWxsYmFjayk7XG4gIH1cblxuICBtYXA8VT4oY2FsbGJhY2s6IChpdGVtOiBULCBpbmRleDogbnVtYmVyKSA9PiBVKTogVVtdIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoY2FsbGJhY2spO1xuICB9XG5cbiAgdG9DaXJjdWl0SW5wdXRzKCk6IElucHV0VmFsdWVbXSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKGdldElucHV0UmVwcmVzZW50YXRpb24pO1xuICB9XG59XG4iLCIvKipcbiAqIEEgYm9vbGVhbiB2YWx1ZSB0eXBlIHRoYXQgcHJvdmlkZXMgdHlwZS1zYWZlIGJvb2xlYW4gb3BlcmF0aW9ucyBhbmQgc2VyaWFsaXphdGlvbi5cbiAqIFRoaXMgY2xhc3Mgd3JhcHMgYSBwcmltaXRpdmUgYm9vbGVhbiB2YWx1ZSBhbmQgcHJvdmlkZXMgbWV0aG9kcyBmb3IgYm9vbGVhbiBhbGdlYnJhXG4gKiBhbmQgY29tcGFyaXNvbiBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgQm9vbCB7XG4gIC8qKiBUaGUgdW5kZXJseWluZyBib29sZWFuIHZhbHVlICovXG4gIHByaXZhdGUgcmVhZG9ubHkgdmFsOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGJvb2xlYW4gaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYm9vbGVhbiB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSBpbnN0YW5jZSB3aXRoXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMudmFsID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBib29sZWFuIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYm9vbGVhbiB2YWx1ZVxuICAgKi9cbiAgdmFsdWUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoaXMgYm9vbGVhbiB3aXRoIGFub3RoZXIgZm9yIGVxdWFsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYm9vbGVhbiB0byBjb21wYXJlIHdpdGhcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBib3RoIGJvb2xlYW5zIGhhdmUgdGhlIHNhbWUgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgZXEob3RoZXI6IEJvb2wpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52YWwgPT09IG90aGVyLnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGxvZ2ljYWwgTk9UIG9wZXJhdGlvbiBvbiB0aGlzIGJvb2xlYW4uXG4gICAqIFJldHVybnMgYSBuZXcgYm9vbGVhbiBpbnN0YW5jZSB3aXRoIHRoZSBuZWdhdGVkIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIG5ldyBib29sZWFuIGluc3RhbmNlIHdpdGggdGhlIG9wcG9zaXRlIHZhbHVlXG4gICAqL1xuICBub3QoKTogQm9vbCB7XG4gICAgcmV0dXJuIG5ldyBCb29sKCF0aGlzLnZhbCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGJvb2xlYW4gdG8gaXRzIENpcmN1aXQgSW5wdXQgcmVwcmVzZW50YXRpb24uXG4gICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgcHJpbWl0aXZlIGJvb2xlYW4gdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBib29sZWFuIHZhbHVlIGFzIGEgcHJpbWl0aXZlXG4gICAqL1xuICB0b0NpcmN1aXRJbnB1dHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmFsO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IElucHV0VmFsdWUgfSBmcm9tICd+L3R5cGVzJztcbmltcG9ydCB7IHR5cGUgRGF0YVR5cGUsIGdldElucHV0UmVwcmVzZW50YXRpb24gfSBmcm9tICcuJztcblxuLyoqXG4gKiBBIGJvdW5kZWQgdmVjdG9yIGltcGxlbWVudGF0aW9uIHRoYXQgbWFpbnRhaW5zIGEgZml4ZWQgbWF4aW11bSBjYXBhY2l0eVxuICogd2hpbGUgYWxsb3dpbmcgZHluYW1pYyBncm93dGggdXAgdG8gdGhhdCBjYXBhY2l0eS4gVGhpcyBjbGFzcyBwcm92aWRlc1xuICogYSB0eXBlLXNhZmUsIHJlc2l6YWJsZSBhcnJheS1saWtlIHN0cnVjdHVyZSB3aXRoIGEgc3RyaWN0IHVwcGVyIGJvdW5kXG4gKiBvbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGl0IGNhbiBjb250YWluLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgZWxlbWVudHMgc3RvcmVkIGluIHRoZSB2ZWN0b3IsIG11c3QgZXh0ZW5kIERhdGFUeXBlXG4gKiBAdGVtcGxhdGUgTiAtIFRoZSB0eXBlIG9mIHRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHZlY3RvciwgbXVzdCBleHRlbmQgbnVtYmVyXG4gKi9cbmV4cG9ydCBjbGFzcyBCb3VuZGVkVmVjPFQgZXh0ZW5kcyBEYXRhVHlwZSwgTiBleHRlbmRzIG51bWJlcj4ge1xuICAvKiogTWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgdGhlIHZlY3RvciBjYW4gaG9sZCAqL1xuICBwcml2YXRlIHJlYWRvbmx5IG1heFNpemU6IG51bWJlcjtcbiAgLyoqIEN1cnJlbnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3IgKi9cbiAgcHJpdmF0ZSBsZW5ndGg6IG51bWJlcjtcbiAgLyoqIEludGVybmFsIHN0b3JhZ2UgZm9yIHZlY3RvciBlbGVtZW50cyAqL1xuICBwcml2YXRlIGl0ZW1zOiBUW107XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYm91bmRlZCB2ZWN0b3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1heGltdW0gc2l6ZS5cbiAgICogVGhlIHZlY3RvciBpcyBpbml0aWFsaXplZCB3aXRoIGRlZmF1bHQgdmFsdWVzIHVwIHRvIHRoZSBtYXhpbXVtIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSBtYXhTaXplIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIHRoZSB2ZWN0b3IgY2FuIGhvbGRcbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIERlZmF1bHQgdmFsdWUgZm9yIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSBpbml0aWFsSXRlbXMgLSBJbml0aWFsIGl0ZW1zIHRvIGFkZCB0byB0aGUgdmVjdG9yXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBtYXhTaXplIGlzIG5lZ2F0aXZlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXhTaXplOiBOLCBkZWZhdWx0VmFsdWU6IFQsIGluaXRpYWxJdGVtczogVFtdID0gW10pIHtcbiAgICBpZiAobWF4U2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF4IHNpemUgbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICB0aGlzLml0ZW1zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbWF4U2l6ZSB9LCAoKSA9PiBkZWZhdWx0VmFsdWUpO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmV4dGVuZEZyb21BcnJheShpbml0aWFsSXRlbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB2ZWN0b3IuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY3VycmVudGx5IHN0b3JlZCBpbiB0aGUgdmVjdG9yXG4gICAqL1xuICBsZW4oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgdGhlIHZlY3RvciBjYW4gaG9sZC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG1heGltdW0gY2FwYWNpdHkgb2YgdGhlIHZlY3RvclxuICAgKi9cbiAgbWF4TGVuKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubWF4U2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZlY3RvciBpcyBlbXB0eS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmVjdG9yIGNvbnRhaW5zIG5vIGVsZW1lbnRzLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHByaXZhdGUgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2ZWN0b3IgaGFzIHJlYWNoZWQgaXRzIG1heGltdW0gY2FwYWNpdHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZlY3RvciBpcyBhdCBtYXhpbXVtIGNhcGFjaXR5LCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHByaXZhdGUgaXNGdWxsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gdGhpcy5tYXhTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGludGVybmFsIHN0b3JhZ2UgZm9yIHRoZSB2ZWN0b3IuXG4gICAqL1xuICBzdG9yYWdlKCk6IFRbXSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIChpbmRleCA8IDAgb3IgaW5kZXggPj0gbGVuZ3RoKVxuICAgKi9cbiAgZ2V0KGluZGV4OiBudW1iZXIpOiBUIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBzdXBwb3J0aW5nIG5lZ2F0aXZlIGluZGljZXMuXG4gICAqIE5lZ2F0aXZlIGluZGljZXMgY291bnQgZnJvbSB0aGUgZW5kIG9mIHRoZSB2ZWN0b3IgKC0xIGlzIHRoZSBsYXN0IGVsZW1lbnQpLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0cmlldmUgKGNhbiBiZSBuZWdhdGl2ZSlcbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMgYWZ0ZXIgYWRqdXN0bWVudFxuICAgKi9cbiAgYXQoaW5kZXg6IG51bWJlcik6IFQge1xuICAgIGNvbnN0IGFkanVzdGVkSW5kZXggPSBpbmRleCA8IDAgPyB0aGlzLmxlbmd0aCArIGluZGV4IDogaW5kZXg7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGFkanVzdGVkSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSB2ZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB2ZWN0b3JcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2ZWN0b3IgaXMgYXQgbWF4aW11bSBjYXBhY2l0eVxuICAgKi9cbiAgcHVzaChpdGVtOiBUKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNGdWxsKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVjdG9yIGlzIGZ1bGwnKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtc1t0aGlzLmxlbmd0aF0gPSBpdGVtO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIHplcm8tYmFzZWQgaW5kZXggd2hlcmUgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHNldFxuICAgKiBAcGFyYW0gaXRlbSAtIFRoZSBuZXcgdmFsdWUgdG8gc2V0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIChpbmRleCA8IDAgb3IgaW5kZXggPj0gbGVuZ3RoKVxuICAgKi9cbiAgc2V0KGluZGV4OiBudW1iZXIsIGl0ZW06IFQpOiB2b2lkIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtc1tpbmRleF0gPSBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgdmVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSB2ZWN0b3JcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2ZWN0b3IgaXMgZW1wdHlcbiAgICovXG4gIHBvcCgpOiBUIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVjdG9yIGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmRzIHRoZSB2ZWN0b3IgYnkgYWRkaW5nIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBnaXZlbiBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGFyciAtIFRoZSBhcnJheSBvZiBlbGVtZW50cyB0byBhZGQgdG8gdGhlIHZlY3RvclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYWRkaW5nIHRoZSBlbGVtZW50cyB3b3VsZCBleGNlZWQgdGhlIHZlY3RvcidzIG1heGltdW0gY2FwYWNpdHlcbiAgICovXG4gIGV4dGVuZEZyb21BcnJheShhcnI6IFRbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIGFyci5sZW5ndGggPiB0aGlzLm1heFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVjdG9yIG92ZXJmbG93Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIHRoaXMucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kcyB0aGUgdmVjdG9yIGJ5IGFkZGluZyBhbGwgZWxlbWVudHMgZnJvbSBhbm90aGVyIGJvdW5kZWQgdmVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gdmVjIC0gVGhlIGJvdW5kZWQgdmVjdG9yIHdob3NlIGVsZW1lbnRzIHNob3VsZCBiZSBhZGRlZFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYWRkaW5nIHRoZSBlbGVtZW50cyB3b3VsZCBleGNlZWQgdGhlIHZlY3RvcidzIG1heGltdW0gY2FwYWNpdHlcbiAgICovXG4gIGV4dGVuZEZyb21WZWModmVjOiBCb3VuZGVkVmVjPFQsIE4+KTogdm9pZCB7XG4gICAgdGhpcy5leHRlbmRGcm9tQXJyYXkodmVjLnRvQXJyYXkoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHZlY3RvcidzIGVsZW1lbnRzIGFzIGFuIGFycmF5LlxuICAgKiBPbmx5IGluY2x1ZGVzIGVsZW1lbnRzIHVwIHRvIHRoZSBjdXJyZW50IGxlbmd0aC5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmVjdG9yJ3MgZWxlbWVudHNcbiAgICovXG4gIHByaXZhdGUgdG9BcnJheSgpOiBUW10ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgQm91bmRlZFZlYyB0byBhIENpcmN1aXQgSW5wdXQgcmVwcmVzZW50YXRpb24uXG4gICAqIFRoZSBKU09OIG9iamVjdCBjb250YWlucyBib3RoIHRoZSBlbGVtZW50cyBhbmQgdGhlIGN1cnJlbnQgbGVuZ3RoLlxuICAgKlxuICAgKiBAcmV0dXJucyBOb2lyIENpcmN1aXQgSW5wdXQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJvdW5kZWRWZWNcbiAgICovXG4gIHRvQ2lyY3VpdElucHV0cygpOiB7XG4gICAgc3RvcmFnZTogSW5wdXRWYWx1ZVtdO1xuICAgIGxlbjogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmFnZTogdGhpcy5zdG9yYWdlKCkubWFwKChpdGVtKSA9PiBnZXRJbnB1dFJlcHJlc2VudGF0aW9uKGl0ZW0pKSxcbiAgICAgIGxlbjogdGhpcy5sZW5ndGgsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbmNvbnN0IE1BWF9GSUVMRF9TSVpFID1cbiAgMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTZuO1xuXG5jb25zdCBmaWVsZElucHV0U2NoZW1hID0gei51bmlvbihbXG4gIHoubnVtYmVyKCkuaW50KCdGaWVsZCBpbnB1dCBtdXN0IGJlIGFuIGludGVnZXInKSxcbiAgei5iaWdpbnQoKSxcbiAgelxuICAgIC5zdHJpbmcoKVxuICAgIC5yZWZpbmUoXG4gICAgICAoc3RyKSA9PiAvXjB4WzAtOWEtZkEtRl0rJC8udGVzdChzdHIpIHx8IC9eXFxkKyQvLnRlc3Qoc3RyKSxcbiAgICAgICdTdHJpbmcgbXVzdCBiZSBhIGRlY2ltYWwgb3IgaGV4YWRlY2ltYWwgbnVtYmVyJ1xuICAgICksXG5dKTtcblxuZXhwb3J0IGNvbnN0IEZpZWxkVmFsaWRhdG9yID0gZmllbGRJbnB1dFNjaGVtYVxuICAudHJhbnNmb3JtKCh2YWwpOiBiaWdpbnQgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIEJpZ0ludCh2YWwpOyAvLyBoYW5kbGVzIGJvdGggaGV4IGFuZCBkZWNpbWFsXG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQodmFsKTtcbiAgfSlcbiAgLnJlZmluZShcbiAgICAobikgPT4gbiA8PSBNQVhfRklFTERfU0laRSAmJiBuID49IC1NQVhfRklFTERfU0laRSxcbiAgICAnRmllbGQgdmFsdWUgbXVzdCBiZSBiZXR3ZWVuIC1NQVhfRklFTERfU0laRSBhbmQgTUFYX0ZJRUxEX1NJWkUnXG4gICk7XG5cbmV4cG9ydCBjb25zdCBJbnRlZ2VyVmFsaWRhdG9yID0gKG1pbjogYmlnaW50LCBtYXg6IGJpZ2ludCkgPT5cbiAgZmllbGRJbnB1dFNjaGVtYVxuICAgIC50cmFuc2Zvcm0oKG4pID0+IEJpZ0ludChuKSlcbiAgICAucmVmaW5lKChuKSA9PiBuID49IG1pbiAmJiBuIDw9IG1heCwge1xuICAgICAgbWVzc2FnZTogYFZhbHVlIG11c3QgYmUgaW4gcmFuZ2UgWyR7bWlufSwgJHttYXh9XWAsXG4gICAgfSk7XG5cbmV4cG9ydCB0eXBlIEZpZWxkSW5wdXQgPSB6LmluZmVyPHR5cGVvZiBmaWVsZElucHV0U2NoZW1hPjtcbmV4cG9ydCB0eXBlIEludGVnZXJJbnB1dCA9IHouaW5mZXI8dHlwZW9mIGZpZWxkSW5wdXRTY2hlbWE+O1xuIiwiaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQgdHlwZSB7IEJpdCB9IGZyb20gJ34vdHlwZXMnO1xuaW1wb3J0IHsgdHlwZSBGaWVsZElucHV0LCBGaWVsZFZhbGlkYXRvciB9IGZyb20gJy4vem9kJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZmluaXRlIGZpZWxkIGVsZW1lbnQgdXNlZCBpbiBub2lyLlxuICpcbiAqIFRoZSBGaWVsZCBjbGFzcyBpbXBsZW1lbnRzIG9wZXJhdGlvbnMgYW5kIGNvbnZlcnNpb25zIGZvciBmaWVsZCBlbGVtZW50cyB0aGF0IGFyZSBjb21wYXRpYmxlXG4gKiB3aXRoIE5vaXIncyBkZWZhdWx0IHByb3ZpbmcgYmFja2VuZCB3aXRoIHRoZSBHcnVtcGtpbiBjdXJ2ZSwgYW5kIGZpZWxkcyBzaXplIG9mICAyNTQtYml0cy5cbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzOlxuICogLSBDb3JlIGNvbnZlcnNpb25zIGJldHdlZW4gZGlmZmVyZW50IHJlcHJlc2VudGF0aW9ucyAoYml0cywgYnl0ZXMsIHJhZGl4KVxuICogLSBNYXRoZW1hdGljYWwgb3BlcmF0aW9ucyAoYWRkaXRpb24sIHN1YnRyYWN0aW9uLCBtdWx0aXBsaWNhdGlvbiwgZGl2aXNpb24pXG4gKiAtIENyeXB0b2dyYXBoaWMgb3BlcmF0aW9ucyAoc2lnbiBkZXRlcm1pbmF0aW9uKVxuICogLSBWYWxpZGF0aW9uIGFuZCBzYWZldHkgY2hlY2tzXG4gKiAtIFNlcmlhbGl6YXRpb24gbWV0aG9kc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBmaWVsZCA9IG5ldyBGaWVsZCg0Mm4pO1xuICogY29uc3QgYml0cyA9IGZpZWxkLnRvTGVCaXRzKDgpOyAvLyBbMCwgMSwgMCwgMSwgMCwgMSwgMCwgMF1cbiAqIGNvbnN0IHN1bSA9IGZpZWxkLmFkZCg1OG4pOyAvLyBuZXcgRmllbGQoMTAwbilcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRmllbGQge1xuICAvKiogVGhlIGludGVybmFsIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQgdmFsdWUgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IGJpZ2ludDtcblxuICAvKiogVGhlIG1heGltdW0gYml0IHNpemUgb2YgYSBGaWVsZCAqL1xuICBzdGF0aWMgcmVhZG9ubHkgTUFYX0JJVF9TSVpFID0gMjU0bjtcblxuICAvKiogVGhlIG1vZHVsdXMgb2YgdGhlIGZpZWxkICovXG4gIHN0YXRpYyByZWFkb25seSBNT0RVTFVTID1cbiAgICAyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN247XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRmllbGQgaW5zdGFuY2UgZnJvbSB2YXJpb3VzIGlucHV0IHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdmFsdWUgdG8gY29udmVydCB0byBhIGZpZWxkIGVsZW1lbnRcbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgaW5wdXQgY2Fubm90IGJlIHBhcnNlZCBhcyBhIHZhbGlkIGZpZWxkIHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbnB1dDogRmllbGRJbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IEZpZWxkVmFsaWRhdG9yLnBhcnNlKGlucHV0KTtcbiAgICB0aGlzLnZhbHVlID0gcGFyc2VkICUgRmllbGQuTU9EVUxVUztcbiAgfVxuXG4gIFtpbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIGBGaWVsZDwke3RoaXMudmFsdWUudG9TdHJpbmcoKX0+YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgbG9nMiBvZiBhIGxhcmdlIHZhbHVlICgwLTJeMjU0KS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbXB1dGUgdGhlIGxvZzIgb2ZcbiAgICogQHJldHVybnMgVGhlIGxvZzIgb2YgdGhlIHZhbHVlXG4gICAqL1xuICBwcml2YXRlIGxvZzIodmFsdWU6IGJpZ2ludCk6IGJpZ2ludCB7XG4gICAgaWYgKHZhbHVlIDw9IDBuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvZzIgaXMgdW5kZWZpbmVkIGZvciBub24tcG9zaXRpdmUgdmFsdWVzJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IDBuO1xuICAgIGxldCB2ID0gdmFsdWU7XG5cbiAgICB3aGlsZSAodiA+IDFuKSB7XG4gICAgICB2ID4+PSAxbjtcbiAgICAgIHJlc3VsdCArPSAxbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBmaWVsZCB2YWx1ZSB0byBhbiBhcnJheSBvZiBiaXRzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSBsZW5ndGggLSBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gZXh0cmFjdFxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBiaXRzICgwIG9yIDEpIGluIGxpdHRsZS1lbmRpYW4gb3JkZXJcbiAgICogQHRocm93cyBFcnJvciBpZiBsZW5ndGggaXMgbmVnYXRpdmUgb3IgZXhjZWVkcyBGaWVsZC5NQVhfQklUX1NJWkUgb3IgaWYgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSByZXF1aXJlZCBiaXRzIHRvIHJlcHJlc2VudCB0aGUgdmFsdWVcbiAgICovXG4gIHRvTGVCaXRzPE4gZXh0ZW5kcyBudW1iZXI+KGxlbmd0aDogTik6IEJpdFtdIHtcbiAgICBjb25zdCBtaW5MZW5ndGhSZXF1aXJlZCA9XG4gICAgICB0aGlzLnZhbHVlID09PSAwbiA/IDAgOiBNYXRoLmNlaWwoTnVtYmVyKHRoaXMubG9nMih0aGlzLnZhbHVlKSkgKyAxKTtcbiAgICBpZiAobGVuZ3RoIDwgbWluTGVuZ3RoUmVxdWlyZWQgfHwgbGVuZ3RoID4gRmllbGQuTUFYX0JJVF9TSVpFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBMZW5ndGggbXVzdCBiZSBiZXR3ZWVuICR7bWluTGVuZ3RoUmVxdWlyZWR9IGFuZCAke0ZpZWxkLk1BWF9CSVRfU0laRX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdHM6IEJpdFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYml0ID0gKHRoaXMudmFsdWUgPj4gQmlnSW50KGkpKSAmIDFuO1xuICAgICAgYml0cy5wdXNoKE51bWJlcihiaXQpIGFzIEJpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpdHM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGZpZWxkIHZhbHVlIHRvIGFuIGFycmF5IG9mIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtIGxlbmd0aCAtIFRoZSBudW1iZXIgb2YgYml0cyB0byBleHRyYWN0XG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGJpdHMgKDAgb3IgMSkgaW4gYmlnLWVuZGlhbiBvcmRlclxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGxlbmd0aCBpcyBuZWdhdGl2ZSBvciBleGNlZWRzIEZpZWxkLk1BWF9CSVRfU0laRSBvciBpZiBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHJlcXVpcmVkIGJpdHMgdG8gcmVwcmVzZW50IHRoZSB2YWx1ZVxuICAgKi9cbiAgdG9CZUJpdHM8TiBleHRlbmRzIG51bWJlcj4obGVuZ3RoOiBOKTogQml0W10ge1xuICAgIGNvbnN0IG1pbkxlbmd0aFJlcXVpcmVkID1cbiAgICAgIHRoaXMudmFsdWUgPT09IDBuID8gMCA6IE1hdGguY2VpbChOdW1iZXIodGhpcy5sb2cyKHRoaXMudmFsdWUpKSArIDEpO1xuICAgIGlmIChsZW5ndGggPCBtaW5MZW5ndGhSZXF1aXJlZCB8fCBsZW5ndGggPiBGaWVsZC5NQVhfQklUX1NJWkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYExlbmd0aCBtdXN0IGJlIGJldHdlZW4gJHttaW5MZW5ndGhSZXF1aXJlZH0gYW5kICR7RmllbGQuTUFYX0JJVF9TSVpFfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0czogQml0W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGJpdCA9ICh0aGlzLnZhbHVlID4+IEJpZ0ludChpKSkgJiAxbjtcbiAgICAgIGJpdHMucHVzaChOdW1iZXIoYml0KSBhcyBCaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBiaXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBmaWVsZCB2YWx1ZSB0byBhbiBhcnJheSBvZiBieXRlcyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIG51bWJlciBvZiBieXRlcyB0byBleHRyYWN0XG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGJ5dGVzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXJcbiAgICogQHRocm93cyBFcnJvciBpZiBsZW5ndGggaXMgbmVnYXRpdmUgb3IgZXhjZWVkcyBGaWVsZC5NQVhfQklUX1NJWkUgb3IgaWYgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSByZXF1aXJlZCBieXRlcyB0byByZXByZXNlbnQgdGhlIHZhbHVlXG4gICAqL1xuICB0b0xlQnl0ZXM8TiBleHRlbmRzIG51bWJlcj4obGVuZ3RoOiBOKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IG1pbkxlbmd0aFJlcXVpcmVkID0gTWF0aC5jZWlsKHRoaXMudmFsdWUudG9TdHJpbmcoMikubGVuZ3RoIC8gOCk7XG4gICAgaWYgKGxlbmd0aCA8IG1pbkxlbmd0aFJlcXVpcmVkIHx8IGxlbmd0aCA+IEZpZWxkLm1vZExlQnl0ZXMoKS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYExlbmd0aCBtdXN0IGJlIGJldHdlZW4gJHttaW5MZW5ndGhSZXF1aXJlZH0gYW5kICR7RmllbGQubW9kTGVCeXRlcygpLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBieXRlczogbnVtYmVyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIoKHRoaXMudmFsdWUgPj4gQmlnSW50KDggKiBpKSkgJiAweGZmbik7XG4gICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZmllbGQgdmFsdWUgdG8gYW4gYXJyYXkgb2YgYnl0ZXMgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtIGxlbmd0aCAtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZXh0cmFjdFxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBieXRlcyBpbiBiaWctZW5kaWFuIG9yZGVyLCBzaXplZCBieSB0aGUgbGVuZ3RoIHBhcmFtZXRlclxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGxlbmd0aCBpcyBuZWdhdGl2ZSwgb3IgZXhjZWVkcyBtYXhpbXVtIGJpdCBzaXplIG9yIGlmIGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gcmVxdWlyZWQgYnl0ZXMgdG8gcmVwcmVzZW50IHRoZSB2YWx1ZVxuICAgKi9cbiAgdG9CZUJ5dGVzPE4gZXh0ZW5kcyBudW1iZXI+KGxlbmd0aDogTik6IG51bWJlcltdIHtcbiAgICBjb25zdCBtaW5MZW5ndGhSZXF1aXJlZCA9IE1hdGguY2VpbCh0aGlzLnZhbHVlLnRvU3RyaW5nKDIpLmxlbmd0aCAvIDgpO1xuICAgIGlmIChsZW5ndGggPCBtaW5MZW5ndGhSZXF1aXJlZCB8fCBsZW5ndGggPiBGaWVsZC5tb2RCZUJ5dGVzKCkubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBMZW5ndGggbXVzdCBiZSBiZXR3ZWVuICR7bWluTGVuZ3RoUmVxdWlyZWR9IGFuZCAke0ZpZWxkLm1vZEJlQnl0ZXMoKS5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXM6IG51bWJlcltdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIoKHRoaXMudmFsdWUgPj4gQmlnSW50KDggKiBpKSkgJiAweGZmbik7XG4gICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBtaW5pbXVtIGxlbmd0aCBuZWVkZWQgdG8gcmVwcmVzZW50IGEgdmFsdWUgaW4gYSBnaXZlbiByYWRpeCwgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdCBwb3dlciBvZiAyLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSB0byBkZXRlcm1pbmUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGRpZ2l0cyByZXF1aXJlZCB0byByZXByZXNlbnRcbiAgICogYSBmaWVsZCB2YWx1ZSBpbiBhIGdpdmVuIGJhc2UgKHJhZGl4KS4gVGhlIHJlc3VsdCBpcyBhbHdheXMgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdCBwb3dlciBvZiAyXG4gICAqIHRvIGVuc3VyZSBjb25zaXN0ZW50IHNpemluZyBmb3IgY3J5cHRvZ3JhcGhpYyBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYmlnaW50IHZhbHVlIHRvIGNhbGN1bGF0ZSB0aGUgcmVwcmVzZW50YXRpb24gbGVuZ3RoIGZvclxuICAgKiBAcGFyYW0gcmFkaXggLSBUaGUgYmFzZSB0byByZXByZXNlbnQgdGhlIHZhbHVlIGluIChtdXN0IGJlIGEgcG93ZXIgb2YgMilcbiAgICogQHJldHVybnMgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGRpZ2l0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gcmFkaXgsIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3QgcG93ZXIgb2YgMlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcmFkaXggaXMgbm90IGEgcG93ZXIgb2YgMlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHJhZGl4IGlzIGxlc3MgdGhhbiAyXG4gICAqL1xuICBwcml2YXRlIG1pblJhZGl4TGVuZ3RoKHZhbHVlOiBiaWdpbnQsIHJhZGl4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh2YWx1ZSA8IDBuKSB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgaWYgKChyYWRpeCAmIChyYWRpeCAtIDEpKSAhPT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXggbXVzdCBiZSBhIHBvd2VyIG9mIDInKTtcbiAgICBpZiAocmFkaXggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4IG11c3QgYmUgPj0gMicpO1xuXG4gICAgaWYgKHZhbHVlID09PSAwbikgcmV0dXJuIDE7XG5cbiAgICAvLyBDb21wdXRlIGxvZzIocmFkaXgpXG4gICAgbGV0IHJhZGl4Qml0cyA9IDA7XG4gICAgbGV0IHIgPSByYWRpeDtcbiAgICB3aGlsZSAoKHIgPj49IDEpID4gMCkge1xuICAgICAgcmFkaXhCaXRzKys7XG4gICAgfVxuXG4gICAgLy8gQ291bnQgaG93IG1hbnkgYml0cyBhcmUgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgdmFsdWVcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IHYgPSB2YWx1ZTtcbiAgICB3aGlsZSAodiA+IDBuKSB7XG4gICAgICB2ID4+PSAxbjtcbiAgICAgIGJpdHMrKztcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIG1pbmltdW0gbnVtYmVyIG9mIHJhZGl4IGRpZ2l0c1xuICAgIGNvbnN0IHJhd0xlbiA9IE1hdGguY2VpbChiaXRzIC8gcmFkaXhCaXRzKTtcblxuICAgIC8vIFJvdW5kIHVwIHRvIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDJcbiAgICBsZXQgcm91bmRlZCA9IDE7XG4gICAgd2hpbGUgKHJvdW5kZWQgPCByYXdMZW4pIHtcbiAgICAgIHJvdW5kZWQgPDw9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdW5kZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGZpZWxkIHZhbHVlIHRvIGFuIGFycmF5IG9mIGRpZ2l0cyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAqXG4gICAqIEBwYXJhbSByYWRpeCAtIFRoZSBiYXNlIHRvIHVzZSBmb3IgY29udmVyc2lvblxuICAgKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gZXh0cmFjdFxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBkaWdpdHMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlclxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHJhZGl4IGlzIGludmFsaWQgb3IgbGVuZ3RoIGlzIG5lZ2F0aXZlIG9yIGlmIGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gcmVxdWlyZWQgZGlnaXRzIHRvIHJlcHJlc2VudCB0aGUgdmFsdWUsIG9yIGlmIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gMjU2XG4gICAqL1xuICB0b0xlUmFkaXgocmFkaXg6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbWluaW11bVJlcXVpcmVkID0gdGhpcy5taW5SYWRpeExlbmd0aCh0aGlzLnZhbHVlLCByYWRpeCk7XG4gICAgaWYgKGxlbmd0aCA8IG1pbmltdW1SZXF1aXJlZCB8fCBsZW5ndGggPiAyNTYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGVuZ3RoIG11c3QgYmUgYmV0d2VlbiAke21pbmltdW1SZXF1aXJlZH0gYW5kIDI1NmApO1xuICAgIH1cblxuICAgIGNvbnN0IHIgPSBCaWdJbnQocmFkaXgpO1xuICAgIGNvbnN0IGRpZ2l0czogbnVtYmVyW10gPSBbXTtcblxuICAgIGxldCB2ID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBkaWdpdHMucHVzaChOdW1iZXIodiAlIHIpKTtcbiAgICAgIHYgLz0gcjtcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXMgaWYgbmVlZGVkXG4gICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCBsZW5ndGgpIGRpZ2l0cy5wdXNoKDApO1xuXG4gICAgcmV0dXJuIGRpZ2l0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZmllbGQgdmFsdWUgdG8gYW4gYXJyYXkgb2YgZGlnaXRzIGluIGJpZy1lbmRpYW4gb3JkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICpcbiAgICogQHBhcmFtIHJhZGl4IC0gVGhlIGJhc2UgdG8gdXNlIGZvciBjb252ZXJzaW9uIChtdXN0IGJlIGEgcG93ZXIgb2YgMiBiZXR3ZWVuIDIgYW5kIDI1NilcbiAgICogQHBhcmFtIGxlbmd0aCAtIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGV4dHJhY3RcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgZGlnaXRzIGluIGJpZy1lbmRpYW4gb3JkZXJcbiAgICogQHRocm93cyBFcnJvciBpZiByYWRpeCBpcyBpbnZhbGlkIG9yIGxlbmd0aCBpcyBuZWdhdGl2ZSBvciBpZiBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHJlcXVpcmVkIGRpZ2l0cyB0byByZXByZXNlbnQgdGhlIHZhbHVlLCBvciBpZiBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIDI1NlxuICAgKi9cbiAgdG9CZVJhZGl4KHJhZGl4OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IG1pbmltdW1SZXF1aXJlZCA9IHRoaXMubWluUmFkaXhMZW5ndGgodGhpcy52YWx1ZSwgcmFkaXgpO1xuICAgIGlmIChsZW5ndGggPCBtaW5pbXVtUmVxdWlyZWQgfHwgbGVuZ3RoID4gMjU2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBtdXN0IGJlIGJldHdlZW4gJHttaW5pbXVtUmVxdWlyZWR9IGFuZCAyNTZgKTtcbiAgICB9XG5cbiAgICBjb25zdCByID0gQmlnSW50KHJhZGl4KTtcbiAgICBjb25zdCBkaWdpdHM6IG51bWJlcltdID0gW107XG5cbiAgICBsZXQgdiA9IHRoaXMudmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgZGlnaXRzLnB1c2goTnVtYmVyKHYgJSByKSk7XG4gICAgICB2IC89IHI7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggbGVhZGluZyB6ZXJvZXMgaWYgbmVlZGVkLCB0aGVuIHJldmVyc2UgZm9yIEJFXG4gICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCBsZW5ndGgpIGRpZ2l0cy5wdXNoKDApO1xuXG4gICAgcmV0dXJuIGRpZ2l0cy5yZXZlcnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmFpc2VzIHRoZSBmaWVsZCB2YWx1ZSB0byB0aGUgc3BlY2lmaWVkIHBvd2VyLlxuICAgKlxuICAgKiBAcGFyYW0gZXhwb25lbnQgLSBUaGUgcG93ZXIgdG8gcmFpc2UgdG9cbiAgICogQHJldHVybnMgQSBuZXcgRmllbGQgaW5zdGFuY2Ugd2l0aCB0aGUgcmVzdWx0XG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgZXhwb25lbnQgaXMgbmVnYXRpdmUgb3IgZ3JlYXRlciB0aGFuIGVxdWFsIHRvIDJeMzJcbiAgICovXG4gIHBvdzMyKGV4cG9uZW50OiB0aGlzKTogRmllbGQge1xuICAgIGNvbnN0IGV4cCA9IGV4cG9uZW50LnZhbHVlO1xuICAgIGNvbnN0IE1BWF9FWFAgPSBCaWdJbnQoMiAqKiAzMik7XG4gICAgaWYgKGV4cCA8IDBuKVxuICAgICAgLy8gTm9pciBvbmx5IHN1cHBvcnRzIGV4cG9uZW50cyA8IDJeMzJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgZXhwb25lbnRzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgIGlmIChleHAgPj0gTUFYX0VYUClcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwb25lbnQgdG9vIGxhcmdlOiBleGNlZWRzIDJeMzIgbGltaXQnKTtcblxuICAgIGxldCByZXN1bHQgPSAxbjtcbiAgICBsZXQgYiA9IHRoaXMudmFsdWUgJSBGaWVsZC5NT0RVTFVTO1xuICAgIGxldCBlID0gZXhwO1xuXG4gICAgd2hpbGUgKGUgPiAwbikge1xuICAgICAgaWYgKGUgJiAxbikge1xuICAgICAgICByZXN1bHQgPSAocmVzdWx0ICogYikgJSBGaWVsZC5NT0RVTFVTO1xuICAgICAgfVxuICAgICAgYiA9IChiICogYikgJSBGaWVsZC5NT0RVTFVTO1xuICAgICAgZSA+Pj0gMW47XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBGaWVsZChyZXN1bHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgZmllbGQgdmFsdWUgZG9lcyBub3QgZXhjZWVkIHRoZSBzcGVjaWZpZWQgYml0IHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSBiaXRTaXplIC0gVGhlIG1heGltdW0gYWxsb3dlZCBiaXQgc2l6ZVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBmaWVsZCB2YWx1ZSBleGNlZWRzIHRoZSBzcGVjaWZpZWQgYml0IHNpemVcbiAgICovXG4gIGFzc2VydE1heEJpdFNpemUoYml0U2l6ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmFsdWUgPCAwbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWdhdGl2ZSBmaWVsZCB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgfVxuXG4gICAgbGV0IGJpdExlbmd0aCA9IDA7XG4gICAgbGV0IHYgPSB0aGlzLnZhbHVlO1xuXG4gICAgd2hpbGUgKHYgPiAwbikge1xuICAgICAgdiA+Pj0gMW47XG4gICAgICBiaXRMZW5ndGgrKztcbiAgICB9XG5cbiAgICBpZiAoYml0TGVuZ3RoID4gYml0U2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCB2YWx1ZSBleGNlZWRzICR7Yml0U2l6ZX0gYml0c2ApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIHRoZSBmaWVsZCB2YWx1ZSAoMCBvciAxKS5cbiAgICogVGhpcyBpcyB1c2VkIGluIGNyeXB0b2dyYXBoaWMgb3BlcmF0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHNpZ24gb2YgYSBmaWVsZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyAwIGlmIHRoZSB2YWx1ZSBpcyBldmVuLCAxIGlmIG9kZFxuICAgKi9cbiAgc2duMCgpOiBCaXQge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy52YWx1ZSAmIDFuKSBhcyBCaXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBmaWVsZCB2YWx1ZSBhcyBhIGRlY2ltYWwgc3RyaW5nXG4gICAqL1xuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZmllbGQgdmFsdWUgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBsZW5ndGggLSBPcHRpb25hbCBsZW5ndGggaW4gYnl0ZXMgdG8gcGFkIHRoZSBoZXggc3RyaW5nIHRvXG4gICAqIEByZXR1cm5zIFRoZSBmaWVsZCB2YWx1ZSBhcyBhIGhleGFkZWNpbWFsIHN0cmluZyB3aXRoICcweCcgcHJlZml4XG4gICAqL1xuICB0b0hleCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGhleCA9IHRoaXMudmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBgMHgke2hleH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBmaWVsZCB2YWx1ZSB0byBpdHMgQ2lyY3VpdCBJbnB1dCByZXByZXNlbnRhdGlvbi5cbiAgICogUmV0dXJucyB0aGUgZmllbGQgdmFsdWUgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAqXG4gICAqL1xuICB0b0NpcmN1aXRJbnB1dHMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGZpZWxkIHZhbHVlIGVxdWFscyBhbm90aGVyIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0IChjYW4gYmUgRmllbGQsIG51bWJlciwgc3RyaW5nLCBvciBiaWdpbnQpXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlcyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhvdGhlcjogRmllbGQgfCBudW1iZXIgfCBzdHJpbmcgfCBiaWdpbnQpOiBib29sZWFuIHtcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBGaWVsZCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG90aGVyLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gQmlnSW50KG90aGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgdmFsdWUgdG8gdGhpcyBmaWVsZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIGFkZCAoY2FuIGJlIEZpZWxkLCBudW1iZXIsIHN0cmluZywgb3IgYmlnaW50KVxuICAgKiBAcmV0dXJucyBBIG5ldyBGaWVsZCBpbnN0YW5jZSB3aXRoIHRoZSBzdW1cbiAgICovXG4gIGFkZChpbnB1dDogRmllbGQgfCBudW1iZXIgfCBzdHJpbmcgfCBiaWdpbnQpOiBGaWVsZCB7XG4gICAgY29uc3QgcmhzID0gaW5wdXQgaW5zdGFuY2VvZiBGaWVsZCA/IGlucHV0LnZhbHVlIDogQmlnSW50KGlucHV0KTtcbiAgICBjb25zdCBzdW0gPSB0aGlzLnZhbHVlICsgcmhzO1xuICAgIGNvbnN0IHJlZHVjZWQgPSBzdW0gPj0gRmllbGQuTU9EVUxVUyA/IHN1bSAtIEZpZWxkLk1PRFVMVVMgOiBzdW07XG5cbiAgICByZXR1cm4gbmV3IEZpZWxkKHJlZHVjZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyBhbm90aGVyIHZhbHVlIGZyb20gdGhpcyBmaWVsZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIHN1YnRyYWN0IChjYW4gYmUgRmllbGQsIG51bWJlciwgc3RyaW5nLCBvciBiaWdpbnQpXG4gICAqIEByZXR1cm5zIEEgbmV3IEZpZWxkIGluc3RhbmNlIHdpdGggdGhlIGRpZmZlcmVuY2VcbiAgICovXG4gIHN1YihpbnB1dDogRmllbGQgfCBudW1iZXIgfCBzdHJpbmcgfCBiaWdpbnQpOiBGaWVsZCB7XG4gICAgY29uc3Qgb3RoZXJGaWVsZCA9IGlucHV0IGluc3RhbmNlb2YgRmllbGQgPyBpbnB1dCA6IG5ldyBGaWVsZChpbnB1dCk7XG4gICAgY29uc3QgcmVzID0gKHRoaXMudmFsdWUgLSBvdGhlckZpZWxkLnZhbHVlICsgRmllbGQuTU9EVUxVUykgJSBGaWVsZC5NT0RVTFVTO1xuICAgIHJldHVybiBuZXcgRmllbGQocmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoaXMgZmllbGQgdmFsdWUgYnkgYW5vdGhlciB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIG11bHRpcGx5IGJ5IChjYW4gYmUgRmllbGQsIG51bWJlciwgc3RyaW5nLCBvciBiaWdpbnQpXG4gICAqIEByZXR1cm5zIEEgbmV3IEZpZWxkIGluc3RhbmNlIHdpdGggdGhlIHByb2R1Y3RcbiAgICovXG4gIG11bChpbnB1dDogRmllbGQgfCBudW1iZXIgfCBzdHJpbmcgfCBiaWdpbnQpOiBGaWVsZCB7XG4gICAgY29uc3Qgb3RoZXJGaWVsZCA9IGlucHV0IGluc3RhbmNlb2YgRmllbGQgPyBpbnB1dCA6IG5ldyBGaWVsZChpbnB1dCk7XG4gICAgcmV0dXJuIG5ldyBGaWVsZCgodGhpcy52YWx1ZSAqIG90aGVyRmllbGQudmFsdWUpICUgRmllbGQuTU9EVUxVUyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG1vZHVsYXIgaW52ZXJzZSBvZiBhIGZpZWxkIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBhIC0gVGhlIGZpZWxkIGVsZW1lbnQgdG8gY29tcHV0ZSB0aGUgaW52ZXJzZSBvZlxuICAgKiBAcGFyYW0gbW9kIC0gVGhlIG1vZHVsdXMgdG8gdXNlIGZvciB0aGUgY29tcHV0YXRpb25cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG1vZHVsYXIgaW52ZXJzZSBvZiB0aGUgZmllbGQgZWxlbWVudFxuICAgKi9cbiAgcHJpdmF0ZSBtb2RJbnYoYTogYmlnaW50LCBtb2Q6IGJpZ2ludCk6IGJpZ2ludCB7XG4gICAgbGV0IHQgPSAwbjtcbiAgICBsZXQgbmV3VCA9IDFuO1xuICAgIGxldCByID0gbW9kO1xuICAgIGxldCBuZXdSID0gYTtcblxuICAgIHdoaWxlIChuZXdSICE9PSAwbikge1xuICAgICAgY29uc3QgcXVvdGllbnQgPSByIC8gbmV3UjtcbiAgICAgIFt0LCBuZXdUXSA9IFtuZXdULCB0IC0gcXVvdGllbnQgKiBuZXdUXTtcbiAgICAgIFtyLCBuZXdSXSA9IFtuZXdSLCByIC0gcXVvdGllbnQgKiBuZXdSXTtcbiAgICB9XG5cbiAgICBpZiAociA+IDFuKSB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG5vdCBpbnZlcnRpYmxlJyk7XG4gICAgaWYgKHQgPCAwbikgdCArPSBtb2Q7XG5cbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHRoaXMgZmllbGQgdmFsdWUgYnkgYW5vdGhlciB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIGRpdmlkZSBieSAoY2FuIGJlIEZpZWxkLCBudW1iZXIsIHN0cmluZywgb3IgYmlnaW50KVxuICAgKiBAcmV0dXJucyBBIG5ldyBGaWVsZCBpbnN0YW5jZSB3aXRoIHRoZSBxdW90aWVudFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGRpdmlkaW5nIGJ5IHplcm9cbiAgICovXG4gIGRpdihpbnB1dDogRmllbGQgfCBudW1iZXIgfCBzdHJpbmcgfCBiaWdpbnQpOiBGaWVsZCB7XG4gICAgY29uc3Qgb3RoZXJGaWVsZCA9IGlucHV0IGluc3RhbmNlb2YgRmllbGQgPyBpbnB1dCA6IG5ldyBGaWVsZChpbnB1dCk7XG5cbiAgICBpZiAob3RoZXJGaWVsZC52YWx1ZSA9PT0gMG4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGl2aXNpb24gYnkgemVybycpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgbW9kdWxhciBpbnZlcnNlIG9mIGRpdmlzb3JcbiAgICBjb25zdCBpbnYgPSB0aGlzLm1vZEludihvdGhlckZpZWxkLnZhbHVlLCBGaWVsZC5NT0RVTFVTKTtcbiAgICBjb25zdCByZXN1bHQgPSAodGhpcy52YWx1ZSAqIGludikgJSBGaWVsZC5NT0RVTFVTO1xuXG4gICAgcmV0dXJuIG5ldyBGaWVsZChyZXN1bHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSByZW1haW5kZXIgb2YgZGl2aXNpb24gb2YgdGhpcyBmaWVsZCB2YWx1ZSBieSBhbm90aGVyIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gZGl2aWRlIGJ5IChjYW4gYmUgRmllbGQsIG51bWJlciwgc3RyaW5nLCBvciBiaWdpbnQpXG4gICAqIEByZXR1cm5zIEEgbmV3IEZpZWxkIGluc3RhbmNlIHdpdGggdGhlIHJlbWFpbmRlclxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGRpdmlkaW5nIGJ5IHplcm9cbiAgICovXG4gIG1vZChpbnB1dDogRmllbGQgfCBudW1iZXIgfCBzdHJpbmcgfCBiaWdpbnQpOiBGaWVsZCB7XG4gICAgY29uc3QgcmhzID0gaW5wdXQgaW5zdGFuY2VvZiBGaWVsZCA/IGlucHV0LnZhbHVlIDogbmV3IEZpZWxkKGlucHV0KS52YWx1ZTtcblxuICAgIGlmIChyaHMgPT09IDBuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBtb2R1bG8gYnkgemVybycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSAoKHRoaXMudmFsdWUgJSByaHMpICsgcmhzKSAlIHJocztcbiAgICByZXR1cm4gbmV3IEZpZWxkKHJlc3VsdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBmaWVsZCB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybnMgQSBuZXcgRmllbGQgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSB2YWx1ZVxuICAgKi9cbiAgY2xvbmUoKTogRmllbGQge1xuICAgIHJldHVybiBuZXcgRmllbGQodGhpcy52YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgbW9kQmVCaXRzKCk6IEJpdFtdIHtcbiAgICByZXR1cm4gW1xuICAgICAgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMSwgMCwgMCwgMSwgMSxcbiAgICAgIDEsIDAsIDAsIDEsIDAsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIDAsIDEsIDAsXG4gICAgICAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDEsIDAsIDEsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDEsIDEsIDEsIDAsXG4gICAgICAxLCAwLCAwLCAxLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMSwgMCwgMCwgMSwgMCxcbiAgICAgIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDAsIDEsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsXG4gICAgICAxLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAxLCAxLCAxLCAxLFxuICAgICAgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBtb2RCZUJ5dGVzKCk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gW1xuICAgICAgNDgsIDEwMCwgNzgsIDExNCwgMjI1LCA0OSwgMTYwLCA0MSwgMTg0LCA4MCwgNjksIDE4MiwgMTI5LCAxMjksIDg4LCA5MyxcbiAgICAgIDQwLCA1MSwgMjMyLCA3MiwgMTIxLCAxODUsIDExMiwgMTQ1LCA2NywgMjI1LCAyNDUsIDE0NywgMjQwLCAwLCAwLCAxLFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgbW9kTGVCaXRzKCk6IEJpdFtdIHtcbiAgICByZXR1cm4gW1xuICAgICAgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsXG4gICAgICAwLCAwLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAxLCAwLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMSwgMSwgMCwgMSwgMCwgMCwgMSwgMSwgMSwgMCwgMSwgMSwgMCwgMCwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMSxcbiAgICAgIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsXG4gICAgICAxLCAwLCAwLCAxLCAwLCAxLCAxLCAxLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAxLCAwLCAxLCAwLCAxLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMCwgMSxcbiAgICAgIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDAsIDEsIDEsIDAsIDAsIDEsIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAwLCAwLCAwLCAxLCAwLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAwLFxuICAgICAgMSwgMCwgMCwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMSwgMCwgMCwgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMSwgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDEsXG4gICAgXTtcbiAgfVxuXG4gIHN0YXRpYyBtb2RMZUJ5dGVzKCk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gW1xuICAgICAgMSwgMCwgMCwgMjQwLCAxNDcsIDI0NSwgMjI1LCA2NywgMTQ1LCAxMTIsIDE4NSwgMTIxLCA3MiwgMjMyLCA1MSwgNDAsIDkzLFxuICAgICAgODgsIDEyOSwgMTI5LCAxODIsIDY5LCA4MCwgMTg0LCA0MSwgMTYwLCA0OSwgMjI1LCAxMTQsIDc4LCAxMDAsIDQ4LFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgbW9kTnVtQml0cygpOiBiaWdpbnQge1xuICAgIHJldHVybiBGaWVsZC5NQVhfQklUX1NJWkU7XG4gIH1cbn1cbiIsImltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9maWVsZCc7XG5pbXBvcnQgeyBJbnRlZ2VyVmFsaWRhdG9yIH0gZnJvbSAnLi96b2QnO1xuaW1wb3J0IHR5cGUgeyBJbnRlZ2VySW5wdXQgfSBmcm9tICcuL3pvZC9pbmRleCc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIGludGVnZXIgdHlwZXMgd2l0aCBmaXhlZCBiaXQtd2lkdGhzLlxuICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBhbmQgdmFsdWUgdmFsaWRhdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSBjb25jcmV0ZSBpbnRlZ2VyIHR5cGUgZXh0ZW5kaW5nIHRoaXMgY2xhc3NcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0SW50ZWdlciBleHRlbmRzIEZpZWxkIHtcbiAgLyoqIE1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyBpbnRlZ2VyIHR5cGUgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyBNQVhfVkFMVUU6IGJpZ2ludDtcbiAgLyoqIE1pbmltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyBpbnRlZ2VyIHR5cGUgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyBNSU5fVkFMVUU6IGJpZ2ludDtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbWluaW11bSB2YWx1ZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBieSB0aGlzIGludGVnZXIgdHlwZS5cbiAgICogQHJldHVybnMgVGhlIG1pbmltdW0gdmFsdWUgYXMgYSBiaWdpbnRcbiAgICovXG4gIHByb3RlY3RlZCBtaW4oKTogYmlnaW50IHtcbiAgICByZXR1cm4gKHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIEFic3RyYWN0SW50ZWdlcikuTUlOX1ZBTFVFO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdGhpcyBpbnRlZ2VyIHR5cGUuXG4gICAqIEByZXR1cm5zIFRoZSBtYXhpbXVtIHZhbHVlIGFzIGEgYmlnaW50XG4gICAqL1xuICBwcm90ZWN0ZWQgbWF4KCk6IGJpZ2ludCB7XG4gICAgcmV0dXJuICh0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBBYnN0cmFjdEludGVnZXIpLk1BWF9WQUxVRTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBjb25jcmV0ZSBpbnRlZ2VyIHR5cGUuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoZSBuZXcgaW5zdGFuY2Ugd2l0aFxuICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgY29uY3JldGUgaW50ZWdlciB0eXBlXG4gICAqL1xuICBwcm90ZWN0ZWQgbmV3SW5zdGFuY2UodmFsdWU6IEludGVnZXJJbnB1dCB8IEZpZWxkKTogdGhpcyB7XG4gICAgY29uc3QgQ29uY3JldGVDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWVsZCkge1xuICAgICAgcmV0dXJuIG5ldyBDb25jcmV0ZUNsYXNzKHZhbHVlLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb25jcmV0ZUNsYXNzKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGludGVnZXIgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyB3aXRoaW4gdGhlIGFsbG93ZWQgcmFuZ2UuXG4gICAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBpbml0aWFsaXplIHRoaXMgaW50ZWdlciB3aXRoXG4gICAqIEB0aHJvd3Mge1pvZEVycm9yfSBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgb3V0c2lkZSB0aGUgYWxsb3dlZCByYW5nZVxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5wdXQ6IEludGVnZXJJbnB1dCkge1xuICAgIHN1cGVyKGlucHV0KTtcbiAgICBjb25zdCBtaW4gPSAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgQWJzdHJhY3RJbnRlZ2VyKS5NSU5fVkFMVUU7XG4gICAgY29uc3QgbWF4ID0gKHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIEFic3RyYWN0SW50ZWdlcikuTUFYX1ZBTFVFO1xuICAgIEludGVnZXJWYWxpZGF0b3IobWluLCBtYXgpLnBhcnNlKGlucHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFub3RoZXIgaW50ZWdlciB0byB0aGlzIG9uZSB3aXRoIG92ZXJmbG93IGNoZWNraW5nLlxuICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgaW50ZWdlciB0byBhZGRcbiAgICogQHJldHVybnMgQSBuZXcgaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIHN1bVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHJlc3VsdCB3b3VsZCBvdmVyZmxvd1xuICAgKi9cbiAgb3ZlcnJpZGUgYWRkKG90aGVyOiB0aGlzIHwgSW50ZWdlcklucHV0KTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMubmV3SW5zdGFuY2Uoc3VwZXIuYWRkKG90aGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3RzIGFub3RoZXIgaW50ZWdlciBmcm9tIHRoaXMgb25lIHdpdGggb3ZlcmZsb3cgY2hlY2tpbmcuXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBpbnRlZ2VyIHRvIHN1YnRyYWN0XG4gICAqIEByZXR1cm5zIEEgbmV3IGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbmNlXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcmVzdWx0IHdvdWxkIG92ZXJmbG93XG4gICAqL1xuICBvdmVycmlkZSBzdWIob3RoZXI6IHRoaXMgfCBJbnRlZ2VySW5wdXQpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5uZXdJbnN0YW5jZShzdXBlci5zdWIob3RoZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoaXMgaW50ZWdlciBieSBhbm90aGVyIHdpdGggb3ZlcmZsb3cgY2hlY2tpbmcuXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBpbnRlZ2VyIHRvIG11bHRpcGx5IGJ5XG4gICAqIEByZXR1cm5zIEEgbmV3IGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBwcm9kdWN0XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcmVzdWx0IHdvdWxkIG92ZXJmbG93XG4gICAqL1xuICBvdmVycmlkZSBtdWwob3RoZXI6IHRoaXMgfCBJbnRlZ2VySW5wdXQpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5uZXdJbnN0YW5jZShzdXBlci5tdWwob3RoZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHRoaXMgaW50ZWdlciBieSBhbm90aGVyIHdpdGggb3ZlcmZsb3cgY2hlY2tpbmcuXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBpbnRlZ2VyIHRvIGRpdmlkZSBieVxuICAgKiBAcmV0dXJucyBBIG5ldyBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgcXVvdGllbnRcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSByZXN1bHQgd291bGQgb3ZlcmZsb3cgb3IgaWYgZGl2aWRpbmcgYnkgemVyb1xuICAgKi9cbiAgb3ZlcnJpZGUgZGl2KG90aGVyOiB0aGlzIHwgSW50ZWdlcklucHV0KTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMubmV3SW5zdGFuY2Uoc3VwZXIuZGl2KG90aGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHJlbWFpbmRlciBvZiBkaXZpZGluZyB0aGlzIGludGVnZXIgYnkgYW5vdGhlci5cbiAgICogQHBhcmFtIG90aGVyIC0gVGhlIGludGVnZXIgdG8gZGl2aWRlIGJ5XG4gICAqIEByZXR1cm5zIEEgbmV3IGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSByZW1haW5kZXJcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGRpdmlkaW5nIGJ5IHplcm9cbiAgICovXG4gIG92ZXJyaWRlIG1vZChvdGhlcjogdGhpcyB8IEludGVnZXJJbnB1dCk6IHRoaXMge1xuICAgIHJldHVybiBzdXBlci5tb2Qob3RoZXIpIGFzIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgd3JhcHBpbmcgYWRkaXRpb24gb2YgdHdvIGludGVnZXJzLlxuICAgKiBJZiB0aGUgcmVzdWx0IHdvdWxkIG92ZXJmbG93LCBpdCB3cmFwcyBhcm91bmQgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBpbnRlZ2VyIHRvIGFkZFxuICAgKiBAcmV0dXJucyBBIG5ldyBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgd3JhcHBlZCBzdW1cbiAgICovXG4gIHdyYXBwaW5nQWRkKG90aGVyOiB0aGlzKTogdGhpcyB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW4oKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heCgpO1xuICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluICsgMW47XG5cbiAgICBjb25zdCBhID0gdGhpcy52YWx1ZSAtIG1pbjtcbiAgICBjb25zdCBiID0gb3RoZXIudmFsdWUgLSBtaW47XG5cbiAgICBjb25zdCBtYXNrID0gcmFuZ2UgLSAxbjtcbiAgICBjb25zdCBzdW0gPSAoYSArIGIpICYgbWFzaztcblxuICAgIHJldHVybiB0aGlzLm5ld0luc3RhbmNlKHN1bSArIG1pbik7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgd3JhcHBpbmcgc3VidHJhY3Rpb24gb2YgdHdvIGludGVnZXJzLlxuICAgKiBJZiB0aGUgcmVzdWx0IHdvdWxkIHVuZGVyZmxvdywgaXQgd3JhcHMgYXJvdW5kIHRvIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgaW50ZWdlciB0byBzdWJ0cmFjdFxuICAgKiBAcmV0dXJucyBBIG5ldyBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgd3JhcHBlZCBkaWZmZXJlbmNlXG4gICAqL1xuICB3cmFwcGluZ1N1YihvdGhlcjogdGhpcyk6IHRoaXMge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluKCk7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXgoKTtcbiAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pbiArIDFuO1xuXG4gICAgY29uc3QgYSA9IHRoaXMudmFsdWUgLSBtaW47XG4gICAgY29uc3QgYiA9IG90aGVyLnZhbHVlIC0gbWluO1xuXG4gICAgY29uc3QgbWFzayA9IHJhbmdlIC0gMW47XG4gICAgY29uc3QgZGlmZiA9IChhIC0gYikgJiBtYXNrO1xuXG4gICAgcmV0dXJuIHRoaXMubmV3SW5zdGFuY2UoZGlmZiArIG1pbik7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgd3JhcHBpbmcgbXVsdGlwbGljYXRpb24gb2YgdHdvIGludGVnZXJzLlxuICAgKiBJZiB0aGUgcmVzdWx0IHdvdWxkIG92ZXJmbG93LCBpdCB3cmFwcyBhcm91bmQgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBpbnRlZ2VyIHRvIG11bHRpcGx5IGJ5XG4gICAqIEByZXR1cm5zIEEgbmV3IGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSB3cmFwcGVkIHByb2R1Y3RcbiAgICovXG4gIHdyYXBwaW5nTXVsKG90aGVyOiB0aGlzKTogdGhpcyB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW4oKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heCgpO1xuICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluICsgMW47XG5cbiAgICBjb25zdCBhID0gdGhpcy52YWx1ZSAtIG1pbjtcbiAgICBjb25zdCBiID0gb3RoZXIudmFsdWUgLSBtaW47XG5cbiAgICBjb25zdCBtYXNrID0gcmFuZ2UgLSAxbjtcbiAgICBjb25zdCBwcm9kID0gKGEgKiBiKSAmIG1hc2s7XG5cbiAgICByZXR1cm4gdGhpcy5uZXdJbnN0YW5jZShwcm9kICsgbWluKTtcbiAgfVxufVxuXG4vKipcbiAqIDEtYml0IHVuc2lnbmVkIGludGVnZXIgdHlwZS5cbiAqIFJhbmdlOiAwIHRvIDFcbiAqL1xuZXhwb3J0IGNsYXNzIFUxIGV4dGVuZHMgQWJzdHJhY3RJbnRlZ2VyIHtcbiAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSBNQVhfVkFMVUUgPSAxbjtcbiAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSBNSU5fVkFMVUUgPSAwbjtcbn1cblxuLyoqXG4gKiA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHR5cGUuXG4gKiBSYW5nZTogMCB0byAyNTVcbiAqL1xuZXhwb3J0IGNsYXNzIFU4IGV4dGVuZHMgQWJzdHJhY3RJbnRlZ2VyIHtcbiAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSBNQVhfVkFMVUUgPSAyNTVuO1xuICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIE1JTl9WQUxVRSA9IDBuO1xufVxuXG4vKipcbiAqIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHR5cGUuXG4gKiBSYW5nZTogMCB0byA2NSw1MzVcbiAqL1xuZXhwb3J0IGNsYXNzIFUxNiBleHRlbmRzIEFic3RyYWN0SW50ZWdlciB7XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUFYX1ZBTFVFID0gNjU1MzVuO1xuICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIE1JTl9WQUxVRSA9IDBuO1xufVxuXG4vKipcbiAqIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHR5cGUuXG4gKiBSYW5nZTogMCB0byA0LDI5NCw5NjcsMjk1XG4gKi9cbmV4cG9ydCBjbGFzcyBVMzIgZXh0ZW5kcyBBYnN0cmFjdEludGVnZXIge1xuICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIE1BWF9WQUxVRSA9IDQyOTQ5NjcyOTVuO1xuICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIE1JTl9WQUxVRSA9IDBuO1xufVxuXG4vKipcbiAqIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHR5cGUuXG4gKiBSYW5nZTogMCB0byAxOCw0NDYsNzQ0LDA3Myw3MDksNTUxLDYxNVxuICovXG5leHBvcnQgY2xhc3MgVTY0IGV4dGVuZHMgQWJzdHJhY3RJbnRlZ2VyIHtcbiAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSBNQVhfVkFMVUUgPSAxODQ0Njc0NDA3MzcwOTU1MTYxNW47XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUlOX1ZBTFVFID0gMG47XG59XG5cbi8qKlxuICogMS1iaXQgc2lnbmVkIGludGVnZXIgdHlwZS5cbiAqIFJhbmdlOiAtMSB0byAwXG4gKi9cbmV4cG9ydCBjbGFzcyBJMSBleHRlbmRzIEFic3RyYWN0SW50ZWdlciB7XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUFYX1ZBTFVFID0gMG47XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUlOX1ZBTFVFID0gLTBuO1xufVxuXG4vKipcbiAqIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHR5cGUuXG4gKiBSYW5nZTogLTEyOCB0byAxMjdcbiAqL1xuZXhwb3J0IGNsYXNzIEk4IGV4dGVuZHMgQWJzdHJhY3RJbnRlZ2VyIHtcbiAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSBNQVhfVkFMVUUgPSAxMjduO1xuICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIE1JTl9WQUxVRSA9IC0xMjhuO1xufVxuXG4vKipcbiAqIDE2LWJpdCBzaWduZWQgaW50ZWdlciB0eXBlLlxuICogUmFuZ2U6IC0zMiw3NjggdG8gMzIsNzY3XG4gKi9cbmV4cG9ydCBjbGFzcyBJMTYgZXh0ZW5kcyBBYnN0cmFjdEludGVnZXIge1xuICBwcm90ZWN0ZWQgc3RhdGljIG92ZXJyaWRlIE1BWF9WQUxVRSA9IDMyNzY3bjtcbiAgcHJvdGVjdGVkIHN0YXRpYyBvdmVycmlkZSBNSU5fVkFMVUUgPSAtMzI3NjhuO1xufVxuXG4vKipcbiAqIDMyLWJpdCBzaWduZWQgaW50ZWdlciB0eXBlLlxuICogUmFuZ2U6IC0yLDE0Nyw0ODMsNjQ4IHRvIDIsMTQ3LDQ4Myw2NDdcbiAqL1xuZXhwb3J0IGNsYXNzIEkzMiBleHRlbmRzIEFic3RyYWN0SW50ZWdlciB7XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUFYX1ZBTFVFID0gMjE0NzQ4MzY0N247XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDhuO1xufVxuXG4vKipcbiAqIDY0LWJpdCBzaWduZWQgaW50ZWdlciB0eXBlLlxuICogUmFuZ2U6IC05LDIyMywzNzIsMDM2LDg1NCw3NzUsODA4IHRvIDksMjIzLDM3MiwwMzYsODU0LDc3NSw4MDdcbiAqL1xuZXhwb3J0IGNsYXNzIEk2NCBleHRlbmRzIEFic3RyYWN0SW50ZWdlciB7XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUFYX1ZBTFVFID0gOTIyMzM3MjAzNjg1NDc3NTgwN247XG4gIHByb3RlY3RlZCBzdGF0aWMgb3ZlcnJpZGUgTUlOX1ZBTFVFID0gLTkyMjMzNzIwMzY4NTQ3NzU4MDhuO1xufVxuIiwiaW1wb3J0IHsgVTggfSBmcm9tICcuL2ludGVnZXInO1xuXG4vKipcbiAqIEEgc3RyaW5nIHZhbHVlIHR5cGUgdGhhdCBwcm92aWRlcyB0eXBlLXNhZmUgc3RyaW5nIG9wZXJhdGlvbnMgYW5kIGJ5dGUgY29udmVyc2lvbi5cbiAqIFRoaXMgY2xhc3Mgd3JhcHMgYSBwcmltaXRpdmUgc3RyaW5nIHZhbHVlIGFuZCBwcm92aWRlcyBtZXRob2RzIGZvciBzdHJpbmcgY29tcGFyaXNvblxuICogYW5kIFVURi04IGJ5dGUgYXJyYXkgY29udmVyc2lvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ciB7XG4gIC8qKiBUaGUgdW5kZXJseWluZyBzdHJpbmcgdmFsdWUgKi9cbiAgcHJpdmF0ZSByZWFkb25seSB2YWw6IHN0cmluZztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdHJpbmcgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHZhbHVlIHRvIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHdpdGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnZhbCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHZhbHVlXG4gICAqL1xuICB2YWx1ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmdcbiAgICovXG4gIGxlbigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnZhbC5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHN0cmluZyB0byBhbiBhcnJheSBvZiBVVEYtOCBlbmNvZGVkIGJ5dGVzLlxuICAgKiBFYWNoIGJ5dGUgaXMgcmVwcmVzZW50ZWQgYXMgYSBVOCBpbnRlZ2VyIHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBVOCBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIFVURi04IGVuY29kZWQgYnl0ZXNcbiAgICovXG4gIGFzQnl0ZXMoKTogVThbXSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVyLmVuY29kZSh0aGlzLnZhbCk7XG4gICAgY29uc3QgcmVzOiBVOFtdID0gW107XG4gICAgZm9yIChjb25zdCBlbGUgb2YgZW5jb2RlZCkge1xuICAgICAgcmVzLnB1c2gobmV3IFU4KGVsZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoaXMgc3RyaW5nIHdpdGggYW5vdGhlciBmb3IgZXF1YWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBzdHJpbmcgdG8gY29tcGFyZSB3aXRoXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYm90aCBzdHJpbmdzIGhhdmUgdGhlIHNhbWUgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgZXEob3RoZXI6IFN0cik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZhbCA9PT0gb3RoZXIudmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBzdHJpbmcgdG8gaXRzIENpcmN1aXQgSW5wdXQgcmVwcmVzZW50YXRpb24uXG4gICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgcHJpbWl0aXZlIHN0cmluZyB2YWx1ZS5cbiAgICovXG4gIHRvQ2lyY3VpdElucHV0cygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnZhbDtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBJbnB1dE1hcCB9IGZyb20gJ0Bub2lyLWxhbmcvbm9pcl9qcyc7XG5pbXBvcnQgdHlwZSB7IElucHV0VmFsdWUgfSBmcm9tICd+L3R5cGVzJztcbmltcG9ydCB7IEZpeGVkU2l6ZUFycmF5IH0gZnJvbSAnLi9hcnJheSc7XG5pbXBvcnQgeyBCb29sIH0gZnJvbSAnLi9ib29sJztcbmltcG9ydCB7IEJvdW5kZWRWZWMgfSBmcm9tICcuL2JvdW5kZWQtdmVjJztcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSAnLi9maWVsZCc7XG5pbXBvcnQgeyBBYnN0cmFjdEludGVnZXIgfSBmcm9tICcuL2ludGVnZXInO1xuaW1wb3J0IHsgU3RyIH0gZnJvbSAnLi9zdHJpbmcnO1xuXG5leHBvcnQgdHlwZSBEYXRhVHlwZSA9XG4gIHwgRmllbGRcbiAgfCBCb29sXG4gIHwgU3RyXG4gIHwgQm91bmRlZFZlYzxEYXRhVHlwZSwgbnVtYmVyPlxuICB8IEZpeGVkU2l6ZUFycmF5PERhdGFUeXBlLCBudW1iZXI+XG4gIHwgU3RydWN0TWFwO1xuXG5leHBvcnQgdHlwZSBTdHJ1Y3RNYXAgPSB7XG4gIFtrZXk6IHN0cmluZ106IERhdGFUeXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldElucHV0UmVwcmVzZW50YXRpb24gPSAodmFsdWU6IERhdGFUeXBlKTogSW5wdXRWYWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0SW50ZWdlcikge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJvb2wpIHtcbiAgICByZXR1cm4gdmFsdWUudG9DaXJjdWl0SW5wdXRzKCk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvQ2lyY3VpdElucHV0cygpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpZWxkKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvQ2lyY3VpdElucHV0cygpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJvdW5kZWRWZWMpIHtcbiAgICByZXR1cm4gdmFsdWUudG9DaXJjdWl0SW5wdXRzKCk7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaXhlZFNpemVBcnJheSkge1xuICAgIHJldHVybiB2YWx1ZS50b0NpcmN1aXRJbnB1dHMoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVzdWx0OiBJbnB1dFZhbHVlID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBnZXRJbnB1dFJlcHJlc2VudGF0aW9uKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYEludmFsaWQgdmFsdWUgdHlwZTogJHt2YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB2YWx1ZX1gXG4gICk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdG9DaXJjdWl0SW5wdXRzKHZhbHVlOiBTdHJ1Y3RNYXApOiBJbnB1dE1hcCB7XG4gIHJldHVybiBnZXRJbnB1dFJlcHJlc2VudGF0aW9uKHZhbHVlKSBhcyBJbnB1dE1hcDtcbn1cblxuZXhwb3J0ICogZnJvbSAnLi9maWVsZCc7XG5leHBvcnQgKiBmcm9tICcuL2ludGVnZXInO1xuZXhwb3J0ICogZnJvbSAnLi9ib29sJztcbmV4cG9ydCAqIGZyb20gJy4vc3RyaW5nJztcbmV4cG9ydCAqIGZyb20gJy4vYXJyYXknO1xuZXhwb3J0ICogZnJvbSAnLi9ib3VuZGVkLXZlYyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vem9kJztcbiJdfQ==