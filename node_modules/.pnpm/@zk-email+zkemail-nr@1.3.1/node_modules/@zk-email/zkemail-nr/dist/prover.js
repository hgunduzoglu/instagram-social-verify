"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZKEmailProver = void 0;
const bb_js_1 = require("@aztec/bb.js");
const noir_js_1 = require("@noir-lang/noir_js");
class ZKEmailProver {
    constructor(
    /* The ACIR of the Noir circuit to prove */
    circuit, 
    /* Define the prover backend to use */
    provingBackend = "plonk", 
    /* Threads to use */
    threads = 1) {
        this.provingBackend = provingBackend;
        this.threads = threads;
        // initialize the backends
        if (provingBackend === "plonk" || provingBackend === "all") {
            this.plonk = new bb_js_1.UltraPlonkBackend(circuit.bytecode, { threads: this.threads });
        }
        if (provingBackend === "honk" || provingBackend === "all") {
            this.honk = new bb_js_1.UltraHonkBackend(circuit.bytecode, { threads: this.threads });
        }
        // initialize the Noir instance
        this.noir = new noir_js_1.Noir(circuit);
    }
    /**
     * Compute the witness for a given input to the circuit without generating a proof
     *
     * @param input - the input that should produce a satisfying witness for the circuit
     * @returns - the witness for the input and the output of the circuit if satisfiable
     */
    async simulateWitness(input) {
        return this.noir.execute(input);
    }
    /**
     * Generate a proof of a satisfying input to the circuit using a provided witness
     *
     * @param input - a satisfying witness for the circuit
     * @param provingBackend - optionally provided if the class was initialized with both proving schemes
     * @returns proof of valid execution of the circuit
     */
    async prove(witness, provingBackend) {
        // determine proving backend to use
        let backend;
        if ((provingBackend && this.plonk) ||
            (this.provingBackend === "plonk" && this.plonk)) {
            backend = this.plonk;
        }
        else if ((provingBackend === "honk" && this.honk) ||
            (this.provingBackend === "honk" && this.honk)) {
            backend = this.honk;
        }
        else {
            throw new Error(`Proving scheme ${this.provingBackend} not initialized`);
        }
        // generate the proof
        return backend.generateProof(witness);
    }
    /**
     * Simulate the witness for a given input and generate a proof
     *
     * @param input - the input that should produce a satisfying witness for the circuit
     * @param provingBackend - optionally provided if the class was initialized with both proving schemes
     * @returns proof of valid execution of the circuit
     */
    async fullProve(input, provingBackend) {
        const { witness } = await this.simulateWitness(input);
        return this.prove(witness, provingBackend);
    }
    /**
     * Verify a proof of a satisfying input to the circuit for a given proving scheme
     *
     * @param proof - the proof to verify
     * @param provingBackend - optionally provided if the class was initialized with both proving schemes
     * @returns true if the proof is valid, false otherwise
     */
    async verify(proof, provingBackend) {
        // determine proving backend to use
        let backend;
        if ((provingBackend && this.plonk) ||
            (this.provingBackend === "plonk" && this.plonk)) {
            backend = this.plonk;
        }
        else if ((provingBackend === "honk" && this.honk) ||
            (this.provingBackend === "honk" && this.honk)) {
            backend = this.honk;
        }
        else {
            throw new Error(`Proving scheme ${this.provingBackend} not initialized`);
        }
        // verify the proof
        return backend.verifyProof(proof);
    }
    /**
     * End the prover wasm instance(s) and clean up resources
     */
    async destroy() {
        if (this.plonk) {
            await this.plonk.destroy();
        }
        if (this.honk) {
            await this.honk.destroy();
        }
    }
}
exports.ZKEmailProver = ZKEmailProver;
