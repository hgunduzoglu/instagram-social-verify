/** A simple immutable Merkle tree container. Use a MerkleTreeCalculator to create a new instance from a set of leaves. */ export class MerkleTree {
    height;
    nodes;
    constructor(height, nodes){
        this.height = height;
        this.nodes = nodes;
        const expectedNodeCount = 2 ** (height + 1) - 1;
        if (nodes.length !== expectedNodeCount) {
            throw new Error(`Invalid node count for Merkle tree: got ${nodes.length} but expected ${expectedNodeCount}`);
        }
    }
    get root() {
        return this.nodes[this.nodes.length - 1];
    }
    get leaves() {
        return this.nodes.slice(0, 2 ** this.height);
    }
    getSiblingPath(leafIndexOrLeaf) {
        if (Buffer.isBuffer(leafIndexOrLeaf)) {
            return this.getSiblingPath(this.getIndex(leafIndexOrLeaf));
        }
        const leafIndex = leafIndexOrLeaf;
        if (leafIndex < 0 || leafIndex >= 2 ** this.height) {
            throw new Error(`Invalid leaf index: got ${leafIndex} but leaves count is ${2 ** this.height}`);
        }
        const tree = this.nodes;
        let rowSize = Math.ceil(tree.length / 2);
        let rowOffset = 0;
        let index = leafIndex;
        const siblingPath = [];
        while(rowSize > 1){
            const isRight = index & 1;
            siblingPath.push(tree[rowOffset + index + (isRight ? -1 : 1)]);
            rowOffset += rowSize;
            rowSize >>= 1;
            index >>= 1;
        }
        return siblingPath;
    }
    /** Returns the leaf index for a given element. */ getIndex(element) {
        return this.leaves.findIndex((leaf)=>leaf.equals(element));
    }
    /** Returns a nice string representation of the tree, useful for debugging purposes. */ drawTree(elemSize = 8) {
        const levels = [];
        const tree = this.nodes;
        const maxRowSize = Math.ceil(tree.length / 2);
        let paddingSize = 1;
        let rowSize = maxRowSize;
        let rowOffset = 0;
        while(rowSize > 0){
            levels.push(tree.slice(rowOffset, rowOffset + rowSize).map((n)=>n.toString('hex').slice(0, elemSize) + ' '.repeat((paddingSize - 1) * (elemSize + 1))));
            rowOffset += rowSize;
            paddingSize <<= 1;
            rowSize >>= 1;
        }
        return levels.reverse().map((row)=>row.join(' ')).join('\n');
    }
}
