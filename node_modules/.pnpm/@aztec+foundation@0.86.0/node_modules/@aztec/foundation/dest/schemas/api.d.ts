import type { z } from 'zod';
import type { ZodNullableOptional } from './utils.js';
type ZodParameterTypeFor<T> = undefined extends T ? ZodNullableOptional<z.ZodType<T, z.ZodTypeDef, any>> : z.ZodType<T, z.ZodTypeDef, any>;
type ZodReturnTypeFor<T> = z.ZodType<T, z.ZodTypeDef, any>;
type ZodMapParameterTypes<T> = T extends [] ? [] : T extends [item: infer Head, ...infer Rest] ? [ZodParameterTypeFor<Head>, ...{
    [K in keyof Rest]: ZodParameterTypeFor<Rest[K]>;
}] : T extends [item?: infer Head, ...infer Rest] ? [ZodNullableOptional<ZodParameterTypeFor<Head>>, ...{
    [K in keyof Rest]: ZodParameterTypeFor<Rest[K]>;
}] : never;
/** Maps all functions in an interface to their schema representation. */
export type ApiSchemaFor<T> = {
    [K in keyof T]: T[K] extends (...args: infer Args) => Promise<infer Ret> ? z.ZodFunction<z.ZodTuple<ZodMapParameterTypes<Args>, z.ZodUnknown>, ZodReturnTypeFor<Ret>> : never;
};
/** Generic Api schema not bounded to a specific implementation. */
export type ApiSchema = {
    [key: string]: z.ZodFunction<z.ZodTuple<any, any>, z.ZodTypeAny>;
};
/** Return whether an API schema defines a valid function schema for a given method name. */
export declare function schemaHasMethod(schema: ApiSchema, methodName: string): boolean;
export {};
//# sourceMappingURL=api.d.ts.map