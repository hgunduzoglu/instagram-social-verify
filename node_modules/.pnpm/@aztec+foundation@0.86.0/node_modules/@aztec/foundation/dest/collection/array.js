/**
 * Pads an array to the target length by appending an element to its end. Throws if target length exceeds the input array length. Does not modify the input array.
 * @param arr - Array with elements to pad.
 * @param elem - Element to use for padding.
 * @param length - Target length.
 * @param errorMsg - Error message to throw if target length exceeds the input array length.
 * @returns A new padded array.
 */ export function padArrayEnd(arr, elem, length, errorMsg = 'Array size exceeds target length') {
    if (arr.length > length) {
        throw new Error(errorMsg);
    }
    // Since typescript cannot always deduce that something is a tuple, we cast
    return [
        ...arr,
        ...Array(length - arr.length).fill(elem)
    ];
}
/** Removes the right-padding for an array. Does not modify original array. */ export function removeArrayPaddingEnd(arr, isEmpty) {
    const lastNonEmptyIndex = arr.reduce((last, item, i)=>isEmpty(item) ? last : i, -1);
    return lastNonEmptyIndex === -1 ? [] : arr.slice(0, lastNonEmptyIndex + 1);
}
/**
 * Pads an array to the target length by prepending elements at the beginning. Throws if target length exceeds the input array length. Does not modify the input array.
 * @param arr - Array with elements to pad.
 * @param elem - Element to use for padding.
 * @param length - Target length.
 * @returns A new padded array.
 */ export function padArrayStart(arr, elem, length) {
    if (arr.length > length) {
        throw new Error(`Array size exceeds target length`);
    }
    // Since typescript cannot always deduce that something is a tuple, we cast
    return [
        ...Array(length - arr.length).fill(elem),
        ...arr
    ];
}
/**
 * Returns if an array is composed of empty items.
 * @param arr - Array to check.
 * @returns True if every item in the array isEmpty.
 */ export function isArrayEmpty(arr, isEmpty) {
    for (const item of arr){
        if (!isEmpty(item)) {
            return false;
        }
    }
    return true;
}
/**
 * Returns the number of non-empty items in an array.
 * @param arr - Array to check.
 * @returns Number of non-empty items in an array.
 */ export function arrayNonEmptyLength(arr, isEmpty) {
    return arr.reduce((sum, item)=>isEmpty(item) ? sum : sum + 1, 0);
}
/**
 * Executes the given function n times and returns the results in an array.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */ export function times(n, fn) {
    return [
        ...Array(n).keys()
    ].map((i)=>fn(i));
}
/**
 * Executes the given async function n times and returns the results in an array. Awaits each execution before starting the next one.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */ export async function timesAsync(n, fn) {
    const results = [];
    for(let i = 0; i < n; i++){
        results.push(await fn(i));
    }
    return results;
}
/**
 * Executes the given async function n times in parallel and returns the results in an array.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */ export async function timesParallel(n, fn) {
    const results = await Promise.all(Array(n).fill(0).map((_, i)=>fn(i)));
    return results;
}
/**
 * Returns the serialized size of all non-empty items in an array.
 * @param arr - Array
 * @returns The serialized size in bytes.
 */ export function arraySerializedSizeOfNonEmpty(arr) {
    return arr.filter((x)=>x && ('isZero' in x ? !x.isZero() : !x.isEmpty())).map((x)=>x.toBuffer().length).reduce((a, b)=>a + b, 0);
}
/**
 * Removes duplicates from the given array.
 * @param arr - The array.
 * @returns A new array.
 */ export function unique(arr) {
    return [
        ...new Set(arr)
    ];
}
/**
 * Removes all undefined elements from the array.
 * @param arr - The array.
 * @returns A new array.
 */ export function compactArray(arr) {
    return arr.filter((x)=>x !== undefined);
}
/**
 * Returns whether two arrays are equal. The arrays are equal if they have the same length and all elements are equal.
 */ export function areArraysEqual(a, b, eq = (a, b)=>a === b) {
    if (a.length !== b.length) {
        return false;
    }
    for(let i = 0; i < a.length; i++){
        if (!eq(a[i], b[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Returns the element of the array that has the maximum value of the given function.
 * In case of a tie, returns the first element with the maximum value.
 * @param arr - The array.
 * @param fn - The function to get the value to compare.
 */ export function maxBy(arr, fn) {
    return arr.reduce((max, x)=>fn(x) > fn(max) ? x : max, arr[0]);
}
/** Computes the sum of a numeric array. */ export function sum(arr) {
    return arr.reduce((a, b)=>a + b, 0);
}
/** Computes the median of a numeric array. Returns undefined if array is empty. */ export function median(arr) {
    if (arr.length === 0) {
        return undefined;
    }
    const sorted = [
        ...arr
    ].sort((a, b)=>a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
}
/** Computes the mean of a numeric array. Returns undefined if the array is empty. */ export function mean(values) {
    if (values.length === 0) {
        return undefined;
    }
    return values.reduce((a, b)=>a + b, 0) / values.length;
}
/** Computes the variance of a numeric array. Returns undefined if there are less than 2 points. */ export function variance(values) {
    if (values.length < 2) {
        return undefined;
    }
    const avg = mean(values);
    const points = values.map((value)=>value * value + avg * avg - 2 * value * avg);
    return sum(points) / (values.length - 1);
}
/** Computes the standard deviation of a numeric array. Returns undefined if there are less than 2 points. */ export function stdDev(values) {
    if (values.length < 2) {
        return undefined;
    }
    return Math.sqrt(variance(values));
}
/** Counts how many items from the beginning of the array match the given predicate. */ export function countWhile(collection, predicate) {
    let count = 0;
    for (const item of collection){
        if (predicate(item)) {
            count++;
        } else {
            break;
        }
    }
    return count;
}
