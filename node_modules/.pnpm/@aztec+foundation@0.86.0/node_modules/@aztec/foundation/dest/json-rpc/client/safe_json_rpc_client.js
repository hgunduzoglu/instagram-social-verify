import { format } from 'util';
import { createLogger } from '../../log/pino-logger.js';
import { schemaHasMethod } from '../../schemas/api.js';
import { defaultFetch } from './fetch.js';
/**
 * Creates a Proxy object that delegates over RPC and validates outputs against a given schema.
 * The server is expected to be a JsonRpcServer.
 * @param host - The host URL.
 * @param schema - The api schema to validate returned data against.
 * @param useApiEndpoints - Whether to use the API endpoints or the default RPC endpoint.
 * @param namespaceMethods - String value (or false/empty) to namespace all methods sent to the server. e.g. 'getInfo' -\> 'pxe_getInfo'
 * @param fetch - The fetch implementation to use.
 */ export function createSafeJsonRpcClient(host, schema, config = {}) {
    const fetch = config.fetch ?? defaultFetch;
    const log = config.log ?? createLogger('json-rpc:client');
    const { useApiEndpoints = false, namespaceMethods = false } = config;
    let id = 0;
    const request = async (methodName, params)=>{
        if (!schemaHasMethod(schema, methodName)) {
            throw new Error(`Unspecified method ${methodName} in client schema`);
        }
        const method = namespaceMethods ? `${namespaceMethods}_${methodName}` : methodName;
        const body = {
            jsonrpc: '2.0',
            id: id++,
            method,
            params
        };
        log.debug(format(`request`, method, params));
        const { response, headers } = await fetch(host, method, body, useApiEndpoints);
        log.debug(format(`result`, method, response));
        if (config.onResponse) {
            await config.onResponse({
                response,
                headers
            });
        }
        if (response.error) {
            throw response.error;
        }
        // TODO(palla/schemas): Find a better way to handle null responses (JSON.stringify(null) is string "null").
        if ([
            null,
            undefined,
            'null',
            'undefined'
        ].includes(response.result)) {
            return;
        }
        return schema[methodName].returnType().parseAsync(response.result);
    };
    const proxy = {};
    for (const method of Object.keys(schema)){
        proxy[method] = (...params)=>request(method, params);
    }
    return proxy;
}
