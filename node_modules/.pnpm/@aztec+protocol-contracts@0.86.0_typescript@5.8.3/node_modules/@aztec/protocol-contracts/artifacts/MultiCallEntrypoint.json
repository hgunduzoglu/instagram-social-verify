{
  "transpiled": true,
  "noir_version": "1.0.0-beta.4+0000000000000000000000000000000000000000",
  "name": "MultiCallEntrypoint",
  "functions": [
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",
      "debug_symbols": "rZLdCoMgGIbvxWMP/P/ZrYwxrGwIYmE1GNG9z8JYrNFOOhE/fXh50HcElS2Gx92FuunA5ToC35Smd01I0zhBUETnvXvct8cAzQumC9+1Jsxj15vYgwtGDFMIbKiWvSQpo3beLtMEd7xUItNqvs+sxD9QTnhGOUefWCamGwSYnWGjqFxtuD62YVRnlAm1s+Gn2Ci22mh1bCPQ+jaCiJ2NOMNGE5JpTfkfG4UyKtHXT01pfJroTOFtrlg9hHLTuP7V2q/ytbEpbTVEO9dw08C0XrGChKbYFP0G",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "entrypoint",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "app_payload",
            "type": {
              "kind": "struct",
              "path": "authwit::entrypoint::app::AppPayload",
              "fields": [
                {
                  "name": "function_calls",
                  "type": {
                    "kind": "array",
                    "length": 4,
                    "type": {
                      "kind": "struct",
                      "path": "authwit::entrypoint::function_call::FunctionCall",
                      "fields": [
                        {
                          "name": "args_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "target_address",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_public",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  }
                },
                {
                  "name": "nonce",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dCZyN1fu/M3dmbElIWSqksoVzZr1Di+xr9n2dYcYaKSqSbEmSJEmSkCRJkmQnSZIkKUlCSJS078v/ebj35+269V/mefrf73Tez+f7mWtmnPk+3+9zznPe9z3veWN8p4+4vD5f8TynP8cQ/MGvsYQyYd8LffV+jo/wewUifK9ghO8VivC9whG+dwGhZtj3Skf4vTIRvlc2wvcujfC98hG+VzHC9ypH0ODKCN+rGuH/mgi/ZyN8LynC/02J8HupEb4XiPB/q0f4vRrBr94j9O+awa9JJjU5OSstMcsm2QyTmJ4ZSDHJKZmpARuwKYGUnomBpKSsQHIgLT0zPc2k2+SkLJudkp6UbU4fhf1n2jI5OhJ7aPIs8n/maVPDv8PcihDiPFxZh9+Dnyv4znyu6PlcJPg7of9XlP59PqEY4QL/me+HDn+YBiZnh60k2FZRv5w3F4rlkDGa+lUWbOt8Qf2Kg+h3pWBbxQT1KyGoX6Sx4ULP2FDc87mE5/MFYWNDSfp3KcJFhIv/gbGhimBbJQW9uQQkt6sKtlVKUL/SIPpVE2zrIkH9yiiPDZd4xoDSns9lPJ8vDhsbytK/LyWUI1z2D4wNRrCtsoLeXA6S21awrUsF9bsCRL9EwbbKCepXXnlsuNwzBlzh+Vze8/mysLGhAv27IqESofI/MDYkCbZVQdCbK0FyO1mwrYqC+lUB0S9FsK1KgvpVVR4brvSMAVU8n6t6PlcOGxuq0b8NwRIS/4GxIVWwrWqC3iSB5HaaYFtGUL9kEP0Cgm1ZQf1SlMeGJM8YkOz5nOL5nBg2NqTSv9MIAUL6PzA2pAu2lSroTXWQ3K4u2FaaoH41QPSrIdhWQFC/q5THhuqeMaCG5/NVns/pYWPD1fTvawjXMrd/YGy4SrCtqwW9uU7Zm+s8Hlzj+Xyt53PNMG9q0b9rE+oQ6kbwJlbYm/I+OT3ryelpvfc9ud0yQY1ifWffA/X5zr6/aHJ2SN5bM16+9f2KhLlx6XYbCHY4rbgb+M8ILNTun4qVdKerJ6hpQ8FOF8mfnPKrHPRHWsPKghwbCU9ypHOcPW7kl/emsXABDA3YjT0Dts93dhHT0EhywNbkWQGEZz3lPpHjC8LBfJMeV/yCbQkukDDhPosb3ijKDWdjQqYjGJ7TeJsI+hHnO7PyM/z4tw7EFUF4/lsLhhZPyX4V6+HZNDgwXc8TNY2zMJ7xhlc7idm5VFsNlE7/mwZnk95Duuo3FTwja6Z8RmZydtjQGZkfJJdy2lbzKPeD86W5wtldC6Wzuxb/g/4o6VlO22op7L90rPWCZ/dSHENXC6L5qlWrKL/iwu1pXHFpHeVxV1KKu02Ux80xN1GIu22Ux11Bye92UR53PaUrqu2FT9r/qdtdgsv1/3S7q4NfkXAHhdtdHaP8dhfH3VHpdhfKxPabhOiOmyecrRTi/lY47tAhfSLYSXAyK+i1FdRP5VapCfZt6Ym7EeTYOcoLO+deZ4W+10XpZLrLP3Ay3VmwpnUVPpkOHdJjULfcPwaZf/L2uuQEUZNnFRCe3ZTH0Zz2H+6c0X57XfA5TP3b652Fzwy95mjwbRk8Q/YJtZt9+vhTpxJq24Y+ePXoHuSeEaq0oa/d/WfvrJPhqcIal5Za+sWqemKwh9ruglU9wy9rsPRoxJ2nO8hZL3vdWmEGmhnlM2+Ou41C3D0A4m6rEHdPgLjbKcSdBRB3e4W4s/+h9TM55dlLkCcP6fkJzYPt8RjH/Z1zn/OANenl8D/GX3lucnakhOYw0rnUO8r7Os87eivE3Ucw7thgHwo/JHXV0LaPP/o59pXmKH06zQFLXt7jtvr65Xn2FeTYD6fz2H9z5+knzRGlqvX3yyaQRlXrrxD3Da6q2RsAOuaAaK9qfLNBuqoNUKhqAwQ5DnRVDaLzDPy3VrUb5QJP1DCGO/mNCnEPclXNDgLomDdpd0yJB1hDt1UlA/cLtmUF471Z2BChG2h/mhUIJs2pAehmhVnGTYKzjMFulgExmA3+t84yhsgFnqRhDHfyIQpx3+JmGfYWgI55a7SfO/MCOOlz51sVqtqtghxvc1UNovPc9m+takPlAk/WMIY7+VCFuIe5qmaHAXTM26O9qnGCdhOuarcrVLXbBTkOd1UNovMMj/KqZrWq2h0A9znvUIh7hKDh3lXo3G4Z3+lBCbHS9QLorHcqcIxINKdJNlKwc6Em1EiAhBqFklCjBe/foSbUaICEGoOSUGMFL9WiJtRYgIS6CyWhxgleJUFNqHEACXU3SkKNlyOagppQ4wES6h6UhJogRzQVNaEmACTUvSgJNVGOaBpqQk0ESKj7UBJqkhzRAGpCTQJIqPtREmqyHNF01ISaDJBQD6Ak1BQ5ohmoCTUFIKEeREmoqXJEM1ETaipAQj2EklDT5Ij2QE2oaQAJ9TBKQk2XI9oTNaGmAyTUIygJNUOOaBZqQs0ASKhHURJqphzRbNSEmgmQUI+hJNQsMaIWduXvLICEehwloWbLJRTseqjZAAk1ByWh5solFOx6qLkACfUESkLNk0so2PVQ8wAS6kmUhJovl1Cw66HmAyTUUygJtUAuoWDXQy0ASKinURJqoVxCwa6HWgiQUM+gJNQiuYSCXQ+1CCChnkVJqMVyCQW7HmoxQEI9h5JQS+QSCnY91BKAhHoeJaGWyiUU7HqopQAJ9QJKQi2TSyjY9VDLABLqRZSEWi6XULDroZYDJNRLKAm1Qi6hYNdDrQBIqJUoCbVKLqFg10OtAkio1SgJtUYuoWDXQ60BSKi1KAm1ToxoIux6qHUACbUeJaE2yCUU7HqoDQAJ9TJKQm2USyjY9VAbARLqFZSE2iSXULDroTYBJNSrKAm1WS6hYNdDbQZIqNdQEmqLXELBrofaApBQr6Mk1Fa5hIJdD7UVIKHeQEmobXIJBbseahtAQr2JklDb5RIKdj3UdoCEegsloXbIJRTseqgdAAn1NkpC7ZRLKNj1UDsBEuodlITaJZdQsOuhdgEk1LuSHFGNKgxg1HsoPX+3XM+HXWe0GyCh3kdJqD1yCQW7zmgPQEJ9gJJQe+USCnad0V6AhPoQJaH2iRFNgl1ntA8goT5CSaj9cgkFu85oP0BCHUBJqINyCQW7zuggQEJ9jJJQh+QSCnad0SGAhDqMklBH5BIKdp3REYCE+gQloY7KJRTsOqOjAAn1KUpCHZNLKNh1RscAEuo4SkJ9JpdQsOuMPgNIqM9REuqEXELBrjM6AZBQX6Ak1Em5hIJdZ3QSIKG+REmor+QSCnad0VcACfU1SkJ9I5dQsOuMvgFIqG9REuo7uYSC3XfpO4CE+h4loX6QSyjY9VA/ACTUjygJ9ZNcQsGuh/oJIKF+RkmoX+QSCnY91C8ACfUrSkL9JkY0GXY91G8ACfU7SkL9IZdQsOuh/gBIKF8cSELFiBFNhl0PFRMX/RxjURLKL5dQsOuh/AAJFYeSUPFyCQW7HioeIKESUBIqj1xCwa6HygOQUHlREiqfXELBrofKB5BQ+VESqoBcQsGuhyoAkFDnoCRUQbmEgl0PVRAgoc5FSahCcgkFux6qEEBCnYeSUIXlEgp2PVRhgIQqgpJQReUSCnY9VFGAhDofJaGKySUU7HqoYgAJdQFKQl0ol1Cw66EuBEio4igJVUIuoWDXQ5UASKiSKAlVSi6hYNdDlQJIqIukOUoTbOT3+Vr65RP0YsHA44Jxx/vOPqT1qObTGQGkeVYF4VlFmGesML/OlPud5JYt2a7UVjf/GT0RPLpZcNlWrIfnJXGnv5amrzHSpDsSaRMhIXI6cBnBtjoKJhbr5w+az8KWoa9xwe95RdfoIM2FO0hzwQ6SffrI9EU4cti2DX3w6lsmmNRlQ1UpZAr/ICbse2WDRvl88r2WReysULn/SJAdtTTi7qoQty+PzmgdJ8MzMcjTlomTi7ms3CzNCuaNlfAi0sAgXSwkvbhU0AuNfsdJzQXNL6yhVsHNaVvlotwPzpdycfLjYLm46B7/ub3mCuP/ZVEedyWluC+P8rgrKsV9RZTH3cSvE3f5KI+7gpLfFaI87uuV/K4Y5XHXU4q7UpTH3VQp7sqCcfNcrwChQrA9rpFcL3js5HGE+xTnF2vNf7eX//8X4Yf0XPVKOW0DgudLAelzV+lc5znllQpz1SqCuR4bzPXwQ1JXDW2rxEU/x6rSHGOFCXLA5QRP5rktDlqaZ1VBjtVwOo/9N3eeagocTx3iV3Jyf3VUuZLDg4VRqI7WVUdrATp4YrRXR14UIV0dExWqY6IgxyRXHSE6TxJKdUzO/dUxUcNgHiySFapjiquONgWgg6dGe3XkpXjS1TFVoTqmCnJMc9URovOkoVTHQO6vjkkaBvNgEVCojumuOtp0gA5ePdqrIy8ulq6O1RWqY3VBjjVcdYToPDVQquNVub86JmsYzIPFVQrV8WpXHe3VAB38mmivjvx4lHR1vEahOl4jyPFaVx0hOs+1KNWxZu6vjikaBp8aeBSq43WuOtrrADp4rWivjqXj5KtjLYXqWEuQY21XHSE6T22U6lgn91fHVA2DebCoo1Ad67rqaOsCdPB60V4dOwUfAJdqL7R1hXTC1xcWMlaYH3d0QbNPDRz1FWYZ9QRnGQ3cLANiEGqAMstomPtnGWkaBvNg0VBhltHIzTJsI4AO3jjaZxmXKJyDN1aojo0FOTZx1RGi8zRBqY5NBaeX0bbPzn/a8ulUx6YK1fF6wcTx7vfF7ZZRSvbQQCw9cEoO7s2UdG0W1BV1JtIL4MW4zSUHU1SjRgIY1cIZZexoAKNaOqOMHQtgVCtnlLHjAIxq7YwydjyAUW2cUcZOADCqrTPK2IkARrVzRhk7CcCo9s4oYycDGNXBGWXsFACjOjqjjJ0KYFQnZ5Sx0wCM6uyMMnY6gFFdnFHGzgAwqqszytiZAEZ1c0YZOwvAqO7OKGNnAxiV4Ywydi6AUZnOKGPnARjVwxll7HwAo3o6o4xdAGBUljPK2IUARmU7o4xdBGBUL2eUsYsBjOrtjDJ2CYBRfZxRxi4FMKqvM8rYZQBG9XNGGbscwKj+zihjVwAYdYMzythVAEYNcEYZuwbAqIHOKGPXARh1ozPK2A0ARg1yRhm7EcCom5xRxm4CMOpmZ5SxmwGMGuyMMnYLgFFDnFHGbgUw6hZnlLHbAIy6VWsvmNgwohIbIEm1dZvgvjLemKX3vxma+/e/ibg1pcnZYXl7zzuEt/i8WGE/nWGCnS8uqGOM7+xDetBIlmvLePneHqdI+PY4+XaHCw5KWnEPjzsjsFC7EblKDPC8/6tfWINygoNofUG/i+XR9cPk7PjLjbNyGvcdgn4UU96ILccvSw72P+kClyLIcURcdOch58sIheJ7p9Kma3d6NrMLHdJ9aITgODQyTrcPmZwdauPQqOgch1QmxKENIaXa4xOooQp9crTwhJgPz/TnP0c0T4g1eSaC8BylXJNymqf85hQe76X7qV+wrVQFr2O0DB8h3PG95vh8OgPqMOEBdZjgiVr26ePPl+Rk2rahD159xwS5j40LJkdoNjQmWCW83xuruN1vyBjpHl88ys/WblOKu0QenYoRJ8MzMcjTjhGcEY8V7NiCeWMlvPAODNK5woP4GKWrTRqXiO8UvkScqfAWqLviol/HUcI69lDQcRyAjmOEdeypoOPdADreJaxjloKO4wF0vFtYx2wFHe+J8quXrOM9CnFPAIj7XoW47wWI+z6FuCcCxH2/Qtz3AcT9gELckwDiflAh7vsB4n5IIe7JAHE/rBD3AwBxP6IQ9xSAuB9ViPtBgLgfU4h7KkDcjyvE/RBA3HMU4p4GEPcTCnE/DBD3kwpxTweI+ymFuB8BiPtphbhnAMT9jELcjwLE/axC3DMB4n5OIe7HAOJ+XiHuWQBxv6AQ9+MAcb+oEPdsgLhfUoh7DkDcKxXingsQ92qFuJ8AiHutQtzzAOJerxD3kwBxv6wQ93yAuF9RiPspgLhfVYh7AUDcrynE/TRA3K8rxL0QIO43FOJ+BiDuNxXiXgQQ91sKcT8LEPfbCnEvBoj7HYW4nwOI+12FuJcAxP2eQtzPA8T9vkLcSwHi/kAh7hcA4v5QIe5lAHF/pBD3iwBxH1CIezlA3B8rxP0SQNyHFeJeARD3JwpxrwSI+1OFuFcBxH1cIe7VAHF/rhD3GoC4v1CIey1A3F8qxL0OIO6vFeJeDxD3twpxbwCI+3uFuF8GiPtHhbg3AsT9s0LcrwDE/atC3JsA4v5dIe5XAeL2KezbsRkg7liFuF8DiDtOIe4tAHEnKMT9OkDceRXi3goQd36FuN8AiPschbi3AcR9rkLcbwLEfZ5C3NsB4i6iEPdbAHGfrxD3DoC4L1CI+22AuIsrxL0TIO6SCnG/AxD3RQpx7xKMm08ZzyE0D7bHe8Tx/ma8NxfvK8V7IvH+QLxXDu8bw3uo8H4ivLcG7zPBey7w/gP8LD4/l87PaPPzyvzsLj/Hys908vON/KwfP/fGz4Dx81D8bBA/J8PPjPDzE/wsAa+r5zXmvN6a1x7zOlxek8rrM3mtIq/b4zVsvJ6L1zbxOh9e88LrP3gtBK8L4HvkfL+Y753yfUS+p8b3l/heC9934GvwfD2ar83ydUq+ZsfXr/haDl/X4HN8Pt/lcz8+D+JzAp4f81yR5008h+B6yrWFx1kec7j/cS6yL+GHX9j7d+W8TxHcTzKlRJTvacr7Sb6r0BffE+yLscG+GH5I6qqhraQGWhx3S3OMFSbIAUu+ioHb4qClee4W5Pg+Tuex/+bO874Cx1OHdHXck/uro8p7UXiw2KNQHT9w1dF+ANDB90Z7deSXokhXx70K1XGvIMcPXXWE6DwfolTHfbm/OiZqGMyDxT6F6viRq472I4AOvl+ao3Qi8UAReo2UZOB+wbZSBeM9IGxIrLAfPGAIJs2pAeiAwmxlv+Bs5aCbrUAMZgdRZisf5/7ZSpKGwTxYfKwwWznkZiv2EEAHPxzt5/I8R5c+lz+sUB0PC3I84qojROc5glIdP8n91TFZw2AeLD5RqI5HXXW0RwE6+KfRXh05QUcJV8dPFarjp4Icj7nqCNF5jqFUx+OCF1+i7a27obY0DObB4rhCdfxMMHFifGfe/s3tlvGdHtwQK2Yvf/Rz/Fyy06MaNRLAqBPOKGNHAxj1hTPK2LEARp10Rhk7DsCoL51Rxo4HMOorZ5SxEwCM+toZZexEAKO+cUYZOwnAqG+dUcZOBjDqO2eUsVMAjPreGWXsVACjfnBGGTsNwKgfnVHGTgcw6idnlLEzAIz62Rll7EwAo35xRhk7C8CoX51Rxs4GMOo3Z5SxcwGM+t0ZZew8AKP+cEYZOx/AKF+8M8ouADAqxhll7EIAo2KdUcYuAjDK74wydjGAUXHOKGOXABgV74wydimAUQnOKGOXARiVxxll7HIAo/I6o4xdAWBUPmeUsasAjMrvjDJ2DYBRBZxRxq4DMOocZ5SxGwCMKuiMMnYjgFHnOqOM3QRgVCFnlLGbAYw6zxll7BYAowo7o4zdCmBUEWeUsdsAjCrqjDJ2O4BR5zujjN0BYFQxZ5SxOwGMusAZZewuAKMudEbR1BfAqOLOKGN3AxhVwhll7B4Ao0o6o4zdC2BUKWeUsfsAjLrIGWXsfgCjLnZGGXsQwKhLnFHGHgIwqrQzytgjAEaVcUYZexTAqLLOKGOPARh1qTPK2M8AjCrnjDL2BIBRlzmjjD0JYNTlzihjvwIw6gpnlLHfABhV3hll7HcARlVwRhn7A4BRFZ1Rxv4EYFQlZ5SxvwAYVdkZZexvAEZd6Ywy9g8Ao6o4o4yNAXgNY1VnlLF+AKOqOaOMjQcwyjijjM0DYJR1RhmbD8CoRGeUsQUAjEpyRhlbEMCoZGeUsYUAjEpxRhlbGMCoVGeUsUUBjEpzRhlbDMCogDPK2AsBjEp3RhlbAsCo6s4oY0sBGFUjXp7jqcMfRjTJpCYnZ6UlZtkkm2ES0zMDKSY5JTM1YAM2JZDSMzGQlJQVSA6kpWemp5l0m5yUZbNT0pOyg41fJUfUFs8j2Bvl2jJxQYPjfWcf4udlPh3jxU/0QXgmCvOMFeY3gpLrDrkByY6ktkbFndETwaMDggNyrIfn1cEOew19jZEmPZxIp0RIiJwOqCmCbQ0XTCzWzx80n4UtQ1/jgt/ziq7RQUYLd5DRgh0k+/SR6Ytw5LBtG/rg1ffaYFLXjA+aETKFfxAT9r2aQaN8PvleGzImvN2cJm3VPLKjlnTcI5XirpZHZ7SOk+GZGORpr42Xi7mm4OxRMG+shBeRBgbpYiHpxXWCXmj0Oy6MXNCkz2C0Cm5O26oV5X5wvtSKlx8Hawmf+kr3uXLk8WWCExJur3mc/MTpMsFcrA3gyeXCnrRQ8ORyQU/qAHhyhbAnLRU8uULQk7oAnpQX9qSVgiflBT2pB+BJBWFPWit4UkHQk/oAnlQU9qSNgicVBT1pAOBJJWFP2ip4UknQk4YAnlQW9qSdgieVBT1pJOyJ+JYgFGt7hetTjQHi7qAQdxOAuDsqxN0UIO5OCnFfDxB3Z4W4mwHE3UUh7uYAcXdViLsFQNzdFOJuCRB3d4W4WwHEnaEQd2uAuDMV4m4DEHcPhbjbAsTdUyHudgBxZynE3R4g7myFuDsAxN1LIe6OAHH3Voi7E0DcfRTi7gwQd1+FuLsAxN1PIe6uAHH3V4i7G0DcNyjE3R0g7gEKcWcAxD1QIe5MgLhvVIi7B0DcgxTi7gkQ900KcWcBxH2zQtzZAHEPVoi7F0DcQxTi7g0Q9y0KcfcBiPtWhbj7CsbNa7kLEioE2+N1pryukdfR8botXifE61J4HQTfd+d70Hw/lu9N8n06vmfF92/4XgZf1+dr3Hy9l6998nVAvibG14f4WglfN+BzaD6f5HMrPs/gOTfPP3kuxvMSrtFcr3js5nGM+zTnN3vdN8Ljn9Jr0fvJaRsQfB4iUC3Kn8nhNeP9FNai9xfM9dhgrocfkrpqaCupgRbHG6Q5xgoT5IBrCT6sw21x0NI8bxDkOACn89h/c+cZoMDx1CFdHQfm/uqo8qQWDxYDFarjja462hsBOvigaK+OvOmJdHUcpFAdBwlyvMlVR4jOcxNKdbw591fHRA2DebC4WaE6DnbV0Q4G6OBDor068lZb0tVxiEJ1HCLI8RZXHSE6zy0o1fHW3F8dkzQM5sHiVoXqeJurjvY2gA4+NNqrI28eKF0dhypUx6GCHIe56gjReYahVMfbc391TNYwmAeL2xWq43BXHe1wgA5+R7RXR75iIl0d71CojncIchzhqiNE5xmBUh3vzP3VMUXDYB4s7lSojiNddbQjATr4qGivjrwxvHR1HKVQHUcJchztqiNE5xmNUh3H5P7qmKphMA8WYxSq41hXHe1YgA5+V7RXR34tzQiFV9NIJ/w4YSFjhflxRxc0+9TAMU5hlnGX4CzjbjfLgBiE7kaZZYzP/bOMNA2DebAYrzDLuMfNMuw9AB18QrTPMq5WOAefoFAdJwhyvNdVR4jOcy9KdZwoOL2MtvdohdrSMJgHi4kK1fE+wcTxvs+P2y2jlOyhgVh64JQc3Ccp6TopqCvqTKSXP/o53i85mMLetgEwarIzii6/Axj1gDOKrrIAGDXFGWXsOACjHnRGGTsewKipzii6JAFg1EPOKGMnAhg1zRll7CQAox52RtE5CoBR051RNPUFMOoRZxTNqACMmuGMokINYNSjziga/wGMmumMomEFwKjHnFGUrQBGzXJGkQgARj3ujDJ2NoBRs51Rxs4FMGqOM8rYeQBGzXVGGTsfwKgnnFHGLgAwap4zytiFAEY96YwydhGAUfOdUcYuBjDqKWeUsUsAjFrgjDJ2KYBRTzujjF0GYNRCZ5SxywGMesYZZewKAKMWOaOMXQVg1LPOKGPXABi12Bll7DoAo55zRhm7AcCoJc4oYzcCGPW8M8rYTQBGLXVGGbsZwKgXnFHGbgEwapkzytitAEa96IwydhuAUcu19oKJDSMqsQGSVFsvCe4r441Zev+bFbl//5uIW1OanB2Wt/c8LrzF51UK++msFOx8cUEdY3xnH9KDRrpcW8bLd1W8IuFV8fLtrhYclLTiXh1/RmChdiNylRjgef9Xv7AGtQQH0XGCfrfOo+uHydnxlxtn5TTuNYJ+tFbeiC2nsVYP9j/pAlddkOPa+OjOQ86XtQrFd53SpmvrPJvZhQ7pPrRWcBxaH6/bh0zODrVxaEN0jkMqE+LQhpBS7fEJ1AqFPvmy8ISYj9BX7xHNE2JNnmkgPDco16Sc5mkN3+nxXrqf+gXbqqHgdYyW4WuFO77XHJ9PZ0BdKTygrhQ8Ucs+ffz5kpxM2zb0wavvxiD3V+KDyRGaDW0MVgnv915R3O43ZIx0j28X5WdrLynF3T6PTsWIk+GZGORpNwrOiF8R7NiCeWMlvPAODNK5woP4RqWrTRqXiD8XvkR8l8JboDbFR7+OJ4R1HKeg46sAOn4hrOPdCjpuBtDxpLCO4xV0fA1Axy+FdbxHQcctADp+JazjBAUdXwfQ8WthHe9V0HErgI7fCOs4UUHHNwB0/FZYx/sUdNwGoON3wjpOUtDxTQAdvxfW8X4FHbcD6PiDsI6TFXR8C0DHH4V1fEBBxx0AOv4krOMUBR3fBtDxZ2EdH1TQcSeAjr8I6zhVQcd3AHT8VVjHhxR03AWg42/COk5T0PFdAB1/F9bxYQUd3wPQ8Q9hHacr6LgbQEdfvKyOjyjo+D6AjjHCOs5Q0HEPgI6xwjo+qqDjBwA6+oV1nKmg414AHeOEdXxMQccPAXSMF9ZxloKO+wB0TBDW8XEFHT8C0DGPsI6zFXTcD6BjXmEd5yjoeABAx3zCOs5V0PEggI75hXV8QkHHjwF0LCCs4zwFHQ8B6HiOsI5PKuh4GEDHgsI6zlfQ8QiAjucK6/iUgo6fAOhYSFjHBQo6HgXQ8TxhHZ9W0PFTAB0LC+u4UEHHYwA6FhHW8RkFHY8D6FhUWMdFCjp+BqDj+cI6Pqug4+cAOhYT1nGxgo4nAHS8QFjH5xR0/AJAxwuFdVyioONJAB2LC+v4vIKOXwLoWEJYx6UKOn4FoGNJYR1fUNDxawAdSwnruExBx28AdLxIWMcXFXT8FkDHi4V1XK6g43cAOl4irONLCjp+D6BjaWEdVyjo+AOAjmWEdVypoOOPADqWFdZxlYKOPwHoeKmwjqsVdPwZQMdywjquUdDxFwAdLxPWca2Cjr8C6Hi5sI7rFHT8DUDHK4R1XK+g4+8AOpYX1nGDgo5/AOhYQVjHlxV09CVEv44VhXXcqKBjDICOlYR1fEVBx1gAHSsL67hJQUc/gI5XCuv4qoKOcQA6VhHWcbOCjvEAOlYV1vE1BR0TAHSsJqzjFgUd8wDoaIR1fF1Bx7wAOlphHbcq6JgPQMdEYR3fUNAxP4COScI6blPQsQCAjsnCOr6poOM5ADqmCOu4XUHHggA6pgrr+JaCjucC6JgmrOMOBR0LAegYENbxbQUdzwPQMV1Yx50KOhYG0LG6sI7vKOhYBEDHGsI67lLQsaigjvzeqnMJzYPt8TtZ+H0i/C4Mfo8Dv4OA98/fSuB9y3nPbd4vmvc65n16eY9Z3h+V9/bkfSl5T0XeD5D3suN92HgPMd7/ivdu4n2HeM8c3u+F9yrhfTZ4jwje34CfzefnyvmZaH6el59F5eco+RlAfn7tOIGfG+JnXvh5DX7WgNfJ8xpvXp/Ma2t5XSivaeT1eLyWjNdB8RoeXn/Cayf4vj/fs+b7rXyvkO9z8T0avr/A18b5ui5fk+TraXwtiK9j8Dk4nz/yuQ/P23nOyfMlrvVcp3iM5fGBc5t9CT/8wt6fL+d9iuD7m1LaR/k7xPj9TayddF8sJtgXY4N9MfyQ1FVD22IJ0c/xAmmO0sWHA5Z89TG3xUFL8/QKmVOOF+J0Hvtv7jwXKnA8dUhXx+K5vzqqvIecB4viCtWxhKuOtgRABy8Z7dWRX0IuXR1LKlTHkoLVsZSrjhCdpxRKdbwo91fHRA2DebC4SKE6Xuyqo70YoINfIs1RfEEitVHDd/aAYXJ2WL9gWzUE4y2tfCFZYnYhmDSnBqDSCrOVSwRnK2XcbAViMCuDMlspm/tnK0kaBvNgUVZhtnKpm63YSwE6eLloP5dP88mfy5dTqI7lBKvjZa46QnSey1Cq4+W5vzomaxjMg8XlCtXxClcd7RUAHbx8tFdHTtANwtWxvEJ1LC9YHSu46gjReSR98qGOcr380c+xojPK2JEARlVyRhk7GsCoys4oY8cCGHWlM8rYcQBGVXFGGTsewKiqzihjJwAYVc0ZZexEAKOMM8rYSQBGWWeUsZMBjEp0Rhk7BcCoJGeUsVMBjEp2Rhk7DcCoFGeUsdMBjEp1Rhk7A8CoNGeUsTMBjAo4o4ydBWBUujPK2NkARlV3Rhk7F8CoGs4oY+cBGHWVM8rY+QBGXe2MMnYBgFHXOKOMXQhg1LXOKGMXARhV0xll7GIAo65zRhm7BMCoWs4oY5cCGFXbGWXsMgCj6jijjF0OYFRdZ5SxKwCMqueMMnYVgFH1nVHGrgEwqoEzyth1AEY1dEYZuwHAqEbOKGM3AhjV2Bll7CYAo5o4o4zdDGBUU2eUsVsAjLreGWXsVgCjmjmjjN0GYFRzZ5Sx2wGMauGMMnYHgFEtnVHG7gQwqpUzythdAEa1dkYZWxjAqDbOKGN3AxjV1hll7B4Ao9o5o4zdC2BUe2eUsfsAjOrgjDJ2P4BRHZ1Rxh4EMKqTM8rYQwBGdXZGGXsEwKguzihjjwIY1dUZZewxAKO6OaOM/QzAqO7OKGNPABiV4Ywy9iSAUZnOKGO/AjCqhzPK2G8AjOrpjDL2OwCjspxRxv4AYFS2M8rYnwCM6uWMMvYXAKN6O6OM/Q3AqD7OKGP/ADCqrzPK2Ji46OfYzxllrB/AqP7OKGPjAYy6wRllbB4AowY4o4zNB2DUQGeUsQUAjLrRGWVsQQCjBjmjjC0EYNRNzihjCwMYdbMzytiiAEYNdkYZWwzAqCHOKGMvBDDqFmeUsSUAjLrVGWVsKQCjbpM0Ki5IMP5sr8SJp/vkxdXgGQDhmSbMM1aY31pKqjXxcu2tp7Y2eBIVwaPSgp011sNzaMLpr8Poa4w06dUkcvUICZFkUpOTs9ISs2ySzTCJ6ZmBFJOckpkasAGbEkjpmRhISsoKJAfS0jPT00y6TU7Kstkp6UnZwYarC7a1WjCxWD9/0HwWtgx9jQt+zyu6Rgd5WbiDvCzYQbJPH5m+CEcO27ahD159bw8m9fCEoBkhU/gHMWHfGx40yueT77UhY8LbzWnS+vPKjlrSca9Xijsur85oHSfDMzHI096eIBfzcLmR3wrmjZXwItLAIF0sJL24Q9ALjX7HhZELml9YQ62Cm9O2RkS5H5wvIxLkx8ERCbLjoHSfq0Ue1xackHB798fLT5xqC+binQCe1BH2ZLKCJ3UEPRkJ4EldYU8eUPCkrqAnowA8qSfsyRQFT+oJejIawJP6wp48qOBJfUFPxgB40kDYk6kKnjQQ9GQsgCcNhT15SMGThoKe3AXgSSNhT6YpeNJI0JNxAJ40FvbkYQVPGgt6cjeAJ02EPZmu4EkTQU/GA3jSVNiTRxQ8aSroyT0Anlwv7MkMBU+uF/RkAoAnzYQ9eVTBk2aCntwL4ElzYU9mKnjSXNCTiQCetBD25DEFT1oIenIfgCcthT2ZpeBJS0FPJgF40krYk8cVPGkl6Mn9AJ60FvZktoInrQU9mQzgSRthT+YoeNJG0JMHADxpK+zJXAVP2gp6MgXAk3bCnjyh4Ek7QU8eBPCkvbAn8xQ8aS/oyVQATzoIe/KkgicdBD15CMCTjsKezFfwpKOgJ9MAPOkk7MlTCp50EvTkYQBPOgt7skDBk86CnkwH8KSLsCdPK3jSRdCTRwA86SrsyUIFT7oKejIDwJNuwp48o+BJN0FPHgXwpLuwJ4sUPOku6MlMAE8yhD15VsGTDEFPHgPwJFPYk8UKnmQKejILwJMewp48p+BJD0FPHgfwpKewJ0sUPOkp6MlsAE+yhD15XsGTLEFP5gB4ki3syVIFT7IFPZkL4EkvYU9eUPCkl6AnTwB40lvYk2UKnvQW9GQegCd9hD15UcGTPoKePAngSV9hT5YreNJX0JP5gp7wXgqFCBWC7fFz3vxcMT/Hys9N8nN6/FwYP4fEz73wcxa8rp/XkfO6ZV4ny+syeR0grzvjdU68robXcfC6Ab5PzfdF+T4c3/fh+wx8XZuvo/J1O75OxNcl+DyYz7t4ns/zSp7HcN3kcZrHBc7D+cGNb7yH9F4QT8lpGxDcjyQQF+V74vCeDU8p7AWxQHhnsEJnp5CorhraSmqgxfFpaY7SAzAHPEJwsxxui4OW5vm0IMeFOJ3H/ps7z0IFjqcO6er4TO6vjio7JfFg8YxCdVzkqqNdBNDBn4326sibDktXx2cVquOzghwXu+oI0XkWo1TH53J/dUzUMJgHi+cUquMSVx3tEoAO/ny0V0fe6l66Oj6vUB2fF+S41FVHiM6zFKU6vpD7q2OShsE8WLygUB2XuepolwF08BejvTqWTpCvji8qVMcXBTkud9URovMsR6mOL+X+6pisYTAPFi8pVMcVrjraFQAdfGW0V0d+/Zh0dVypUB1XCnJc5aojROdZhVIdV+f+6piiYTAPFqsVquMaVx3tGoAOvjbaq+MwhXPHtQrVca0gx3WuOkJ0nnUo1XF97q+OqRoG82CxXqE6bnDV0W4A6OAvR3t15NdCrxV8uCH0amjphN8oLGSsMD/u6IJmnxo4NirMMl4WnGW84mYZEIPQKyizjE25f5aRpmEwDxabFGYZr7pZhn0VoINvjvZZxlCFc/DNCtVxsyDH11x1hOg8r0lzlCYY6jzSyS7ZIbcIisj6+YM6crtlfKdjR6wevfzRz/F1yQ6AatRIAKO2OqOMHQ1g1BvOKGPHAhi1zRll7DgAo950Rhk7HsCo7c4oYycAGPWWM8rYiQBG7XBGGTsJwKi3nVHGTgYwaqczytgpAEa944wydiqAUbucUcZOAzDqXWeUsdMBjHrPGWXsDACjdjujjJ0JYNT7zihjZwEYtccZZexsAKM+cEYZOxfAqL3OKGPnARj1oTPK2PkARu1zRhm7AMCoj5xRxi4EMGq/M8rYRQBGHXBGGbsYwKiDzihjlwAY9bEzytilAEYdckYZuwzAqMPOKGOXAxh1xBll7AoAoz5xRhm7CsCoo84oY9cAGPWpM8rYdQBGHXNGGbsBwKjjzihjNwIY9ZkzythNAEZ97owydjOAUSecUcZuATDqC2eUsVsBjDrpjDJ2G4BRX2rtbhUbRjSne2RIBn21Tydo6ZhjBGO+BiTmWMGYrwWJ2S8Yc81/KGaTs8NeJ6hfLb9OzNKDbS0fBs/aIDzrgPCsC8KzHgjP+iA8G4DwbAjCsxEIz8YgPJuA8GwKwvN6EJ7NQHg2B+HZAoRnSxCerUB4tgbh2QaEZ1sQnu1AeLYH4dkBhGdHEJ6dQHh2BuHZBYRnVxCe3UB4dgfhmQHCMxOEZw8Qnj1BeGaB8MwG4dkLhGdvEJ59QHj2BeHZD4RnfxCeN4DwHADCcyAIzxtBeA4C4XkTCM+bQXgOBuE5BITnLSA8bwXheRsIz6EgPIeB8LwdhOdwEJ53gPAcAcLzThCeI0F4jgLhORqE5xgQnmNBeN4FwnMcCM+7QXiOB+F5DwjPCSA87wXhORGE530gPCeB8LwfhOdkEJ4PgPCcAsLzQRCeU0F4PgTCcxoIz4dBeE4H4fkICM8ZIDwfBeE5E4TnYyA8Z4HwfByE52wQnnNAeM4F4fkECM95IDyfBOE5H4TnUyA8F4DwfBqE50IQns+A8FwEwvNZEJ6LQXg+B8JzCQjP50F4LgXh+QIIz2UgPF8E4bkchOdLIDxXgPBcCcJzFQjP1SA814DwXAvCcx0Iz/UgPDeA8HwZhOdGEJ6vgPDcBMLzVRCem0F4vgbCcwsIz9dBeG4F4fkGCM9tIDzfBOG5HYTnWyA8d4DwfBuE504Qnu+A8NwFwvNdEJ7vgfDcDcLzfRCee0B4fgDCcy8Izw9BeO4D4fkRCM/9IDwPgPA8CMLzYxCeh0B4HgbheQSE5ycgPI+C8PwUhOcxEJ7HQXh+BsLzcxCeJ0B4fgHC8yQIzy9BeH4FwvNrEJ7fgPD8FoTndyA8vwfh+QMIzx9BeP4EwvNnEJ6/gPD8FYTnbyA8fwfh+QcIT24QgWcMCM9YEJ5+EJ5xIDzjQXgmgPDMA8IzLwjPfCA884PwLADC8xwQngVBeJ4LwrMQCM/zQHgWBuFZBIRnURCe54PwLAbC8wIQnheC8CwOwrMECM+SIDxLgfC8CITnxSA8LwHhWRqEZxkQnmVBeF4KwrMcCM/LQHheDsLzCmGescL8RiT4fHcmnGkvyaQmJ2elJWbZJJthEtMzAykmOSUzNWADNiWQ0jMxkJSUFUgOpKVnpqeZdJuclGWzU9KTsoMNcnuvJ8jzLB8jx9Ebr8nhoeXJSGFPtip4UkHQk5EAnowS9uQNBU8qCnoyCsCT0cKebFPwpJKgJ6MBPBkj7MmbCp5UFvRkDIAnY4U92a7gyZWCnowF8OQuYU/eUvCkiqAndwF4Mk7Ykx0KnlQV9GQcgCd3C3vytoIn1QQ9uRvAk/HCnuxU8MQIejIewJN7hD15R8ETK+jJPQCeTBD2ZJeCJ4mCnkwA8OReYU/eVfAkSdCTewE8mSjsyXsKniQLejIRwJP7hD3ZreBJiqAn9wF4MknYk/cVPEkV9GQSgCf3C3uyR8GTNEFP7gfwZLKwJx8oeBIQ9GQygCcPCHuyV8GTdEFPHgDwZIqwJx8qeFJd0JMpAJ48KOzJPgVPagh68iCAJ1OFPflIwZOrBD2ZCuDJQ8Ke7Ffw5GpBTx4C8GSasCcHFDy5RtCTaQCePCzsyUEFT64V9ORhAE+mC3vysYInNQU9mQ7gySPCnhxS8OQ6QU8eAfBkhrAnhxU8qSXoyQwATx4V9uSIgie1BT15FMCTmcKefKLgSR1BT2YCePKYsCdHFTypK+jJYwCezBL25FMFT+oJejILwJPHhT05puBJfUFPHgfwZLawJ8cVPGkg6MlsAE/mCHvymYInDQU9mQPgyVxhTz5X8KSRoCdzATx5QtiTEwqeNBb05AkAT+YJe/KFgidNBD2ZB+DJk8KenFTwpKmgJ08CeDJf2JMvFTy5XtCT+cqe5JTf2nifr6KgJ+upvU3x8vsMNIuJfh0rCev4qoKOzQF0rCys42YFHVsA6HilsI6vKejYEkDHKsI6blHQsRWAjlWFdXxdQcfWADpWE9Zxq4KObQB0NMI6vqGgY1sAHa2wjtsUdGwHoGOisI5vKujYHkDHJGEdtyvo2AFAx2RhHd9S0LEjgI4pwjruUNCxE4COqcI6vq2gY2cAHdOEddypoGMXAB0Dwjq+o6BjVwAd04V13KWgYzcAHasL6/iugo7dAXSsIazjewo6ZgDoeJWwjrsVdMwE0PFqYR3fV9CxB4CO1wjruEdBx54AOl4rrOMHCjpmAehYU1jHvQo6ZgPoeJ2wjh8q6NgLQMdawjruU9CxN4COtYV1/EhBxz4AOtYR1nG/go59AXSsK6zjAQUd+wHoWE9Yx4MKOvYH0LG+sI4fK+h4A4CODYR1PKSg4wAAHRsK63hYQceBADo2EtbxiIKONwLo2FhYx08UdBwEoGMTYR2PKuh4E4COTYV1/FRBx5sBdLxeWMdjCjoOBtCxmbCOxxV0HAKgY3NhHT9T0PEWAB1bCOv4uYKOtwLo2FJYxxMKOt4GoGMrYR2/UNBxKICOrYV1PKmg4zAAHdsI6/ilgo63A+jYVljHrxR0HA6gYzthHb9W0PEOAB3bC+v4jYKOIwB07CCs47cKOt4JoGNHYR2/U9BxJICOnYR1/F5Bx1EAOnYW1vEHBR1HA+jYRVjHHxV0HAOgY1dhHX9S0HEsgI7dhHX8WUHHuwB07C6s4y8KOo4D0DFDWMdfFXS8G0DHTGEdf1PQcTyAjj2EdfxdQcd7AHTsKazjHwo6TgDQMUtYR1+CvI73AuiYLaxjjIKOEwF07CWsY6yCjvcB6NhbWEe/go6TAHTsI6xjnIKO9wPo2FdYx3gFHScD6NhPWMcEBR0fANCxv7COeRR0nAKg4w3COuZV0PFBAB0HCOuYT0HHqQA6DhTWMb+Cjg8B6HijsI4FFHScBqDjIGEdz1HQ8WEAHW8S1rGggo7TAXS8WVjHcxV0fARAx8HCOhZS0HEGgI5DhHU8T0HHRwF0vEVYx8IKOs4E0PFWYR2LKOj4GICOtwnrWFRBx1nCOoYOaZ6Pg/CcDcJzDgjPuSA8nwDhOQ+E55MgPOeD8HwKhOcCEJ5Pg/BcCMLzGRCei0B4PgvCczEIz+dAeC4B4fk8CM+lIDxfAOG5DITniyA8l4PwfAmE5woQnitBeK4C4bkahOcaEJ5rQXiuA+G5HoTnBhCeL4Pw3AjC8xUQnptAeL4KwnMzCM/XQHhuAeH5OgjPrSA83wDhuQ2E55sgPLeD8HwLhOcOEJ5vg/DcCcLzHRCeu0B4vgvC8z0QnrtBeL4PwnMPCM8PQHjuBeH5IQjPfSA8PwLhuR+E5wEQngdBeH4MwvMQCM/DIDyPgPD8BITnURCen4LwPAbC8zgIz89AeH4OwvMECM8vQHieBOH5JQjPr0B4fg3C8xsQnt+C8PwOhOf3IDx/AOH5IwjPn0B4/gzC8xcQnr+C8PwNhOfvIDz/AOHpi8XgGQPCMxaEpx+EZxwIz3gQngkgPPOA8MwLwjMfCM/8IDwLgPA8B4RnQRCe54LwLATC8zwQnoVBeBYB4VkUhOf5IDyLgfC8AITnhSA8i4PwLAHCsyQIz1IgPC8C4XkxCM9LQHiWBuFZBoRnWRCel4LwLAfC8zIQnpeD8LwChGd5EJ4VQHhWBOFZCYRnZRCeV4LwrALCsyoIz2ogPA0ITwvCMxGEZxIIz2QQnikgPFNBeKaB8AyA8EwH4VkdhGcNEJ5XgfC8GoTnNSA8rwXhWROE53UgPGuB8KwNwrMOCM+6IDzrgfCsD8KzAQjPhiA8G4HwbAzCswkIz6YgPK8H4dkMhGdzEJ4tQHi2BOHZCoRnaxCebUB4tgXh2Q6EZ3sQnh1AeHYE4dkJhGdnEJ5dQHh2BeHZDYRndxCeGSA8M0F49gDh2ROEZxYIz2wQnr1AePYG4dkHhGdfEJ79QHj2B+F5AwjPASA8B4LwvBGE5yAQnjeB8LwZhOdgEJ5DQHjeAsLzVhCet4HwHArCcxgIz9tBeA4H4XkHCM8RIDzvBOE5EoTnKBCeo0F4jgHhORaE510gPMeB8LwbhOd4EJ73gPCcAMLzXhCeE0F43gfCcxIIz/tBeE4G4fkACM8pIDwfBOE5FYTnQyA8p4HwfBiE53QQno+A8JwBwvNREJ4zQXg+BsJzFgjPx0F4zgbhOQeE51wQnk+A8JwHwvNJEJ7zQXg+BcJzAQjPp0F4LgTh+QwIz0UgPJ8F4bkYhOdzIDyXgPB8HoTnUhCeL4DwXAbC80UQnstBeL4EwnMFCM+VIDxXgfBcDcJzDQjPtSA814HwXA/CcwMIz5dBeG4E4fkKCM9NIDxfBeG5GYTnayA8t4DwfB2E51YQnm+A8NwGwvNNEJ7bQXi+BcJzBwjPt0F47gTh+Q4Iz10gPN8F4fkeCM/dIDzfB+G5B4TnByA894Lw/BCE5z4Qnh+B8NwPwvMACM+DIDw/BuF5CITnYRCeR0B4fgLC8ygIz09BeB4D4XkchOdnSjxjw3gmmdTk5Ky0xCybZDNMYnpmIMUkp2SmBmzApgRSeiYGkpKyAsmBtPTM9DSTbpOTsmx2SnpSdrDt8oIxfy4cs3SsQxN8vhEJcvFyWxsJfuHcORErF7M33py2tTEBI6fjBL34AqQfxwvGfBIk5gTBmL8EiTmPYMxfgcScVzDmr0FizicY8zcgMecXjPlbkJgLCMb8HUjM5wjG/D1IzAUFY/4BJOZzBWP+ESTmQoIx/wQS83mCMf8MEnNhwZh/AYm5iGDMv4LEXFQw5t9AYj5fMObfQWIuJhjzHyAxXyAYM18EQ4j5QsGYY0BiLi4YcyxIzCUEY/aDxFxSMOY4kJhLCcYcDxLzRYIxJ4DEfLFgzHlAYr5EMOa8IDGXFow5H0jMZQRjzg8Sc1nBmAuAxHypYMzngMRcTjDmgiAxXyYY87kgMV8uGHMhkJivEIz5PMGY/cFYdwUDvppwDeHaIN/rCLUItQl1CHUJ9Qj1CQ0IDQmNCI0JTQhNCdcTmhGaE1oQWhJaEVoT2hDaEtoR2hM6EDoSOhE6E7oQuhK6EboTMgiZhB6EnoQsQjahF6E3oQ+hL6EfoT/hBsIAwkDCjYRBhJsINxMGE4YQbiHcSriNMJQwjHA7YTjhDsIIwp2EkYRRhNGEMYSxhLsI4wh3E8YT7iFMINxLmEi4jzCJcD9hMuEBwhTCg4SphIcI0wgPE6YTHiHMIDxKmEl4jDCL8DhhNmEOYS7hCcI8wpOE+YSnCAsITxMWEp4hLCI8S1hMeI6whPA8YSnhBcIywouE5YSXCCsIKwmrCKsJawhrCesI6wkbCC8TNhJeIWwivErYTHiNsIXwOmEr4Q3CNsKbhO2Etwg7CG8TdhLeIewivEt4j7Cb8D5hD+EDwl7Ch4R9hI8I+wkHCAcJHxMOEQ4TjhA+IRwlfEo4RjhO+IzwOeEE4QvCScKXhK8IXxO+IXxL+I7wPeEHwo+Enwg/E34h/Er4jfA74Q8CL/SLIcQS/IQ4QjwhgZCHkJeQj5CfUIBwDqEg4VxCIcJ5hMKEIoSihPMJxQgXEC4kFCeUIJQklCJcRLiYcAmhNKEMoSzhUkI5wmWEywlXEMoTKhAqEioRKhOuJFQhVCVUIxiCJSQSkgjJhBRCKiGNECCkE6oTahCuIlxNuIZwLaEm4TpCLUJtQh1CXUI9Qn1CA0JDQiNCY0ITQlPC9YRmhOaEFoSWhFaE1oQ2hLaEdoT2hA6EjoROhM6ELoSuhG6E7oQMQiahB6EnIYuQTehF6E3oQ+hL6EfoT7iBMIAwkHAjYRDhJsLNhMGEIYRbCLcSbiMMJQwj3E4YTriDMIJwJ2EkYRRhNGEMYSzhLsI4wt2E8YR7CBMI9xImEu4jTCLcT5hMeIAwhfAgYSrhIcI0wsOE6YRHCDMIjxJmEh4jzCI8TphNmEOYS3iCMI/wJGE+4SnCAsLThIWEZwiLCM8SFhOeIywhPE9YSniBsIzwImE54SXCCsJKwirCasIawlrCOsJ6wgbCy4SNhFcImwivEjYTXiNsIbxO2Ep4g7CN8CZhO+Etwg7C24SdhHcIuwjvEt4j7Ca8T9hD+ICwl/AhYR/hI8J+wgHCQcLHhEOEw4QjhE8IRwmfEo4RjhM+I3xOOEH4gnCS8CXhK8LXhG8I3xK+I3xP+IHwI+Enws+EXwi/En4j/E74g8CFMYYQS/AT4gjxhARCHkJeQj5CfkIBwjmEgoRzCYUI5xEKE4oQihLOJxQjXEC4kFCcUIJQklCKcBHhYsIlhNKEMoSyhEsJ5QiXES4nXEEoT6hAqEioRKhMuJJQhVCVUI1gCJaQSEgiJBNSCKmENEKAkE6oTqhBuIpwNeEawrWEmoTrCLUItQl1CHUJ9Qj1CQ0IDQmNCI0JTQhNCdcTmhGaE1oQWhJaEVoT2hDaEtoR2hM6EDoSOhE6E7oQuhK6EboTMgiZhB6EnoQsQjahF6E3oQ+hL6EfoT/hBsIAAr+znt8Hz+9a5/eY8zvC+f3b/G5rfm80v5OZ33fM7xLm9/TyO3D5/bL87lZ+Lyq/c3Qkgd+Vye+h5Hc88vsT+d2E/N4/fqcev6+O3wXH71njd5jx+8H43Vv8Xit+ZxS/j4nfdcTvEeJ39PD7b/jdMvzeFn4nCr9vhN/lwe/J4HdQ8Psd+N0J/F4C3vN/NoH3qud94HmPdd6/nPcG5323eU9r3i+a92LmfY55D2Hen5f3vuV9ZXnPVt4Plfca5X08eY9M3n+S93bkfRN5T0Le74/30uN96ngPON5fjfcu433BeM+tDQTeK4r3YeI9jnj/IN6bh/e94T1leL8W3guF9xnhPTx4fwzee4L3deA9E3g/An7Wn5+j52fUeY7Jz1bzc8v8TDA/b8vPsvJzovwMJj/fyM8O8nN5/MzbAQI/q8XPQfEzRvz8Dj8bw8+d8DMd/LwEP4vA6/x5DT2vKef10LwOl9el8jpNXrfI6/h4XRuv8+J1T7wOiNfF8DoRXjfB6wj4vjrfZ+b7rnwfku/L8X0qvm/D9zH4uj5f5+brvnwdlK8L8nUyvm7E11H4ugKfZ/N5J5+H8XkJz9NjT08jfLzOmI+rfWeO4BBzak04/5zX5fI6VV63yesYeV0fr3PjdV+8DorXBfE6GV43wusoeF0B32fn+858H5bvS/J9Or5vxfdx+L4GX+fn6958HZivi/J1Qr5uVoZQlnApgc+7+TyUz8v4PIXX+VcgVCRUIlQmXEmoQqhKqEbgkyVLSCQkEZIJKYRUQhohQEgnVCfUIFzlO/so6vmcFvxa7PB1JQZtfaqu9/eu+Zuf1fubn7X9m591DX794ONdLW8cOKyZ92ej/+b/8Rzrr/5fRsxf/78ef/OzaX/zszl/8/e4xvzV/+sX+9f/b8Pf/L+Nf/Oz7/7mZ6EHGyL9vc1/87OScZHbDPWXUsGv+YJfgxRO9R1utmbw3yZnh83naVe6/YBJDuTz/fkQ5p+UL9hmvE77yaH2E3TaP7VWnY86I8+0740l9HdDz8/UG3lGy3oj/8wp9Dv1Pb9T3/M7fBQMfo458yv/+duhn8V6flY37Gd+39l/P/SzON/Zf5fH88K+M5+LBD/nC+OhkXfeWKR9KxqBf+hvFQjGWiz4b65hZYKfBwwc3Cd7aN0Bg4ZkDcnq2XxIZv8+PeoNGdBjcJ+BA2pn9O/vCzu8mob7Fu5VuD9eT+J8f314/1+MJ4ZQ340b+effqxn8vsnBkRYwJvS3/MH2431/5u8L+/vxYb9fMvjv/GHcQ3HX/D/yzE7LsNlJGdkZKRk9eyb3yCgS1j4fXq87Bj+Dj9WZ/9RYrTSWpoTaz6PTfsSx2htL6OehHA6Nnd7P/9Ox2vs7DTy/08DzO3z80+N56GfxvrM5ecc8/nyBhyMfDUee4R4T9rNGnp+F+ObznT02CeZ7er6wOIXzJbFoBP6hvxWqEdV9f9Y1lE+h3/fqoJTXSTFhf8/nO7seeP9+fp9qP7YxYX8vxCdcn1CecH0NnVP1oBra/KY+t2QMzgqVVW8I3mZjI4TolcD7O950z0kZDv07PkK7f/X/w7/3d10/5i+++iL8f5+H93m+s6czCWF/J1bg72h2aT7O80We9nn/tlJ3T4k0NPrCNPR2mXAfvd07PDd9EfT1eX4nFJP3MdCCEX4vnI/XB++phjeOSH75fWdrGR/G8a+GvtD3lU/dUiMNqeHxezUP9yOv52f/Wz9CMf1v/fBqlCfsZ+HTPu/PvPy8JSbap/DXBv/9/z2F95biQr6zczcm7Gden8LHNqV8TgzxCOVzSOu/6oeR+Pjk+Nj4MD4Ngl9Zy9Zh2nn7YPjY4PP9OX+9ue/9fe/YGYq3UIQY84TF//8xTfH6ET7mh8aVhL/4/VB78WG/3zz4lf/dLvg5Ut32h/0sNkLbkcaUkIbcH6T7Y4+U1MweySkZJsvyPxP/u/4o/ffpT6f1yEizNj3ZZiXblP/u74fGzdDXYmH6/l95hB3/OaU/X6d9481NX1gs3r8bfunCJ8gh1F4oLyPNj8Ln2aHfzRvGL0aenw3nEmn+GjpCpxnne77nPeX1cvXmsGQdCLVfQKf9iDmT3/O5QNjPQt5FusQY8xf/jg37+ne/G/M37RaM8LNQmyGvvHxDcfwXWM00H+v0BwA=",
      "debug_symbols": "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",
      "brillig_names": [
        "notify_enqueued_public_function_call_wrapper",
        "call_private_function_internal",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAABAA==",
      "debug_symbols": "XYxLCoAwDAXvkrUn8Coi0k9aAqEpsRWk9O5+cCFdzhveNPBoa9woBdlhXhqwOFNI0k2tT2CVmCluw3wYJWMZPww1uZ8tZ8bhn1Uc+qr4lF7X134B",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "app_payload",
                    "type": {
                      "fields": [
                        {
                          "name": "function_calls",
                          "type": {
                            "kind": "array",
                            "length": 4,
                            "type": {
                              "fields": [
                                {
                                  "name": "args_hash",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "function_selector",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                  }
                                },
                                {
                                  "name": "target_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "is_public",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                },
                                {
                                  "name": "is_static",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::entrypoint::function_call::FunctionCall"
                            }
                          }
                        },
                        {
                          "name": "nonce",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::entrypoint::app::AppPayload"
                    }
                  }
                ],
                "kind": "struct",
                "path": "MultiCallEntrypoint::entrypoint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "MultiCallEntrypoint::entrypoint_abi"
        }
      ]
    }
  },
  "file_map": {
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "143": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "270": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "288": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "305": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "363": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/multi_call_entrypoint_contract/src/main.nr",
      "source": "// An entrypoint contract that allows everything to go through. Only used for testing\n// Pair this with SignerlessWallet to perform multiple actions before any account contracts are deployed (and without authentication)\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract MultiCallEntrypoint {\n    use dep::authwit::entrypoint::app::AppPayload;\n    use dep::aztec::macros::functions::private;\n\n    #[private]\n    fn entrypoint(app_payload: AppPayload) {\n        app_payload.execute_calls(&mut context);\n    }\n}\n"
    },
    "55": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr",
      "source": "use dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\n#[derive(Serialize)]\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    pub nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage()\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "68": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
