import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { DEPLOYER_CONTRACT_INSTANCE_UPDATED_TAG, ProtocolContractAddress } from '../protocol_contract_data.js';
/** Event emitted from the ContractInstanceDeployer. */ export class ContractInstanceUpdatedEvent {
    address;
    prevContractClassId;
    newContractClassId;
    blockOfChange;
    constructor(address, prevContractClassId, newContractClassId, blockOfChange){
        this.address = address;
        this.prevContractClassId = prevContractClassId;
        this.newContractClassId = newContractClassId;
        this.blockOfChange = blockOfChange;
    }
    static isContractInstanceUpdatedEvent(log) {
        return log.contractAddress.equals(ProtocolContractAddress.ContractInstanceDeployer) && log.log[0].equals(DEPLOYER_CONTRACT_INSTANCE_UPDATED_TAG);
    }
    static fromLog(log) {
        const bufferWithoutAddressAndTag = log.toBuffer().subarray(64);
        const reader = new BufferReader(bufferWithoutAddressAndTag);
        const address = reader.readObject(AztecAddress);
        const prevContractClassId = reader.readObject(Fr);
        const newContractClassId = reader.readObject(Fr);
        const blockOfChange = reader.readObject(Fr).toNumber();
        return new ContractInstanceUpdatedEvent(address, prevContractClassId, newContractClassId, blockOfChange);
    }
    toContractInstanceUpdate() {
        return {
            address: this.address,
            prevContractClassId: this.prevContractClassId,
            newContractClassId: this.newContractClassId,
            blockOfChange: this.blockOfChange
        };
    }
}
