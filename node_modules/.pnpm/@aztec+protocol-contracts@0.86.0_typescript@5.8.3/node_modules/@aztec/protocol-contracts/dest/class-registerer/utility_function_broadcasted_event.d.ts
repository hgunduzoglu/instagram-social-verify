/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { ARTIFACT_FUNCTION_TREE_MAX_HEIGHT } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
import type { Tuple } from '@aztec/foundation/serialize';
import { FieldReader } from '@aztec/foundation/serialize';
import { FunctionSelector } from '@aztec/stdlib/abi';
import type { UtilityFunction, UtilityFunctionWithMembershipProof } from '@aztec/stdlib/contract';
import type { ContractClassLog } from '@aztec/stdlib/logs';
/** Event emitted from the ContractClassRegisterer. */
export declare class UtilityFunctionBroadcastedEvent {
    readonly contractClassId: Fr;
    readonly artifactMetadataHash: Fr;
    readonly privateFunctionsArtifactTreeRoot: Fr;
    readonly artifactFunctionTreeSiblingPath: Tuple<Fr, typeof ARTIFACT_FUNCTION_TREE_MAX_HEIGHT>;
    readonly artifactFunctionTreeLeafIndex: number;
    readonly utilityFunction: BroadcastedUtilityFunction;
    constructor(contractClassId: Fr, artifactMetadataHash: Fr, privateFunctionsArtifactTreeRoot: Fr, artifactFunctionTreeSiblingPath: Tuple<Fr, typeof ARTIFACT_FUNCTION_TREE_MAX_HEIGHT>, artifactFunctionTreeLeafIndex: number, utilityFunction: BroadcastedUtilityFunction);
    static isUtilityFunctionBroadcastedEvent(log: ContractClassLog): boolean;
    static fromLog(log: ContractClassLog): UtilityFunctionBroadcastedEvent;
    static fromFields(fields: Fr[] | FieldReader): UtilityFunctionBroadcastedEvent;
    toFunctionWithMembershipProof(): UtilityFunctionWithMembershipProof;
}
export declare class BroadcastedUtilityFunction implements UtilityFunction {
    /** Selector of the function. Calculated as the hash of the method name and parameters. The specification of this is not enforced by the protocol. */
    readonly selector: FunctionSelector;
    /** Artifact metadata hash */
    readonly metadataHash: Fr;
    /** Brillig bytecode */
    readonly bytecode: Buffer;
    constructor(
    /** Selector of the function. Calculated as the hash of the method name and parameters. The specification of this is not enforced by the protocol. */
    selector: FunctionSelector, 
    /** Artifact metadata hash */
    metadataHash: Fr, 
    /** Brillig bytecode */
    bytecode: Buffer);
    static fromFields(fields: Fr[] | FieldReader): BroadcastedUtilityFunction;
}
//# sourceMappingURL=utility_function_broadcasted_event.d.ts.map