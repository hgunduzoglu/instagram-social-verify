"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyDKIMSignature = void 0;
exports.generateEmailVerifierInputs = generateEmailVerifierInputs;
exports.generateEmailVerifierInputsFromDKIMResult = generateEmailVerifierInputsFromDKIMResult;
const helpers_1 = require("@zk-email/helpers");
const dkim_1 = require("@zk-email/helpers/dist/dkim");
const NoirBignum = __importStar(require("@mach-34/noir-bignum-paramgen"));
const utils_1 = require("./utils");
var dkim_2 = require("@zk-email/helpers/dist/dkim");
Object.defineProperty(exports, "verifyDKIMSignature", { enumerable: true, get: function () { return dkim_2.verifyDKIMSignature; } });
/** Formatted for BoundedVec in case used in other places */
function removeSoftLineBreaks(body) {
    const result = [];
    let i = 0;
    let count = 0;
    while (i < body.storage.length) {
        if (i + 2 < body.storage.length &&
            body.storage[i] === "61" && // '=' character
            body.storage[i + 1] === "13" && // '\r' character
            body.storage[i + 2] === "10") {
            // '\n' character
            // Skip the soft line break sequence
            i += 3; // Move past the soft line break
        }
        else {
            result.push(body.storage[i]);
            i++;
            count++;
        }
    }
    // Pad the result with zeros to make it the same length as the body
    while (result.length < body.storage.length) {
        result.push("0");
    }
    return {
        storage: result,
        len: count.toString()
    };
}
/**
 * @description Generate circuit inputs for the EmailVerifier circuit from raw email content
 * @param rawEmail Full email content as a buffer or string
 * @param params Arguments to control the input generation
 * @returns Circuit inputs for the EmailVerifier circuit
 */
async function generateEmailVerifierInputs(rawEmail, params = {}) {
    const dkimResult = await (0, dkim_1.verifyDKIMSignature)(rawEmail, undefined, undefined, true);
    return generateEmailVerifierInputsFromDKIMResult(dkimResult, params);
}
/**
 * @description Generate circuit inputs for the EmailVerifier circuit from DKIMVerification result
 * @param dkimResult DKIMVerificationResult containing email data and verification result
 * @param params Arguments to control the input generation
 * @returns Circuit inputs for the EmailVerifier circuit
 */
function generateEmailVerifierInputsFromDKIMResult(dkimResult, params = {}) {
    const { headers, body, bodyHash, publicKey, signature, modulusLength } = dkimResult;
    // SHA add padding
    const [messagePadded] = (0, helpers_1.sha256Pad)(headers, params.maxHeadersLength || helpers_1.MAX_HEADER_PADDED_BYTES);
    // set inputs used in all cases
    const circuitInputs = {
        header: {
            storage: (0, helpers_1.Uint8ArrayToCharArray)(messagePadded),
            len: headers.length.toString(),
        },
        pubkey: {
            modulus: NoirBignum.bnToLimbStrArray(publicKey, modulusLength),
            redc: NoirBignum.bnToRedcLimbStrArray(publicKey, modulusLength),
        },
        // modified from original: use noir bignum to format
        signature: NoirBignum.bnToLimbStrArray(signature, modulusLength),
        dkim_header_sequence: (0, utils_1.getHeaderSequence)(headers, "dkim-signature"),
    };
    // removed: header mask
    if (!params.ignoreBodyHashCheck) {
        if (!body || !bodyHash) {
            throw new Error("body and bodyHash are required when ignoreBodyHashCheck is false");
        }
        const bodyHashIndex = headers.toString().indexOf(bodyHash);
        const maxBodyLength = params.maxBodyLength || helpers_1.MAX_BODY_PADDED_BYTES;
        // 65 comes from the 64 at the end and the 1 bit in the start, then 63 comes from the formula to round it up to the nearest 64.
        // see sha256algorithm.com for a more full explanation of padding length
        const bodySHALength = Math.floor((body.length + 63 + 65) / 64) * 64;
        const [bodyPadded, bodyPaddedLen] = (0, helpers_1.sha256Pad)(body, Math.max(maxBodyLength, bodySHALength));
        const { precomputedSha, bodyRemainingLength, ...rest } = (0, helpers_1.generatePartialSHA)({
            body: bodyPadded,
            bodyLength: bodyPaddedLen,
            selectorString: params.shaPrecomputeSelector,
            maxRemainingBodyLength: maxBodyLength,
        });
        // code smell but it passes the linter
        let { bodyRemaining } = rest;
        // idk why this gets out of sync, todo: fix
        if (params.shaPrecomputeSelector &&
            bodyRemaining.length !== bodyRemainingLength) {
            bodyRemaining = bodyRemaining.slice(0, bodyRemainingLength);
        }
        circuitInputs.body = {
            storage: (0, helpers_1.Uint8ArrayToCharArray)(bodyRemaining),
            len: body.length.toString(),
        };
        circuitInputs.body_hash_index = bodyHashIndex.toString();
        if (params.shaPrecomputeSelector) {
            // can use exact body lengths
            const selector = new TextEncoder().encode(params.shaPrecomputeSelector);
            const selectorIndex = (0, helpers_1.findIndexInUint8Array)(body, selector);
            const shaCutoffIndex = Math.floor(selectorIndex / 64) * 64;
            const remainingBodyLength = body.length - shaCutoffIndex;
            circuitInputs.partial_body_real_length = body.length.toString();
            circuitInputs.body.len = remainingBodyLength.toString();
            // format back into u32 so noir doesn't have to do it
            circuitInputs.partial_body_hash = Array.from((0, utils_1.u8ToU32)(precomputedSha)).map((x) => x.toString());
        }
        // masking
        if (params.headerMask)
            circuitInputs.header_mask = params.headerMask.map((x) => x.toString());
        if (params.bodyMask)
            circuitInputs.body_mask = params.bodyMask.map((x) => x.toString());
        // remove soft line breaks
        if (params.removeSoftLineBreaks) {
            circuitInputs.decoded_body = removeSoftLineBreaks(circuitInputs.body);
        }
        // address extraction
        if (params.extractFrom) {
            const fromSequences = (0, utils_1.getAddressHeaderSequence)(headers, "from");
            circuitInputs.from_header_sequence = fromSequences[0];
            circuitInputs.from_address_sequence = fromSequences[1];
        }
        if (params.extractTo) {
            const toSequences = (0, utils_1.getAddressHeaderSequence)(headers, "to");
            circuitInputs.to_header_sequence = toSequences[0];
            circuitInputs.to_address_sequence = toSequences[1];
        }
    }
    return circuitInputs;
}
