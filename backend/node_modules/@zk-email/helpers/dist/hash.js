"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.poseidonLarge = poseidonLarge;
exports.poseidonModular = poseidonModular;
const circomlibjs_1 = require("circomlibjs");
const binary_format_1 = require("./binary-format");
async function poseidonLarge(input, numChunks, bitsPerChunk) {
    const poseidon = await (0, circomlibjs_1.buildPoseidon)();
    const pubkeyChunked = (0, binary_format_1.bigIntToChunkedBytes)(input, bitsPerChunk, numChunks);
    const hash = poseidon(pubkeyChunked);
    return poseidon.F.toObject(hash);
}
/**
 * Calculates Poseidon hash of an arbitrary number of inputs
 * Mimics the behavior of PoseidonModular circuit
 * @param inputs Array of bigints to be hashed
 * @returns Promise<bigint> The final hash
 */
async function poseidonModular(inputs) {
    const poseidon = await (0, circomlibjs_1.buildPoseidon)();
    const CHUNK_SIZE = 16;
    // Calculate number of chunks
    const numElements = inputs.length;
    let chunks = Math.floor(numElements / CHUNK_SIZE);
    const lastChunkSize = numElements % CHUNK_SIZE;
    if (lastChunkSize !== 0) {
        chunks += 1;
    }
    let out = null;
    // Process each chunk
    for (let i = 0; i < chunks; i++) {
        const start = i * CHUNK_SIZE;
        let end = start + CHUNK_SIZE;
        if (end > numElements) {
            end = numElements;
        }
        const chunk = inputs.slice(start, end);
        const chunkHash = poseidon.F.toObject(poseidon(chunk));
        if (i === 0) {
            out = chunkHash;
        }
        else {
            out = poseidon.F.toObject(poseidon([out, chunkHash]));
        }
    }
    if (out === null) {
        throw new Error('No inputs provided');
    }
    return out;
}
